<html>
<head>
<title>Binary Classifier Evaluation made easy with HandySpark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HandySpark 简化二元分类器评估</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/binary-classifier-evaluation-made-easy-with-handyspark-3b1e69c12b4f?source=collection_archive---------13-----------------------#2019-03-11">https://towardsdatascience.com/binary-classifier-evaluation-made-easy-with-handyspark-3b1e69c12b4f?source=collection_archive---------13-----------------------#2019-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/84fc2cf94c7251850bc39e410d738277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8E8uKv-BMEzXPt3h"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sjbaren?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">SJ Baren</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0e7b" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">TLDR；</h1><p id="c7b4" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir"> HandySpark </strong>是一个 Python 包，旨在改善<em class="lz"> PySpark </em>用户体验，尤其是在涉及到<strong class="ld ir">探索性数据分析</strong>时，包括<strong class="ld ir">可视化</strong>功能，以及现在的<strong class="ld ir">二进制分类器的扩展评估指标。</strong></p><p id="e7ef" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">使用 Google Colab 亲自尝试一下:</p><div class="mf mg gp gr mh mi"><a href="https://colab.research.google.com/github/dvgodoy/handyspark/blob/master/notebooks/Exploring_Titanic.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd ir gy z fp mn fr fs mo fu fw ip bi translated">谷歌联合实验室</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">使用 HandySpark 探索泰坦尼克号</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">colab.research.google.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw jw mi"/></div></div></a></div><p id="7b40" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">检查存储库:</p><div class="mf mg gp gr mh mi"><a href="https://github.com/dvgodoy/handyspark" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd ir gy z fp mn fr fs mo fu fw ip bi translated">dvgodoy/handyspark</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">HandySpark——带来熊猫般的能力，激发数据帧——dvgodoy/HandySpark</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">github.com</p></div></div><div class="mr l"><div class="mx l mt mu mv mr mw jw mi"/></div></div></a></div><h1 id="8804" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="b524" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在我之前的<a class="ae kc" rel="noopener" target="_blank" href="/handyspark-bringing-pandas-like-capabilities-to-spark-dataframes-5f1bcea9039e">帖子</a>中，我介绍了<strong class="ld ir"> HandySpark </strong>，这是我为<em class="lz"> PySpark </em>开发的一个包，用来帮助缩小<em class="lz">熊猫</em>和<em class="lz"> Spark </em>数据帧之间的差距。</p><p id="b013" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">今天，我很高兴地宣布新版本的<a class="ae kc" href="https://github.com/dvgodoy/handyspark/releases/tag/v0.2.0a1" rel="noopener ugc nofollow" target="_blank">发布</a>，它不仅解决了<em class="lz">分层</em>操作的一些<em class="lz">性能问题</em>(现在应该快几倍了！)，而且<strong class="ld ir">使得评估二进制分类器更加容易。</strong></p><h1 id="1c2a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">二元分类任务</h1><p id="a6e4" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们将使用一个简单的二进制分类任务来说明<em class="lz"> HandySpark </em>提供的扩展评估功能:再一次使用<strong class="ld ir">泰坦尼克号</strong>数据集预测乘客存活率。</p><p id="a39b" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">让我们首先设置好一切，然后<em class="lz">加载</em>我们的数据:</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Setting everything up and loading the Titanic dataset :-)</figcaption></figure><p id="f093" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">要评估一个模型，我们需要先<em class="lz">训练</em>它。为了训练一个模型，我们需要<em class="lz">首先清理</em>数据集。所以，就从这点开始吧！</p><h1 id="3ec7" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">使用 HandySpark 清理数据</h1><p id="888c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们知道<code class="fe ne nf ng nh b">Age, Cabin</code>和<code class="fe ne nf ng nh b">Embarked</code>缺少值。你可以使用<code class="fe ne nf ng nh b"><a class="ae kc" href="https://dvgodoy.github.io/handyspark/handyspark.html#handyspark.HandyFrame.isnull" rel="noopener ugc nofollow" target="_blank">isnull</a></code>方法很容易地检验这一点。</p><p id="eee3" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">为了让我们的模型和管道尽可能简单，让我们只使用<em class="lz">数字</em> <em class="lz">变量</em>，比如<code class="fe ne nf ng nh b">Age</code>、<code class="fe ne nf ng nh b">Fare</code>、<code class="fe ne nf ng nh b">SibSp</code>和<code class="fe ne nf ng nh b">Parch.</code></p><p id="a039" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">对于<strong class="ld ir">输入<code class="fe ne nf ng nh b">Age</code>的缺失值</strong>，我们可以只对每个缺失值使用一个<em class="lz">简单平均值</em>，对吗？但是你真的认为一等舱、二等舱和三等舱的男女乘客的年龄差不多吗？</p><p id="0890" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">让我们使用<code class="fe ne nf ng nh b"><a class="ae kc" href="https://dvgodoy.github.io/handyspark/handyspark.sql.html#handyspark.sql.dataframe.HandyFrame.stratify" rel="noopener ugc nofollow" target="_blank">stratify</a></code>操作来检查一下，就像这样:</p><pre class="my mz na nb gt ni nh nj nk aw nl bi"><span id="94b3" class="nm ke iq nh b gy nn no l np nq">hdf.stratify(['Pclass', 'Sex']).cols['Age'].mean()</span><span id="fdf9" class="nm ke iq nh b gy nr no l np nq">Pclass  Sex   <br/>1       female    34.611765<br/>        male      41.281386<br/>2       female    28.722973<br/>        male      30.740707<br/>3       female    21.750000<br/>        male      26.507589<br/>Name: Age, dtype: float64</span></pre><p id="d9b2" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">这显然是有区别的……女性比男性年轻，阶级越低，乘客越年轻。毫不奇怪，我会说…</p><p id="d749" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">那么<strong class="ld ir">离群值</strong>呢？我们可以使用<a class="ae kc" href="https://en.wikipedia.org/wiki/Outlier#Tukey's_fences" rel="noopener ugc nofollow" target="_blank">图基的栅栏</a>方法来识别然后<strong class="ld ir">栅栏</strong>值被认为是极端的。对于<code class="fe ne nf ng nh b">Fare</code>，我们有多少离群值？</p><pre class="my mz na nb gt ni nh nj nk aw nl bi"><span id="b545" class="nm ke iq nh b gy nn no l np nq">hdf.cols['Fare'].outliers(k=3)</span><span id="103a" class="nm ke iq nh b gy nr no l np nq">Fare    53<br/>Name: outliers, dtype: int64</span></pre><p id="ef76" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">请记住，图基的栅栏非常敏感——他们假设高于 <em class="lz"> k 乘以四分位数间距(IQR) </em>的一切都是<strong class="ld ir">极值</strong>。在我们的例子中，它导致了 53 个异常值！你可以尝试不同的 k 值来校准它，尽管…</p><p id="bd85" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">所以，让我们用我们发现的数据来清理它。首先，我们<em class="lz">根据给定<code class="fe ne nf ng nh b">Pclass</code>和<code class="fe ne nf ng nh b">Sex</code>的平均值填充</em>缺失的<code class="fe ne nf ng nh b">Age</code>值。接下来，我们使用 Tukey 的方法<em class="lz">保护</em> <code class="fe ne nf ng nh b">Fare</code>值:</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Cleaning up!</figcaption></figure><h1 id="f7c7" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">建立模型</h1><p id="0dc4" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一旦我们有了干净的数据集，我们就可以建立一个简单的分类器来预测乘客是否在泰坦尼克号灾难中幸存。让我们使用 Spark 的<code class="fe ne nf ng nh b">RandomForestClassifier</code>来完成这个任务。</p><p id="5e62" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">但是，记住 Spark ML 算法需要将所有特征整齐地<em class="lz">组装</em>成一个<strong class="ld ir">特征向量</strong>。此外，该特征向量<strong class="ld ir">不接受<em class="lz">缺失的</em>值。</strong></p><p id="9d35" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">这个怎么处理？我们可以简单地使用<em class="lz"> HandySpark </em>的<code class="fe ne nf ng nh b">imputer</code>和<code class="fe ne nf ng nh b">fencer</code>方法来创建相应的<strong class="ld ir">变压器</strong>来填充缺失值和隔离异常值。然后，我们将这些变压器添加到我们的<strong class="ld ir">管道</strong>中，我们就可以开始了！</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Training a classifier and making predictions</figcaption></figure><p id="c0bf" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">我们的<strong class="ld ir">预测</strong>是什么样子的？让我们把数据帧做成一个<em class="lz">手帧</em>，看看我们的标签和分类器生成的预测:</p><pre class="my mz na nb gt ni nh nj nk aw nl bi"><span id="8828" class="nm ke iq nh b gy nn no l np nq">predictions.toHandy().cols[['probability', 'prediction', 'Survived']][:5]</span></pre><figure class="my mz na nb gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/3d2f0b23fb2d93530ca8cf0016840daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*waTx3VWWI9lcI_b5ADBwNw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">First 5 rows from our predictions</figcaption></figure><p id="185c" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated"><strong class="ld ir">概率</strong>列包含一个<em class="lz">向量</em>，其概率分别与类别 0 和 1 相关联。为了<em class="lz">评估</em>的目的，我们需要成为<em class="lz">阳性</em>病例的概率，因此我们应该查看概率向量的<em class="lz">第二个</em>元素。<strong class="ld ir">预测</strong>栏显示了相应的<strong class="ld ir">类</strong>，假设<em class="lz">阈值为 0.5 </em>。</p><h1 id="87ba" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">评估模型</h1><p id="9237" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们的模型有多好？我们可以只计算具有<em class="lz">匹配预测和幸存列</em>的行的比例，这就是我们的<strong class="ld ir">准确度</strong>。然而，事实证明，准确度是<strong class="ld ir">而不是</strong>评价二元分类器的一个很好的标准。</p><p id="baf0" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">为了真正说明我们的模型有多好，我们需要其他指标，如<strong class="ld ir">真阳性率</strong> ( <strong class="ld ir"> TPR </strong>，也称为<strong class="ld ir">召回</strong>)、<strong class="ld ir">假阳性率</strong> ( <strong class="ld ir"> FPR </strong>)和<strong class="ld ir">精度</strong>，这将<strong class="ld ir"> <em class="lz">随我们选择的<strong class="ld ir">阈值</strong>而变化</em>，从而将预测概率转化为预测类别(0 或 1</strong></p><p id="639d" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">如果我们检查<strong class="ld ir">每一个可能的阈值</strong>并计算这些<em class="lz">度量</em>，我们可以为给定的模型建立<strong class="ld ir">接收器工作特性</strong> ( <strong class="ld ir"> ROC </strong>)曲线和<strong class="ld ir">精度召回</strong> ( <strong class="ld ir"> PR </strong>)曲线。</p><p id="df2f" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">这就带来了另一个问题:<em class="lz">如何利用这些曲线</em>比较两个模型？它们可能在不同的点交叉，对吗？解决这个问题的一个方法是查看曲线下的<strong class="ld ir">面积:粗略地说，<em class="lz">面积越大，<em class="lz">模型越好。这样我们就可以计算 ROC </em></em></strong>曲线下的<strong class="ld ir">面积(<strong class="ld ir"> AUROC </strong>、<strong class="ld ir"> ROC AUC </strong>，或者有时只是<strong class="ld ir"> AUC </strong>)和 PR </strong>曲线下的<strong class="ld ir">面积(<strong class="ld ir"> PR AUC </strong>)。</strong></p><blockquote class="nt nu nv"><p id="4ee0" class="lb lc lz ld b le ma lg lh li mb lk ll nw mc lo lp nx md ls lt ny me lw lx ly ij bi translated">如果你想了解所有这些指标的更多信息，请查看这些帖子:<a class="ae kc" rel="noopener" target="_blank" href="/confused-by-the-confusion-matrix-e26d5e1d74eb">被困惑矩阵</a>、<a class="ae kc" rel="noopener" target="_blank" href="/receiver-operating-characteristic-curves-demystified-in-python-bd531a4364d0">接收器操作特性曲线揭秘</a>、<a class="ae kc" rel="noopener" target="_blank" href="/understanding-auc-roc-curve-68b2303cc9c5">了解 AUC — ROC 曲线</a>和<a class="ae kc" href="http://www.navan.name/roc/" rel="noopener ugc nofollow" target="_blank">了解 ROC 曲线</a>(互动)。</p></blockquote><h1 id="20be" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">使用 PySpark 评估模型</h1><p id="c49d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们既有<em class="lz">好的</em>也有一些<em class="lz">坏的</em>消息……好的<em class="lz">消息是:<em class="lz"> PySpark </em>给了我们<strong class="ld ir">两个</strong> ROC AUC 和 PR AUC。坏消息是:<em class="lz"> PySpark </em>只给了我们<strong class="ld ir">那个:-(</strong></em></p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Using PySpark Evaluator to get ROC AUC and PR AUC</figcaption></figure><p id="2b49" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">如果我们想用<em class="lz">不同的阈值</em>做实验呢？出手相救:-)</p><h1 id="991e" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">使用 HandySpark 评估模型</h1><p id="1b98" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><em class="lz"> HandySpark </em>扩展了 PySpark 的<code class="fe ne nf ng nh b">BinaryClassificationMetrics</code>，因为它的 Java 对应物已经有了几个检索指标和阈值的方法，现在由<em class="lz"> HandySpark </em>公开。但是也有新实现的方法。</p><p id="1d3a" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated"><em class="lz"> HandySpark </em>还可以使用包含<strong class="ld ir">预测概率</strong>和<strong class="ld ir">标签</strong>的数据帧作为自变量，如下要点所示:</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Plotring ROC and PR curves, getting metrics by threshold and confusion matrices with HandySpark!</figcaption></figure><p id="5e28" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">让我们深入研究评估模型的所有这些新的可能性。</p><h2 id="e1fa" class="nm ke iq bd kf nz oa dn kj ob oc dp kn lm od oe kr lq of og kv lu oh oi kz oj bi translated">绘制曲线</h2><p id="4179" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一张图片胜过千言万语！所以，让我们从使用<code class="fe ne nf ng nh b">plot_roc_curve</code>和<code class="fe ne nf ng nh b">plot_pr_curve</code>方法的两条曲线的<strong class="ld ir">图</strong>开始。就这么简单:</p><pre class="my mz na nb gt ni nh nj nk aw nl bi"><span id="af62" class="nm ke iq nh b gy nn no l np nq">fig, axs = plt.subplots(1, 2, figsize=(12, 4))<br/>bcm.plot_roc_curve(ax=axs[0])<br/>bcm.plot_pr_curve(ax=axs[1])</span></pre><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/3766181fefba2d0dc62bd9ba647b3728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mjB3fHAOjcIJ3RYfQdkcCg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">ROC and PR curves</figcaption></figure><p id="871e" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated"><strong class="ld ir">瞧啊</strong>！现在我们可以说，如果我们愿意接受 20%的<em class="lz">假阳性率</em>，我们将得到 60%以上的<em class="lz">真阳性率</em>。够好吗？酷！</p><p id="52f2" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">你会问，我们应该使用哪个<strong class="ld ir">阈值</strong>来实现这一点？</p><h2 id="f9c6" class="nm ke iq bd kf nz oa dn kj ob oc dp kn lm od oe kr lq of og kv lu oh oi kz oj bi translated">阈值和指标</h2><p id="4e50" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们可以使用<code class="fe ne nf ng nh b">getMetricsByThreshold</code>方法获得<strong class="ld ir">所有阈值</strong>和相应的<strong class="ld ir">指标</strong>。它返回一个 Spark 数据帧，然后我们可以过滤出感兴趣的指标(在我们的例子中，FPR 介于 19%和 21%之间):</p><pre class="my mz na nb gt ni nh nj nk aw nl bi"><span id="62df" class="nm ke iq nh b gy nn no l np nq">bcm.getMetricsByThreshold().filter('fpr between 0.19 and 0.21').toPandas()</span></pre><figure class="my mz na nb gt jr gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/5786d7e1782ed2e939e72efc0f6326dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*5V09rI_DLCwTzXh5hgYjeA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Thresholds for FPR between 19% and 21%</figcaption></figure><p id="5faa" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">我们需要<em class="lz">的误报率</em>最多为 20%，那么对应的<strong class="ld ir">阈值为 0.415856 </strong>。这将给我们 68.1%的<em class="lz">真阳性率</em> ( <em class="lz">召回</em>)和 68.3%的<em class="lz">精度</em>。</p><p id="83b6" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">我们还可以查看使用特定的<em class="lz">阈值</em>构建的<em class="lz">混淆矩阵</em>，这产生了我们刚刚获得的指标。</p><h2 id="b265" class="nm ke iq bd kf nz oa dn kj ob oc dp kn lm od oe kr lq of og kv lu oh oi kz oj bi translated">混淆矩阵</h2><p id="4ac0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">混淆矩阵可以，呃… <em class="lz">混淆</em>！；-)为了尽量减少阅读时可能产生的任何误解，我已经用<strong class="ld ir">标记了</strong>列和行，所以你<em class="lz">不需要猜测</em>哪个类先出现，哪个是预测值和实际值。</p><p id="00f0" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">用你选择的<em class="lz">阈值</em>调用<code class="fe ne nf ng nh b">print_confusion_matrix</code>就行了，就这么简单:</p><pre class="my mz na nb gt ni nh nj nk aw nl bi"><span id="ddfb" class="nm ke iq nh b gy nn no l np nq">bcm.print_confusion_matrix(.415856)</span></pre><figure class="my mz na nb gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/fa2f3dd49ee1be9346104d12fbe7e58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/1*5RhZxE39HGTAwZpOh72aCg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Confusion Matrix — not so confusing anymore :-)</figcaption></figure><h1 id="6534" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">最后的想法</h1><p id="0961" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我的目标是<strong class="ld ir">改善 PySpark 用户体验</strong>，让执行<strong class="ld ir">数据清理</strong>和<strong class="ld ir">模型</strong> <strong class="ld ir">评估</strong>变得更加容易。不用说，这是一项正在进行的工作，我已经计划了更多的改进。</p><p id="2092" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">如果你是使用<em class="lz"> PySpark </em>的数据科学家，我希望你尝试一下<strong class="ld ir"> HandySpark </strong>并<strong class="ld ir">让我知道你对它的想法:-) </strong></p><div class="mf mg gp gr mh mi"><a href="https://github.com/dvgodoy/handyspark" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd ir gy z fp mn fr fs mo fu fw ip bi translated">dvgodoy/handyspark</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">HandySpark——带来熊猫般的能力，激发数据帧——dvgodoy/HandySpark</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">github.com</p></div></div><div class="mr l"><div class="on l mt mu mv mr mw jw mi"/></div></div></a></div><p id="8a51" class="pw-post-body-paragraph lb lc iq ld b le ma lg lh li mb lk ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated"><em class="lz">如果你有任何想法、评论或问题，请在下方留言或联系我</em> <a class="ae kc" href="https://twitter.com/dvgodoy" rel="noopener ugc nofollow" target="_blank"> <em class="lz">推特</em> </a> <em class="lz">。</em></p></div></div>    
</body>
</html>