<html>
<head>
<title>How to use airflow-style DAGs for highly effective data science workflows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将气流式 Dag 用于高效的数据科学工作流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-airflow-style-dags-for-highly-effective-data-science-workflows-b52053dedd32?source=collection_archive---------10-----------------------#2019-07-24">https://towardsdatascience.com/how-to-use-airflow-style-dags-for-highly-effective-data-science-workflows-b52053dedd32?source=collection_archive---------10-----------------------#2019-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4b67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Airflow 和 Luigi 对于数据工程来说很棒，但是对于数据科学来说并没有优化。<a class="ae ko" href="https://github.com/d6t/d6tflow" rel="noopener ugc nofollow" target="_blank"> d6tflow </a>为数据科学带来了气流式的 Dag。</p><h1 id="f027" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">数据科学工作流是 Dag</h1><p id="fd38" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">数据科学工作流通常如下所示。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/db2a93224bcc4c179e8a5669d6703328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nDK9tyz89UJXN1IoQ33CSA.png"/></div></div></figure><p id="530d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此工作流类似于数据工程工作流。它包括将参数化的任务链接在一起，这些任务在彼此之间传递多个输入和输出。参见<a class="ae ko" rel="noopener" target="_blank" href="/4-reasons-why-your-machine-learning-code-is-probably-bad-c291752e4953">为什么你的机器学习代码可能不好的 4 个原因</a>为什么在函数之间传递数据或硬编码文件/数据库名称而没有明确定义任务依赖关系不是编写数据科学代码的好方法。</p><pre class="lt lu lv lw gt me mf mg mh aw mi bi"><span id="e107" class="mj kq it mf b gy mk ml l mm mn"># bad data science code<br/>def process_data(data, do_preprocess):<br/>    data = do_stuff(data, do_preprocess)<br/>    data.to_pickle('data.pkl')</span><span id="0bfd" class="mj kq it mf b gy mo ml l mm mn">data = pd.read_csv('data.csv')<br/>process_data(data, True)<br/>df_train = pd.read_pickle(df_train)<br/>model = sklearn.svm.SVC()<br/>model.fit(df_train.iloc[:,:-1], df_train['y'])</span></pre><h1 id="eb50" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">R&amp;D 与生产数据工作流</h1><p id="a4ff" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">使用<a class="ae ko" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank">气流</a>和<a class="ae ko" href="https://github.com/spotify/luigi" rel="noopener ugc nofollow" target="_blank"> luigi </a>比编写用于管理数据工作流的功能代码前进了一大步。虽然数据工程和数据科学工作流相似，但它们的注意事项是相同的。这两个库都是为数据工程师在生产环境中使用而设计的，其重点是:</p><ul class=""><li id="7e59" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">确保一切按时顺利进行</li><li id="5d17" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">时间安排和协调</li><li id="0537" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">从故障中恢复</li><li id="a497" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">数据质量</li></ul><p id="0793" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相比之下，研发工作流程的重点是:</p><ul class=""><li id="f553" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">产生洞察力</li><li id="2a22" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">原型速度</li><li id="b114" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">评估不同模型和参数的预测能力</li><li id="e5fa" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">可视化输出</li></ul><p id="7788" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，研发工作流程:</p><ul class=""><li id="9070" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">不太明确</li><li id="e13e" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">涉及反复试验</li><li id="2971" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">当模型、参数和数据发生变化时，需要频繁重置任务和输出</li><li id="19b4" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">接受数据工程师的输出</li></ul><h1 id="314a" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">R&amp;D 环境中的气流/luigi 问题</h1><p id="49f7" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">由于这两个库都针对数据工程生产环境进行了优化，因此数据科学研发环境的 UX 并不是很大:</p><ul class=""><li id="8392" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">用于读/写数据的湿代码</li><li id="b1df" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">手动跟踪保存数据的文件名或数据库表名</li><li id="3db7" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">当模型、参数和数据改变时，不方便重新设置任务</li><li id="c893" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">不方便跟踪不同参数设置的模型结果</li></ul><p id="d431" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在复杂的数据工作流中手动跟踪文件名…不可扩展。</p><pre class="lt lu lv lw gt me mf mg mh aw mi bi"><span id="f838" class="mj kq it mf b gy mk ml l mm mn"># example of manually caching dataframes and keep track of files<br/>cfg_fpath_cc_base = cfg_fpath_base + 'vendor/'<br/>cfg_fpath_cc_raw = cfg_fpath_cc_base + 'df_cc_raw.pkl'<br/>cfg_fpath_cc_raw_recent2 = cfg_fpath_cc_base + 'df_cc_raw_recent2.pkl'<br/>cfg_fpath_cc_yoy = cfg_fpath_cc_base + 'df_cc_yoy.pkl'<br/>cfg_fpath_cc_yoy_bbg = cfg_fpath_cc_base + 'df_cc_yoy_bbg.pkl'<br/>cfg_fpath_cc_yoy_fds = cfg_fpath_cc_base + 'df_cc_yoy_fds.pkl'<br/>cfg_fpath_cc_var_fds = cfg_fpath_cc_base + 'df_cc_var_fds.pkl'<br/>cfg_fpath_cc_yoy_recent2 = cfg_fpath_cc_base + 'df_cc_yoy_recent2.pkl'<br/>cfg_fpath_cc_actual = cfg_fpath_cc_base + 'df_cc_sales_actual.pkl'<br/>cfg_fpath_cc_monthly = cfg_fpath_cc_base + 'df_cc_monthly.pkl'<br/>cfg_fpath_cc_yoy_cs2 = 'data/processed/df_cc_yoy_cs2.pq' # consistent shopper data for new methodology from 2018</span></pre><h1 id="dfc7" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">d6tflow 与 airflow/luigi 有何不同</h1><p id="05dc" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">d6tflow 针对数据科学研究和开发工作流进行了优化。以下是在数据科学中使用 d6tflow 的好处。</p><h1 id="a66b" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">好处:任务有输入和输出数据</h1><p id="bd80" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">不再需要手动加载和保存数据，而是外包给图书馆。这可以更好地伸缩，并减少维护，因为输入/输出数据的位置可以改变，而不必重写代码。这也使得数据工程师更容易将数据交给数据科学家。</p><pre class="lt lu lv lw gt me mf mg mh aw mi bi"><span id="0626" class="mj kq it mf b gy mk ml l mm mn">class TaskProcess(d6tflow.tasks.TaskPqPandas): # define output format</span><span id="b32e" class="mj kq it mf b gy mo ml l mm mn">    def requires(self):<br/>        return TaskGetData() # define dependency</span><span id="fe25" class="mj kq it mf b gy mo ml l mm mn">    def run(self):<br/>        data = self.input().load() # load input data<br/>        data = do_stuff(data) # process data<br/>        self.save(data) # save output data</span></pre><h1 id="1a8a" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">好处:轻松使任务无效</h1><p id="35c7" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">实现了常见的失效场景。当您在试错过程中更改代码和数据时，这将提高原型开发速度。</p><pre class="lt lu lv lw gt me mf mg mh aw mi bi"><span id="223f" class="mj kq it mf b gy mk ml l mm mn"># force execution including downstream tasks<br/>d6tflow.run(TaskTrain(), force=TaskGetData())</span><span id="9efe" class="mj kq it mf b gy mo ml l mm mn"># reset single task<br/>TaskGetData().invalidate()</span><span id="42f9" class="mj kq it mf b gy mo ml l mm mn"># reset all downstream tasks<br/>d6tflow.invalidate_downstream(TaskGetData(), TaskTrain())</span><span id="61a5" class="mj kq it mf b gy mo ml l mm mn"># reset all upstream tasks<br/>d6tflow.invalidate_upstream(TaskTrain())</span></pre><h1 id="7d95" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">优点:使用不同的参数轻松训练模型</h1><p id="011e" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">更改参数后，您可以智能地重新运行工作流。参数从目标任务传递到相关的下游任务。因此，您不再需要手动跟踪要更新的任务，从而提高了原型开发速度并减少了错误。</p><pre class="lt lu lv lw gt me mf mg mh aw mi bi"><span id="03a6" class="mj kq it mf b gy mk ml l mm mn">d6tflow.preview(TaskTrain(do_preprocess=False))</span><span id="ba25" class="mj kq it mf b gy mo ml l mm mn">'''<br/>└─--[TaskTrain-{'do_preprocess': 'False'} (PENDING)]<br/>   └─--[TaskPreprocess-{'do_preprocess': 'False'} (PENDING)]<br/>      └─--[TaskGetData-{} (COMPLETE)] =&gt; this doesn't change and doesn't need to rerun<br/>'''</span></pre><h1 id="2a7f" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">好处:轻松比较模型</h1><p id="42e7" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">用不同参数训练的不同模型可以容易地加载和比较。</p><pre class="lt lu lv lw gt me mf mg mh aw mi bi"><span id="21d0" class="mj kq it mf b gy mk ml l mm mn">df_train1 = TaskPreprocess().output().load()<br/>model1 = TaskTrain().output().load()<br/>print(sklearn.metrics.accuracy_score(df_train1['y'],model1.predict(df_train1.iloc[:,:-1])))</span><span id="9161" class="mj kq it mf b gy mo ml l mm mn">df_train2 = TaskPreprocess(do_preprocess=False).output().load()<br/>model2 = TaskTrain(do_preprocess=False).output().load()<br/>print(sklearn.metrics.accuracy_score(df_train2['y'],model2.predict(df_train2.iloc[:,:-1])))</span></pre><h1 id="d5af" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">加速数据工程师向数据科学家的移交</h1><p id="fb77" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">要快速共享工作流输出文件，可以使用<a class="ae ko" href="https://github.com/d6t/d6tpipe" rel="noopener ugc nofollow" target="_blank"> d6tpipe </a>。参见<a class="ae ko" href="https://d6tflow.readthedocs.io/en/latest/collaborate.html" rel="noopener ugc nofollow" target="_blank">共享工作流和输出</a>。</p><pre class="lt lu lv lw gt me mf mg mh aw mi bi"><span id="1e33" class="mj kq it mf b gy mk ml l mm mn">import d6tflow.pipe</span><span id="9bb6" class="mj kq it mf b gy mo ml l mm mn">d6tflow.pipe.init(api, 'pipe-name') # save flow output <br/>pipe = d6tflow.pipes.get_pipe()<br/>pipe.pull()</span><span id="71c8" class="mj kq it mf b gy mo ml l mm mn">class Task2(d6tflow.tasks.TaskPqPandas):</span><span id="3c83" class="mj kq it mf b gy mo ml l mm mn">    def requires(self):<br/>        return Task1() # define dependency</span><span id="babb" class="mj kq it mf b gy mo ml l mm mn">    def run(self):<br/>        data = self.input().load() # load data from data engineer</span></pre><p id="dbe4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者，您可以使用<a class="ae ko" href="https://pipe.databolt.tech/gui/request-premium/" rel="noopener ugc nofollow" target="_blank"> d6tflow premium </a>将输出保存在数据库中。</p><pre class="lt lu lv lw gt me mf mg mh aw mi bi"><span id="4844" class="mj kq it mf b gy mk ml l mm mn">d6tflow2.db.init('postgresql+psycopg2://usr:pwd@localhost/db', 'schema_name')</span><span id="4e3e" class="mj kq it mf b gy mo ml l mm mn">class Task1(d6tflow2.tasks.TaskSQLPandas):</span><span id="b2cb" class="mj kq it mf b gy mo ml l mm mn">    def run(self):<br/>        df = pd.DataFrame()<br/>        self.save(df)</span></pre><p id="76e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，数据科学家可以继承数据工程师编写的任务来快速加载源数据。</p><pre class="lt lu lv lw gt me mf mg mh aw mi bi"><span id="8373" class="mj kq it mf b gy mk ml l mm mn">import tasks_factors # import tasks written by data engineer<br/>import utils</span><span id="297e" class="mj kq it mf b gy mo ml l mm mn">class Task1(tasks_factors.Task1):<br/>    external = True # rely on data engineer to run</span><span id="d5fc" class="mj kq it mf b gy mo ml l mm mn">    def run(self):<br/>        data = self.input().load() # load data from data engineer</span></pre><h1 id="3789" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">d6tflow 快速入门</h1><p id="b92a" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">这是一个完整的例子，展示了如何使用 d6tflow 进行 ML 工作流<a class="ae ko" href="https://github.com/d6t/d6tflow#example-output" rel="noopener ugc nofollow" target="_blank">https://github.com/d6t/d6tflow#example-output</a></p><h1 id="be07" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">可扩展 ML 项目的模板</h1><p id="e4d0" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在<a class="ae ko" href="https://github.com/d6t/d6tflow-template" rel="noopener ugc nofollow" target="_blank">https://github.com/d6t/d6tflow-template</a>有一个用于真实项目的 d6t 流代码模板</p><ul class=""><li id="a448" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">多任务输入和输出</li><li id="56bf" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">参数继承</li><li id="8166" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">模块化任务，运行和</li></ul></div></div>    
</body>
</html>