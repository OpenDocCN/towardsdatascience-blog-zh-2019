<html>
<head>
<title>Is a drug stored or excreted? Writing and training a simple perceptron to find out</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">药物是储存的还是排泄的？编写并训练一个简单的感知器来找出答案</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/is-a-drug-stored-or-excreted-writing-and-training-a-simple-perceptron-to-classify-bioconcentration-bc2112239ce8?source=collection_archive---------34-----------------------#2019-06-05">https://towardsdatascience.com/is-a-drug-stored-or-excreted-writing-and-training-a-simple-perceptron-to-classify-bioconcentration-bc2112239ce8?source=collection_archive---------34-----------------------#2019-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9755" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><em class="jb">我进军 DL </em></h2><div class=""/><div class=""><h2 id="ad0f" class="pw-subtitle-paragraph ka jd it bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">简单感知器学习算法的简单实用介绍及其在生物浓缩分类中的应用</h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/9b609e6a739f30ead53db57295deddb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCrLegDP0_i-SVcCCpEJPg.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Image by Ahmed Gad from Pixabay</figcaption></figure><h2 id="1121" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">简单来说，什么是感知器？</h2><p id="21cf" class="pw-post-body-paragraph md me it mf b mg mh ke mi mj mk kh ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi mw translated"><span class="l mx my mz bm na nb nc nd ne di">一个</span>神经元是大脑的基本功能单位，类似地，感知器是神经网络的基本功能单位。在这篇文章中，我将简要介绍人工神经网络和生物神经网络之间的相似之处，感知机如何工作背后的理论，以及如何在 python 中实现算法，以在生物浓度数据集上训练它。</p><p id="2f49" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated">在动物中，一个神经元在其树突处接收来自其他神经元突触的输入。这些树状结构接收输入信号，并在细胞体(也称为细胞体)中进行融合。一旦信号在胞体中发生叠加，门控离子通道将根据信号是否突破阈值而打开或保持关闭——导致神经元沿着轴突放电或保持静止。神经元要么激活，要么不激活。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nk"><img src="../Images/62ef2d0553d347dc302aad2882966600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NATA2Tmj2ULBldLOnN_FUw.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Biological and artificial neuron similarities</figcaption></figure><p id="5e47" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated">为了更好地理解这个模型，我们应该回顾一下上面我整理的图片中的几个组件:</p><p id="c7d3" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated"><strong class="mf je">输入&amp;偏置:</strong>生物神经元的树突接受来自连接突触的神经递质输入。感知器模型中的对应物是输入(用于分类的特征)乘以其各自的权重。权重是在训练模型时随时间变化的值，因为当训练期间发生错误时，它们在“学习”阶段更新。添加偏差作为特殊输入，通过向左或向右平移点来移动决策边界。下面的求和公式显示了输入、权重和偏差是如何结合在一起的。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9547b6e2bfe2489d730fce62dc3b32e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*smKyXJOX3-GEuVwNwQiKzg.png"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Summation equation</figcaption></figure><p id="b127" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated">下图是一条 sigmoid 曲线，如果我们要改变权重，我们可以改变斜率的陡度，但实际上要向左或向右移动曲线，您需要添加一个偏差。使用 bias 在某个方向上平移所有点可以通过帮助分离超平面来增加精度。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nm"><img src="../Images/ccf9c8635b933c34adb4daf138f50666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3lHpi-EHwvAch_Gm21gWGw.jpeg"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Basic sigmoid curve</figcaption></figure><p id="b93d" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated"><strong class="mf je">激活功能</strong>:神经元胞体中兴奋性离子和抑制性离子的总和产生动作电位。如果动作电位是兴奋性的，并且超过阈值，就会发出信号。在人工神经元中，激活函数计算总输入的净输出。感知器实际上是模型的决策者，并使用<a class="ae nn" href="https://www.wikiwand.com/en/Heaviside_step_function" rel="noopener ugc nofollow" target="_blank"> heaviside 函数</a>，也称为阶跃函数，来计算预测的二进制输出。下面是最常用的阶跃函数:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi no"><img src="../Images/b625ba45cfabe00387b21e0e9f31f506.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*2RkG2sD12qoOLpMOWbDaRw.png"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Unit step function</figcaption></figure><ul class=""><li id="bf5e" class="np nq it mf b mg nf mj ng lr nr lv ns lz nt mv nu nv nw nx bi translated">θ是激活函数</li><li id="7fd2" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv nu nv nw nx bi translated">z 是输入的总和乘以它们的权重(和偏差，如果包括的话)</li></ul><p id="4a07" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated"><strong class="mf je">输出:</strong>生物神经元沿着它的轴突传播信号，如果达到阈值，这就是它的输出。感知器的输出也是在全有或全无的基础上触发，并导致 1 或-1 的二进制分类。</p><p id="f877" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated"><strong class="mf je">注:</strong>关于这份材料的更深入的文章可以在<a class="ae nn" rel="noopener" target="_blank" href="/perceptron-the-artificial-neuron-4d8c70d5cc8d">这里</a>找到。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h2 id="e768" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">逐步算法</h2><p id="ba4d" class="pw-post-body-paragraph md me it mf b mg mh ke mi mj mk kh ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">以下是该算法进行预测和学习的步骤纲要。</p><ol class=""><li id="7bbf" class="np nq it mf b mg nf mj ng lr nr lv ns lz nt mv ok nv nw nx bi translated">将权重设置为较小的初始值</li><li id="8a19" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv ok nv nw nx bi translated">将输入向量和权重向量相乘，然后求和</li><li id="6b86" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv ok nv nw nx bi translated">如果总和值大于阈值，则将计算二进制输出</li><li id="6620" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv ok nv nw nx bi translated">检查预测的结果是否正确，然后相应地更新权重</li><li id="113c" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv ok nv nw nx bi translated">重复该过程以提高精确度</li></ol><p id="4ac3" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated"><strong class="mf je">注意:</strong>另一篇伟大的文章解释了为什么算法<a class="ae nn" rel="noopener" target="_blank" href="/perceptron-learning-algorithm-d5db0deab975">会起作用</a>。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h2 id="6bea" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">编码感知器</h2><p id="6cc1" class="pw-post-body-paragraph md me it mf b mg mh ke mi mj mk kh ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated"><strong class="mf je">注意:</strong>我将剖析和解释《Python 机器学习》一书<a class="ae nn" href="https://www.goodreads.com/book/show/35911519-python-machine-learning" rel="noopener ugc nofollow" target="_blank"/>中的代码示例，同时加入我自己的代码。我会检查我们感知机的每一行代码。</p><p id="0168" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated">第一行代码将导入 numpy，因为我们需要执行向量乘法并绘制随机数。然后我们创建感知器类，初始化它，并为“epochs”、“learning_rate”和 randomState 设置参数值。</p><ul class=""><li id="4a8a" class="np nq it mf b mg nf mj ng lr nr lv ns lz nt mv nu nv nw nx bi translated">时期-所有训练数据向前和向后传递的次数</li><li id="9328" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv nu nv nw nx bi translated">学习率——通常指η (eta)和步长。该值更新权重。当训练数据时，权重将根据它们对多少误差负责来更新，但是学习率用这个误差的一部分来更新权重。因此权重更新为——权重+ η(误差)。</li><li id="749e" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv nu nv nw nx bi translated">randomState—用于为实例绘制伪随机数的类。我建议不要使用 random.seed()，因为它会影响全局 numpy 环境。</li></ul><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="310c" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated">这里我们定义了接受 x 和 y 参数的<strong class="mf je"> fit </strong>函数。</p><ul class=""><li id="6d01" class="np nq it mf b mg nf mj ng lr nr lv ns lz nt mv nu nv nw nx bi translated">权重-该参数用于将权重设置为一个随机数，而不是零。以零作为起始权重会导致对称性问题。如果所有输入值的权重为零，则误差也将为零，并且它们都将以相同的幅度更新。我们生成一个平均值为 0、标准偏差为 0.01、抽取样本数量为 1 的正态分布。</li><li id="c71c" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv nu nv nw nx bi translated">errors —是一个空列表，我们将在其中添加我们在培训过程中捕获的错误</li></ul><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="5784" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated">下一段代码是我们刚刚定义的 fit 函数中的一个循环。然而，由于它有许多部分，我们将逐行单独查看。</p><ol class=""><li id="e88d" class="np nq it mf b mg nf mj ng lr nr lv ns lz nt mv ok nv nw nx bi translated">我们将循环设置为遍历每个时期</li><li id="3f74" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv ok nv nw nx bi translated">将每次迭代的误差变量设置为 0</li><li id="2ee8" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv ok nv nw nx bi translated">这里，xi 和目标是 x 和 y 值元组中的两个数字，我们将它们作为数据输入</li><li id="966e" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv ok nv nw nx bi translated">我们将更新变量设置为我们需要用来更新权重的值，即学习率*误差</li><li id="b8cc" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv ok nv nw nx bi translated">用下面的公式更新输入的权重:<br/>权重=权重+(更新* xi)</li><li id="87e9" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv ok nv nw nx bi translated">这里我们将偏差输入更新为:权重=权重+更新</li><li id="4187" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv ok nv nw nx bi translated">我们现在将 errors 变量的值设置为更新值</li><li id="ff3f" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv ok nv nw nx bi translated">最后，我们追加前面创建的错误列表</li></ol><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="e687" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated">感知器代码的最后一块将定义求和及预测功能。</p><ul class=""><li id="9d75" class="np nq it mf b mg nf mj ng lr nr lv ns lz nt mv nu nv nw nx bi translated">求和-我们将特征输入定义为 x，并返回权重和输入的矢量点积，以及偏差单位。</li><li id="f6e4" class="np nq it mf b mg ny mj nz lr oa lv ob lz oc mv nu nv nw nx bi translated">预测-使用 x(要素输入)作为函数参数，如果总和(x)大于 0，则函数返回 1；-1 否则。</li></ul><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ol om l"/></div></figure></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h2 id="4e7e" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">清理和准备数据</h2><p id="21fe" class="pw-post-body-paragraph md me it mf b mg mh ke mi mj mk kh ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">我没有选择像 Fisher 的 iris 数据集这样的经典数据集，而是选择寻找一个与我目前正在做的工作相关的数据集。这让我找到了由米兰-比科卡大学主办的生物浓缩数据集，可以在这里找到<a class="ae nn" href="http://www.michem.unimib.it/download/data/mechanisms-of-bioconcentration/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3ab9" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated">这些数据只需稍加润色就可以使用了。在下面的代码块中，我做了些什么来使数据可用于感知器模型。原始数据有 3 种不同的分类:(1)主要储存在脂质组织中，(2)有额外的储存位点(如蛋白质)，或(3)被代谢/消除[1]。因为我们的模型将使用两个预测类，所以我们可以去掉(2)类标签。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="b915" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated">我们现在可以创建训练数据集来训练感知器学习模型:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="3381" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">训练感知器</h2><p id="ee6b" class="pw-post-body-paragraph md me it mf b mg mh ke mi mj mk kh ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">下面是我们的感知器学习模型的完整代码块</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="6441" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated">这个数据集是心血来潮选择的，为了使分类器尽可能准确，预测特征应该能够沿着一个平面将各组分开。我们可以执行 PCA 或其他形式的降维来找出最重要的特征，但这不是本教程的重点。重点是看看我们是否可以在给定的一组分类数据上编写和训练一个感知器，以及它在这些数据上的表现如何。下面的代码块绘制了我们的训练结果，并查看了各个时期的更新次数——我们必须对整个训练数据集的传递执行多少调整。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="7257" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">结论:不是很棒，但是很管用！</h2><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi on"><img src="../Images/3942e96dca4d1aed6c095296da67d47b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WczPN6KpA5N9xEsi8WyJDg.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Number of updates over epoch (entire data set passes)</figcaption></figure><p id="7557" class="pw-post-body-paragraph md me it mf b mg nf ke mi mj ng kh ml lr nh mn mo lv ni mq mr lz nj mt mu mv im bi translated">我们看到，虽然更新的数量在波动，但在迭代过程中有一个总体下降的趋势，也就是说，我们的感知器算法在训练数据的每次传递中变得越来越准确。我们不能说它会达到零(像 Fisher's Iris 这样不太复杂的数据集一样)，但我们可以说我们从 20 世纪 60 年代开始的简单感知机学习算法确实“学习”了。</p><h2 id="6a83" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak">参考文献</strong></h2><p id="7288" class="pw-post-body-paragraph md me it mf b mg mh ke mi mj mk kh ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">[1] F. Grisoni，V.Consonni，M.Vighi，S.Villa，R.Todeschini，<a class="ae nn" href="http://F. Grisoni, V.Consonni, M.Vighi, S.Villa, R.Todeschini (2016). Investigating the mechanisms of bioconcentration through QSAR classification trees, Environment International, 88, 198-205" rel="noopener ugc nofollow" target="_blank">通过 QSAR 分类树调查生物浓缩机制</a> (2016)，国际环境组织</p></div></div>    
</body>
</html>