<html>
<head>
<title>Dependency Parser or how to find syntactic neighbours of a word</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依存解析器或如何找到一个单词的语法邻居</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dependency-parser-or-how-to-find-syntactic-neighbours-of-a-word-a9e7d17ffe8?source=collection_archive---------10-----------------------#2019-07-25">https://towardsdatascience.com/dependency-parser-or-how-to-find-syntactic-neighbours-of-a-word-a9e7d17ffe8?source=collection_archive---------10-----------------------#2019-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3d26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文将通过理论来揭开 NLP 中这一不为人知的部分。然后，在第二篇文章中，我们将推荐一些工具来帮助您理解如何轻松地实现依赖解析器。</p><p id="2dfb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们考虑一个单词的邻居时，我们可以把邻居看作是他们在句子中的位置，他们与其他单词的关系(主语，行列式，等等。)，称之为句法，或者称之为它们意义的相似性，称之为语义。这里我们感兴趣的是句法上的邻域。</p><h1 id="339e" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">词汇</h1><p id="8643" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">首先，我们来定义一些词汇，让大家更清楚。</p><ul class=""><li id="5442" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated"><strong class="js iu">语义学</strong>是研究意义和解释的语言学和哲学领域。它非常依赖单词之间的联系来理解句子，并分析意思的变化。在编程中，语义是程序的预期输出。</li><li id="bdcd" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated"><strong class="js iu">句法</strong>是语言学领域的语法。它是对句子中单词模式规则的研究。众所周知，在编程中，语法错误通常会导致错误，因为规则通常比口头语言要严格得多。</li></ul><h1 id="f0de" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">什么是依赖解析器？</h1><p id="ef43" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">依存关系树是一种可以被定义为有向图的结构，具有对应于单词的|V|个节点(顶点),以及对应于它们之间的句法依存关系的|A|个弧。我们可能还想将标签归属于依赖关系，称为关系。这些关系给出了依赖类型的细节(如主语、直接宾语补足语、决定因素……)。你可以通过下面的链接找到所有来自通用依赖的关系:【https://universaldependencies.org/u/dep/index.html】T4。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/b42b903ecb50ff71d2211ce20c335b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M6hUDHa04FrcBn1LATqXMQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Example of Dependency Tree : “What is a parser ?”</figcaption></figure><p id="f5d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在弧 h → d 中，h 是<strong class="js iu">头</strong>，d 是<strong class="js iu">从属</strong>。中心是一个短语中最重要的节点，而<strong class="js iu">词根</strong>是整个句子中最重要的节点:它直接或间接地是所有其他节点的中心。</p><p id="fba9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">依存解析器只是将一个句子转换成一棵依存树。</p><h1 id="b770" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">度量:如何识别一个好的解析器？</h1><p id="6e7b" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">一个准确的依存解析器能够很好地识别单词之间的依存关系。两个度量(分数)对此是有用的:<br/> -未标记的附件分数(UAS)，其对应于在可能性的数量上正确预测的依赖性的数量；<br/> -标记的附件分数(LAS)，其对应于在可能性的数量上正确预测的依赖性和关系的数量。</p><p id="9273" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">LAS 始终小于或等于 UAS，因为不正确的依赖关系会导致次优的 UAS 和 LAS，而不正确的关系(或标注)只会导致 LAS 下降。</p><h1 id="06cb" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">算法:它是如何工作的？</h1><p id="0c65" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">正如您可能已经想到的，我们可以通过语言学家开发的规则创建一个依赖解析器。这些解析器被称为<strong class="js iu">理性主义者</strong>。它们一点也不高效，因为语言非常复杂，而且会随着时间而变化。语言的任何微小变化都会导致解析器的巨大变化。机器学习允许开发数据驱动的<strong class="js iu">经验</strong>解析器。通过许多句子，可以得出依赖或关系的概率。语言学知识可能会用到，但没有定论，如果你像我一样忘记了小学的功课，这是一个很好的观点…</p><p id="0b74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建依赖解析器需要几个步骤。我们的输入是句子的单词及其<strong class="js iu">属性</strong>(索引、词性标签、词条、特征)；然后，我们必须为句子中所有可能的弧线计算<strong class="js iu">特征</strong>。由于这些特性，我们为每种可能性计算一个<strong class="js iu">分数</strong>，最后用一个<strong class="js iu">解码器</strong>解码分数。</p><p id="4e20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">功能和评分</strong></p><p id="103c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">句子中的每个单词都有一些属性，比如词性标签或词条。如果你已经读过 NLP，你可能知道他们。如果没有，您可以在这里查看:</p><ul class=""><li id="cd94" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated"><a class="ae mf" href="https://universaldependencies.org/u/pos/all.html" rel="noopener ugc nofollow" target="_blank">https://universaldependencies.org/u/pos/all.html</a></li><li id="9389" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated"><a class="ae mf" href="https://universaldependencies.org/u/feat/index.html" rel="noopener ugc nofollow" target="_blank">https://universaldependencies.org/u/feat/index.html</a></li></ul><p id="a004" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">利用这些特征，我们训练一个机器学习回归模型，该模型返回将被解码器利用的分数。</p><p id="bcc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">特征选择至关重要，一些模型允许我们通过深度学习部分绕过这一部分。我们将在下一节介绍的算法就是这种情况。</p><h2 id="50cc" class="mw kp it bd kq mx my dn ku mz na dp ky kb nb nc lc kf nd ne lg kj nf ng lk nh bi translated">解码器</h2><p id="0ce9" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">已经开发了许多不同的解码器。然而，我们可以将它们分为两类:基于转换的解码器和基于图的解码器。基于转换的解码器速度更快，解码乐谱需要的内存更少，但通常不如基于图形的解码器准确。在本文中，我将只介绍基于图的模型原理。</p><p id="6ff5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其他算法可以应用不同的过渡，但这一个允许我们理解主要的原理。</p><p id="c350" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">基于图形的解码器</strong></p><p id="dd8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要理解这些算法，需要处理图论。</p><p id="8df9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">图 G=(V，A)是表示记号的顶点 V(也称为节点)和弧(I，j)∈ A 的集合，其中 I，j ∈ V。弧表示两个单词之间的依赖关系。</p><p id="ba8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在基于图的依赖解析器中，图是有向的，这意味着链接有不同的方向，节点之间可以有多条弧线，这被称为<strong class="js iu">多向图</strong>。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/c4f9aace0ac4448f6111c07cc4f7846f.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*iDz4c1LKnt-4mLnjHNd1Ng.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Weighted Multi Directed Graph (G)</figcaption></figure><p id="839f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以注意到有些箭头比其他的粗。这代表弧的权重。弧线的权重越大，两个节点之间的联系就越紧密。我们可以把这解释为解析器的语法依赖性的强度。比如 C 和 A 看起来很依赖 B，但是 B 看起来不太依赖 C 和 A。</p><p id="051c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">图 G 太连通了。为了得到依赖树，我们需要:</p><ul class=""><li id="234f" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated">仅将每个单词与其从属词链接，而不是与所有单词链接。弧的总数应该等于节点数减 1 (|A| = |V|-1)。</li><li id="f544" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">保持相同的节点(或记号或单词)。</li><li id="4cb4" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">让它成为非循环的:我们不希望一个头依赖于它的一个从属(直接或间接)。</li></ul><p id="fdd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，所有这些都已经有了名字:我们想要的是一棵生成树！</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/98e9194db8a2ff5b2096a1b1383eb443.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*_Hd-WYyxqnAga9mn5c--tw.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Example of Spanning Tree from the graph G</figcaption></figure><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/92a0d1042c6eedcee24c718b1030e9a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*A_BMSg3pEmXd12iSDOyd9Q.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">An other example of Spanning Tree</figcaption></figure><p id="942b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我清楚什么是生成树，你应该知道有多种可能性，因为我们只有几个条件来得到一个。这里有一个窍门:我们当然想要最好的，但是我们如何确定“最好”的呢？</p><p id="a23e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有 3 个节点，我们想保留它们。然而，我们有 6 个弧，我们只想保留 2 个。“最佳”依赖树是具有最高权重的树:这被称为最大生成树(MST)。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/121118c1aba14aa9ad1f7b92a011491c.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*JiqZAES0LVH1UrlyGxwGkQ.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Maximum Spanning Tree of G</figcaption></figure><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/cb5067af18514799c2390c3b1855a438.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*s-MVEh4Tjw_Jpft0_O1qhA.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Minimum Spanning Tree of G</figcaption></figure><p id="6108" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个最大生成树给了我们依赖树，我们将使用它来寻找句子中最接近的语法邻居。</p><h1 id="33a0" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结论</h1><p id="7449" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">与不同的现有算法相比，这里给出的见解是非常轻的。然而，在开发依赖解析器时，这应该会提高您的直觉。</p></div></div>    
</body>
</html>