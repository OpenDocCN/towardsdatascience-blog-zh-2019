<html>
<head>
<title>Data Scientists, The 5 Graph Algorithms that you should know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家，你应该知道的 5 种图形算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-scientists-the-five-graph-algorithms-that-you-should-know-30f454fa5513?source=collection_archive---------0-----------------------#2019-08-21">https://towardsdatascience.com/data-scientists-the-five-graph-algorithms-that-you-should-know-30f454fa5513?source=collection_archive---------0-----------------------#2019-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bf2d7da7f89dd19b367c9d046dc99cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_WiMjF0s6_gGRqPmDZ1Eg.png"/></div></div></figure><div class=""/><div class=""><h2 id="abc7" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">因为图表分析是未来</h2></div><p id="2575" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">作为数据科学家，我们已经对 Pandas 或 SQL 或任何其他关系数据库驾轻就熟。</p><p id="f2d7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们习惯于以行的形式看到用户，以列的形式看到他们的属性。但是现实世界真的是那样的吗？</p><p id="e141" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在一个互联的世界中，用户不能被视为独立的实体。它们彼此之间有一定的关系，我们有时希望在构建机器学习模型时包括这种关系。</p><p id="6e62" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，虽然在关系数据库中，我们不能在不同的行(用户)之间使用这种关系，但在图形数据库中，这样做是相当简单的。</p><p id="dd20" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lp">在这篇文章中，我将谈论一些你应该知道的最重要的图算法，以及如何用 Python 实现它们。</em> </strong></p><p id="e66d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">此外，这里有一个由 UCSanDiego 在 Coursera 上提供的<a class="ae lq" href="https://coursera.pxf.io/YgKbbe" rel="noopener ugc nofollow" target="_blank">大数据图形分析课程，我强烈推荐学习图论的基础知识。</a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="37f5" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">1.连接的组件</h1><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mq"><img src="../Images/e56224cf925a5a22ce8b26e43a08e617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5jLiNyvTWtp4a6eSX-cybg.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">A graph with 3 connected components</figcaption></figure><p id="fb63" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们都知道集群是如何工作的？</p><p id="7e46" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="lp">你可以用非常通俗的术语把连通分量想象成一种硬聚类算法，它在相关/连通的数据中寻找聚类/孤岛。</em></p><p id="a06a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="lp">举个具体的例子:</em> <strong class="kv jf"> <em class="lp">假设你有连接世界上任意两个城市的道路的数据。你需要找出世界上所有的大洲以及它们包含的城市。</em> </strong></p><p id="9e17" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你将如何实现这一目标？来吧，考虑一下。</p><p id="2af5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们使用的连通分量算法是基于<strong class="kv jf"> BFS/DFS </strong>的一个特例。我不会在这里过多地谈论它是如何工作的，但是我们将看到如何使用<code class="fe mz na nb nc b">Networkx</code>让代码运行起来。</p><h2 id="edc3" class="nd lz je bd ma ne nf dn me ng nh dp mi lc ni nj mk lg nk nl mm lk nm nn mo no bi translated">应用程序</h2><p id="b6d5" class="pw-post-body-paragraph kt ku je kv b kw np kf ky kz nq ki lb lc nr le lf lg ns li lj lk nt lm ln lo im bi translated">从零售的角度来看:比方说，我们有很多客户使用很多账户。使用连通分量算法的一种方法是在数据集中找出不同的族。</p><p id="44fa" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们可以基于相同的信用卡使用、相同的地址或相同的手机号码等假设客户之间的边(道路)。一旦我们有了这些连接，我们就可以在相同的上运行连接组件算法来创建单独的聚类，然后我们可以为这些聚类分配一个家族 ID。</p><p id="d236" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然后，我们可以使用这些家庭 id 根据家庭需求提供个性化建议。我们还可以使用这个家族 ID，通过创建基于家族的分组特征来推动我们的分类算法。</p><p id="060c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">从<strong class="kv jf">财务角度</strong>:另一个用例是使用这些家庭 id 来捕获欺诈。如果一个帐户在过去进行过欺诈，则关联的帐户很可能也容易受到欺诈。</p><p id="5c14" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">可能性只受到你自己想象力的限制。</p><h2 id="eb0d" class="nd lz je bd ma ne nf dn me ng nh dp mi lc ni nj mk lg nk nl mm lk nm nn mo no bi translated">密码</h2><p id="dd78" class="pw-post-body-paragraph kt ku je kv b kw np kf ky kz nq ki lb lc nr le lf lg ns li lj lk nt lm ln lo im bi translated">我们将使用 Python 中的<code class="fe mz na nb nc b">Networkx</code>模块来创建和分析我们的图表。</p><p id="9a60" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们从一个用于我们目的的示例图开始。包含城市和它们之间的距离信息。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/36cd286443808253caec6823b8b5ed2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjrkUYfaIHHrdhwORwgesw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">Graph with Some random distances</figcaption></figure><p id="cd00" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们首先创建一个边和距离的列表，我们将添加边的权重:</p><pre class="mr ms mt mu gt nv nc nw nx aw ny bi"><span id="16fb" class="nd lz je nc b gy nz oa l ob oc">edgelist = [['Mannheim', 'Frankfurt', 85], ['Mannheim', 'Karlsruhe', 80], ['Erfurt', 'Wurzburg', 186], ['Munchen', 'Numberg', 167], ['Munchen', 'Augsburg', 84], ['Munchen', 'Kassel', 502], ['Numberg', 'Stuttgart', 183], ['Numberg', 'Wurzburg', 103], ['Numberg', 'Munchen', 167], ['Stuttgart', 'Numberg', 183], ['Augsburg', 'Munchen', 84], ['Augsburg', 'Karlsruhe', 250], ['Kassel', 'Munchen', 502], ['Kassel', 'Frankfurt', 173], ['Frankfurt', 'Mannheim', 85], ['Frankfurt', 'Wurzburg', 217], ['Frankfurt', 'Kassel', 173], ['Wurzburg', 'Numberg', 103], ['Wurzburg', 'Erfurt', 186], ['Wurzburg', 'Frankfurt', 217], ['Karlsruhe', 'Mannheim', 80], ['Karlsruhe', 'Augsburg', 250],["Mumbai", "Delhi",400],["Delhi", "Kolkata",500],["Kolkata", "Bangalore",600],["TX", "NY",1200],["ALB", "NY",800]]</span></pre><p id="86d2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们使用<code class="fe mz na nb nc b">Networkx</code>创建一个图表:</p><pre class="mr ms mt mu gt nv nc nw nx aw ny bi"><span id="7610" class="nd lz je nc b gy nz oa l ob oc"><strong class="nc jf">g = nx.Graph()</strong><br/>for edge in edgelist:<br/>    <strong class="nc jf">g.add_edge</strong>(edge[0],edge[1], weight = edge[2])</span></pre><p id="09cb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在<strong class="kv jf"> <em class="lp">我们想从这张图上找出不同的大陆和它们的城市。</em> </strong></p><p id="18ce" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们现在可以使用连通分量算法来实现这一点，如下所示:</p><pre class="mr ms mt mu gt nv nc nw nx aw ny bi"><span id="6f79" class="nd lz je nc b gy nz oa l ob oc">for i, x in enumerate(<strong class="nc jf">nx.connected_components(g)</strong>):<br/>    print("cc"+str(i)+":",x)<br/>------------------------------------------------------------<br/>cc0: {'Frankfurt', 'Kassel', 'Munchen', 'Numberg', 'Erfurt', 'Stuttgart', 'Karlsruhe', 'Wurzburg', 'Mannheim', 'Augsburg'}<br/>cc1: {'Kolkata', 'Bangalore', 'Mumbai', 'Delhi'}<br/>cc2: {'ALB', 'NY', 'TX'}</span></pre><p id="2ae4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如您所见，我们能够在数据中找到不同的组件。仅仅通过使用边和顶点。这个算法可以在不同的数据上运行，以满足我上面提到的任何用例。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f82e" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">2.最短路径</h1><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/5c70e5c9dac2a3443bd7fc6b3ff2bd9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u2As0kyEUMDs59Zb"/></div></div></figure><p id="b602" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">继续上面的例子，我们得到一个图表，上面有德国的城市以及它们之间的距离。</p><p id="12ac" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">你想找出如何从法兰克福(起点)到慕尼黑的最短距离</strong>。</p><p id="3fcc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们用来解决这个问题的算法叫做<strong class="kv jf"> Dijkstra </strong>。用 Dijkstra 自己的话说:</p><blockquote class="oe of og"><p id="eb09" class="kt ku lp kv b kw kx kf ky kz la ki lb oh ld le lf oi lh li lj oj ll lm ln lo im bi translated">从<a class="ae lq" href="https://en.wikipedia.org/wiki/Rotterdam" rel="noopener ugc nofollow" target="_blank">鹿特丹</a>到<a class="ae lq" href="https://en.wikipedia.org/wiki/Groningen" rel="noopener ugc nofollow" target="_blank">格罗宁根</a>的最短旅行方式是什么，一般来说:从给定的城市到给定的城市。<a class="ae lq" href="https://en.wikipedia.org/wiki/Shortest_path_problem" rel="noopener ugc nofollow" target="_blank">是最短路径的算法</a>，我用了大概二十分钟设计的。一天早上，我和我年轻的未婚妻在阿姆斯特丹购物，累了，我们坐在咖啡馆的露台上喝咖啡，我在想我是否可以这样做，然后我设计了最短路径的算法。正如我所说，这是一个 20 分钟的发明。事实上，它是在三年后的 59 年出版的。该出版物仍然可读，事实上，相当不错。它如此漂亮的原因之一是我没有用铅笔和纸来设计它。我后来才知道，不用铅笔和纸进行设计的一个好处是，你几乎是被迫避免所有可以避免的复杂性。最终，令我大为惊讶的是，这个算法成了我成名的基石之一。</p><p id="cdf9" class="kt ku lp kv b kw kx kf ky kz la ki lb oh ld le lf oi lh li lj oj ll lm ln lo im bi translated">— Edsger Dijkstra，在与 Philip L. Frana 的访谈中，ACM 通讯，2001<a class="ae lq" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#cite_note-Dijkstra_Interview-3" rel="noopener ugc nofollow" target="_blank">【3】</a></p></blockquote><h2 id="aaf7" class="nd lz je bd ma ne nf dn me ng nh dp mi lc ni nj mk lg nk nl mm lk nm nn mo no bi translated">应用程序</h2><ul class=""><li id="367b" class="ok ol je kv b kw np kz nq lc om lg on lk oo lo op oq or os bi translated">Dijkstra 算法的变体在谷歌地图中被广泛用于查找最短路线。</li><li id="8a61" class="ok ol je kv b kw ot kz ou lc ov lg ow lk ox lo op oq or os bi translated">你在沃尔玛超市。你有不同的过道和过道之间的距离。您希望为顾客提供从通道 A 到通道 d 的最短路径。</li></ul><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/7fd38db595067aafc05aed27d8200c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*D2QhdfY5rQCX-rDoVaEVTw.png"/></div></figure><ul class=""><li id="6c76" class="ok ol je kv b kw kx kz la lc oz lg pa lk pb lo op oq or os bi translated">你已经看到 LinkedIn 如何显示一级关系，二级关系。幕后发生了什么？</li></ul><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/f49ea3fb62fef0bbc7986eeaed3e86ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*7KITzPhKhz5EAIcXDhdLgg.png"/></div></figure><h2 id="ab3f" class="nd lz je bd ma ne nf dn me ng nh dp mi lc ni nj mk lg nk nl mm lk nm nn mo no bi translated">密码</h2><pre class="mr ms mt mu gt nv nc nw nx aw ny bi"><span id="8717" class="nd lz je nc b gy nz oa l ob oc">print(<strong class="nc jf">nx.shortest_path</strong>(g, 'Stuttgart','Frankfurt',weight='weight'))<br/>print(<strong class="nc jf">nx.shortest_path_length</strong>(g, 'Stuttgart','Frankfurt',weight='weight'))<br/>--------------------------------------------------------<br/>['Stuttgart', 'Numberg', 'Wurzburg', 'Frankfurt']<br/>503</span></pre><p id="92ea" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您还可以使用以下方法查找所有对之间的最短路径:</p><pre class="mr ms mt mu gt nv nc nw nx aw ny bi"><span id="ec8b" class="nd lz je nc b gy nz oa l ob oc">for x in <strong class="nc jf">nx.all_pairs_dijkstra_path(g,weight='weight')</strong>:<br/>    print(x)<br/>--------------------------------------------------------<br/>('Mannheim', {'Mannheim': ['Mannheim'], 'Frankfurt': ['Mannheim', 'Frankfurt'], 'Karlsruhe': ['Mannheim', 'Karlsruhe'], 'Augsburg': ['Mannheim', 'Karlsruhe', 'Augsburg'], 'Kassel': ['Mannheim', 'Frankfurt', 'Kassel'], 'Wurzburg': ['Mannheim', 'Frankfurt', 'Wurzburg'], 'Munchen': ['Mannheim', 'Karlsruhe', 'Augsburg', 'Munchen'], 'Erfurt': ['Mannheim', 'Frankfurt', 'Wurzburg', 'Erfurt'], 'Numberg': ['Mannheim', 'Frankfurt', 'Wurzburg', 'Numberg'], 'Stuttgart': ['Mannheim', 'Frankfurt', 'Wurzburg', 'Numberg', 'Stuttgart']})</span><span id="2934" class="nd lz je nc b gy pd oa l ob oc">('Frankfurt', {'Frankfurt': ['Frankfurt'], 'Mannheim': ['Frankfurt', 'Mannheim'], 'Kassel': ['Frankfurt', 'Kassel'], 'Wurzburg': ['Frankfurt', 'Wurzburg'], 'Karlsruhe': ['Frankfurt', 'Mannheim', 'Karlsruhe'], 'Augsburg': ['Frankfurt', 'Mannheim', 'Karlsruhe', 'Augsburg'], 'Munchen': ['Frankfurt', 'Wurzburg', 'Numberg', 'Munchen'], 'Erfurt': ['Frankfurt', 'Wurzburg', 'Erfurt'], 'Numberg': ['Frankfurt', 'Wurzburg', 'Numberg'], 'Stuttgart': ['Frankfurt', 'Wurzburg', 'Numberg', 'Stuttgart']})</span><span id="5b8e" class="nd lz je nc b gy pd oa l ob oc">....</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5bcb" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">3.最小生成树</h1><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/2b21d6ff40a3c4021f2645331ac2288d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QucExOxxHRAj64ZK"/></div></div></figure><p id="9ee0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在我们有另一个问题。我们为一家水管铺设公司或互联网光纤公司工作。我们需要使用最少的电线/管道连接图表中的所有城市。 我们如何做到这一点？</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pf"><img src="../Images/e9a54a4c330459e51be7adf1ea5421fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W7eBhVF22WmT37M-"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">An Undirected Graph and its MST on the right.</figcaption></figure><h2 id="4e3f" class="nd lz je bd ma ne nf dn me ng nh dp mi lc ni nj mk lg nk nl mm lk nm nn mo no bi translated">应用程序</h2><ul class=""><li id="fe2e" class="ok ol je kv b kw np kz nq lc om lg on lk oo lo op oq or os bi translated">最小生成树在网络设计中有直接的应用，包括计算机网络、电信网络、运输网络、供水网络和电网(它们最初就是为此而发明的)</li><li id="e080" class="ok ol je kv b kw ot kz ou lc ov lg ow lk ox lo op oq or os bi translated">MST 用于近似旅行推销员问题</li><li id="4a27" class="ok ol je kv b kw ot kz ou lc ov lg ow lk ox lo op oq or os bi translated">聚类-首先构建 MST，然后使用簇间距离和簇内距离确定一个阈值来断开 MST 中的一些边。</li><li id="cff2" class="ok ol je kv b kw ot kz ou lc ov lg ow lk ox lo op oq or os bi translated">图像分割—它用于图像分割，我们首先在图上构建一个 MST，其中像素是节点，像素之间的距离基于某种相似性度量(颜色、强度等)。)</li></ul><h2 id="997a" class="nd lz je bd ma ne nf dn me ng nh dp mi lc ni nj mk lg nk nl mm lk nm nn mo no bi translated">密码</h2><pre class="mr ms mt mu gt nv nc nw nx aw ny bi"><span id="b197" class="nd lz je nc b gy nz oa l ob oc"># nx.minimum_spanning_tree(g) returns a instance of type graph<br/>nx.draw_networkx(<strong class="nc jf">nx.minimum_spanning_tree</strong>(g))</span></pre><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pg"><img src="../Images/6d402c9c8820f11ba3e5738fc5ab64fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7FTdmCYLmJzquFBUINI2w.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">The MST of our graph.</figcaption></figure><p id="e663" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如你所见，上面是我们要铺设的电线。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4dbc" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">4.Pagerank</h1><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/63bd2e7d5dcdf54d7c9273104623d683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vlVuoBXlu063bQDO.jpg"/></div></div></figure><p id="e5f2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这是长期以来为谷歌提供动力的页面排序算法。它根据输入和输出链接的数量和质量给网页打分。</p><h2 id="f985" class="nd lz je bd ma ne nf dn me ng nh dp mi lc ni nj mk lg nk nl mm lk nm nn mo no bi translated">应用程序</h2><p id="aff5" class="pw-post-body-paragraph kt ku je kv b kw np kf ky kz nq ki lb lc nr le lf lg ns li lj lk nt lm ln lo im bi translated">Pagerank 可以用在任何我们想要评估任何网络中节点重要性的地方。</p><ul class=""><li id="3163" class="ok ol je kv b kw kx kz la lc oz lg pa lk pb lo op oq or os bi translated">它已经被用于通过引用来寻找最有影响力的论文。</li><li id="1e87" class="ok ol je kv b kw ot kz ou lc ov lg ow lk ox lo op oq or os bi translated">已经被谷歌用来对网页进行排名</li><li id="cf6a" class="ok ol je kv b kw ot kz ou lc ov lg ow lk ox lo op oq or os bi translated">它可以用来对 tweets 进行排序——用户和 Tweets 作为节点。如果用户 A 关注用户 B，则在用户之间创建链接；如果用户发推文/转发推文，则在用户和推文之间创建链接。</li><li id="217d" class="ok ol je kv b kw ot kz ou lc ov lg ow lk ox lo op oq or os bi translated">推荐引擎</li></ul><h2 id="f1e1" class="nd lz je bd ma ne nf dn me ng nh dp mi lc ni nj mk lg nk nl mm lk nm nn mo no bi translated">密码</h2><p id="d0dd" class="pw-post-body-paragraph kt ku je kv b kw np kf ky kz nq ki lb lc nr le lf lg ns li lj lk nt lm ln lo im bi translated">在这个练习中，我们将使用脸书的数据。我们有 facebook 用户之间的边/链接文件。我们首先使用以下公式创建 FB 图:</p><pre class="mr ms mt mu gt nv nc nw nx aw ny bi"><span id="e8a7" class="nd lz je nc b gy nz oa l ob oc"># reading the dataset</span><span id="2db5" class="nd lz je nc b gy pd oa l ob oc">fb = nx.read_edgelist('../input/facebook-combined.txt', create_using = nx.Graph(), nodetype = int)</span></pre><p id="50eb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">看起来是这样的:</p><pre class="mr ms mt mu gt nv nc nw nx aw ny bi"><span id="81fa" class="nd lz je nc b gy nz oa l ob oc">pos = nx.spring_layout(fb)</span><span id="a722" class="nd lz je nc b gy pd oa l ob oc">import warnings<br/>warnings.filterwarnings('ignore')</span><span id="f354" class="nd lz je nc b gy pd oa l ob oc">plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20, 15)<br/>plt.axis('off')<br/>nx.draw_networkx(fb, pos, with_labels = False, node_size = 35)<br/>plt.show()</span></pre><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/6bff95ff5f4d357a5802368a290433b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZ7cCQlOuL2X2bIm22DDoQ.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">FB User Graph</figcaption></figure><p id="872b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在我们想找到具有高影响力的用户。</p><p id="da68" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">直观地说，Pagerank 算法会给一个有很多朋友的用户更高的分数，而这个用户又有很多 FB 朋友。</p><pre class="mr ms mt mu gt nv nc nw nx aw ny bi"><span id="9219" class="nd lz je nc b gy nz oa l ob oc">pageranks = nx.pagerank(fb)<br/>print(pageranks)<br/>------------------------------------------------------<br/>{0: 0.006289602618466542,<br/> 1: 0.00023590202311540972,<br/> 2: 0.00020310565091694562,<br/> 3: 0.00022552359869430617,<br/> 4: 0.00023849264701222462,<br/>........}</span></pre><p id="09af" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们可以使用以下方法获得排序后的 PageRank 或最有影响力的用户:</p><pre class="mr ms mt mu gt nv nc nw nx aw ny bi"><span id="9bf3" class="nd lz je nc b gy nz oa l ob oc">import operator<br/>sorted_pagerank = sorted(pageranks.items(), key=operator.itemgetter(1),reverse = True)<br/>print(sorted_pagerank)<br/>------------------------------------------------------<br/>[(3437, 0.007614586844749603), (107, 0.006936420955866114), (1684, 0.0063671621383068295), (0, 0.006289602618466542), (1912, 0.0038769716008844974), (348, 0.0023480969727805783), (686, 0.0022193592598000193), (3980, 0.002170323579009993), (414, 0.0018002990470702262), (698, 0.0013171153138368807), (483, 0.0012974283300616082), (3830, 0.0011844348977671688), (376, 0.0009014073664792464), (2047, 0.000841029154597401), (56, 0.0008039024292749443), (25, 0.000800412660519768), (828, 0.0007886905420662135), (322, 0.0007867992190291396),......]</span></pre><p id="dfa1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">以上 id 是针对最有影响力的用户。</p><p id="c7d4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们可以看到最有影响力的用户的子图:</p><pre class="mr ms mt mu gt nv nc nw nx aw ny bi"><span id="7751" class="nd lz je nc b gy nz oa l ob oc">first_degree_connected_nodes = list(fb.neighbors(3437))<br/>second_degree_connected_nodes = []<br/>for x in first_degree_connected_nodes:<br/>    second_degree_connected_nodes+=list(fb.neighbors(x))<br/>second_degree_connected_nodes.remove(3437)<br/>second_degree_connected_nodes = list(set(second_degree_connected_nodes))</span><span id="bd78" class="nd lz je nc b gy pd oa l ob oc">subgraph_3437 = nx.subgraph(fb,first_degree_connected_nodes+second_degree_connected_nodes)</span><span id="1fbd" class="nd lz je nc b gy pd oa l ob oc">pos = nx.spring_layout(subgraph_3437)</span><span id="d3a2" class="nd lz je nc b gy pd oa l ob oc">node_color = ['yellow' if v == 3437 else 'red' for v in subgraph_3437]<br/>node_size =  [1000 if v == 3437 else 35 for v in subgraph_3437]<br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20, 15)<br/>plt.axis('off')</span><span id="77b7" class="nd lz je nc b gy pd oa l ob oc">nx.draw_networkx(subgraph_3437, pos, with_labels = False, node_color=node_color,node_size=node_size )<br/>plt.show()</span></pre><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/530f7427e4f036211756b80203ff8ad9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5UR3xcZVb787uFqOyMrHCQ.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">Our most influential user(Yellow)</figcaption></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="0ffc" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">5.<strong class="ak">中心性测量</strong></h1><p id="41ed" class="pw-post-body-paragraph kt ku je kv b kw np kf ky kz nq ki lb lc nr le lf lg ns li lj lk nt lm ln lo im bi translated">有许多中心性度量，可以用作机器学习模型的特征。我将谈论其中的两个。这里可以看看其他措施<a class="ae lq" href="https://networkx.github.io/documentation/networkx-1.10/reference/algorithms.centrality.html#current-flow-closeness" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="51c2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">中间中心性:不仅拥有最多朋友的用户很重要，将一个地理位置与另一个地理位置联系起来的用户也很重要，因为这让用户可以看到来自不同地理位置的内容。<strong class="kv jf"> <em class="lp">中间中心性量化了一个特定节点在两个其他节点之间的最短选择路径中出现的次数。</em> </strong></p><p id="8e21" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">度中心性:</strong>简单来说就是一个节点的连接数。</p><h2 id="9de6" class="nd lz je bd ma ne nf dn me ng nh dp mi lc ni nj mk lg nk nl mm lk nm nn mo no bi translated">应用程序</h2><p id="c0ee" class="pw-post-body-paragraph kt ku je kv b kw np kf ky kz nq ki lb lc nr le lf lg ns li lj lk nt lm ln lo im bi translated">中心性度量可以用作任何机器学习模型中的特征。</p><h2 id="abfb" class="nd lz je bd ma ne nf dn me ng nh dp mi lc ni nj mk lg nk nl mm lk nm nn mo no bi translated">密码</h2><p id="395f" class="pw-post-body-paragraph kt ku je kv b kw np kf ky kz nq ki lb lc nr le lf lg ns li lj lk nt lm ln lo im bi translated">下面是寻找子图中间中心性的代码。</p><pre class="mr ms mt mu gt nv nc nw nx aw ny bi"><span id="4793" class="nd lz je nc b gy nz oa l ob oc">pos = nx.spring_layout(subgraph_3437)<br/>betweennessCentrality = <strong class="nc jf">nx.betweenness_centrality(</strong>subgraph_3437<strong class="nc jf">,normalized=True, endpoints=True)</strong></span><span id="d62c" class="nd lz je nc b gy pd oa l ob oc">node_size =  [v * 10000 for v in betweennessCentrality.values()]<br/>plt.figure(figsize=(20,20))<br/>nx.draw_networkx(subgraph_3437, pos=pos, with_labels=False,<br/>                 node_size=node_size )<br/>plt.axis('off')</span></pre><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/1623fc0ad9e84c9b82648de1c686360b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SzSp9t-NwqP8FuAuUjUYGw.png"/></div></div></figure><p id="cf85" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可以在这里看到根据介数中心性值确定大小的节点。他们可以被认为是信息传递者。断开任何具有高介数中心性的节点都会将图分成许多部分。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f481" class="ly lz je bd ma mb mc md me mf mg mh mi kk mj kl mk kn ml ko mm kq mn kr mo mp bi translated">结论</h1><p id="8cf4" class="pw-post-body-paragraph kt ku je kv b kw np kf ky kz nq ki lb lc nr le lf lg ns li lj lk nt lm ln lo im bi translated"><strong class="kv jf"> <em class="lp">在这篇文章中，我谈到了一些最有影响力的图算法，它们改变了我们的生活方式。</em>T11】</strong></p><p id="7a64" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">随着如此多的社交数据的出现，网络分析可以在改善我们的模型和产生价值方面提供很大帮助。</p><p id="b83e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="lp">甚至对世界多一点了解。</em>T15】</strong></p><p id="22b5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">有很多图形算法，但这是我最喜欢的。如果你愿意的话，一定要更详细地研究这些算法。在这篇文章中，我只是想获得该领域所需的广度。</p><p id="4244" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你觉得我把你最喜欢的算法留在了评论里，请告诉我。</p><p id="20e8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">下面是<a class="ae lq" href="https://www.kaggle.com/mlwhiz/top-graph-algorithms" rel="noopener ugc nofollow" target="_blank"> Kaggle 内核</a>的全部代码。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="572b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你想阅读更多关于图算法的内容，这里有一个由 UCSanDiego 在 Coursera 上开设的<a class="ae lq" href="https://coursera.pxf.io/YgKbbe" rel="noopener ugc nofollow" target="_blank">大数据图分析课程</a>，我强烈推荐你学习图论的基础知识。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="16f6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">谢谢你的阅读。将来我也会写更多初学者友好的帖子。在<a class="ae lq" href="https://medium.com/@rahul_agarwal?source=post_page---------------------------" rel="noopener"> <strong class="kv jf">媒体</strong> </a>关注我或者订阅我的<a class="ae lq" href="https://mlwhiz.ck.page/a9b8bda70c" rel="noopener ugc nofollow" target="_blank"> <strong class="kv jf">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter <a class="ae lq" href="https://twitter.com/MLWhiz?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系。</p></div></div>    
</body>
</html>