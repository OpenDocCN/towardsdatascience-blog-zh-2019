<html>
<head>
<title>Using MongoDB Change Streams to replicate data into BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 MongoDB 更改流将数据复制到 BigQuery 中</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-mongodb-change-streams-to-replicate-data-into-bigquery-64ab54636b0e?source=collection_archive---------13-----------------------#2019-01-03">https://towardsdatascience.com/using-mongodb-change-streams-to-replicate-data-into-bigquery-64ab54636b0e?source=collection_archive---------13-----------------------#2019-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="43bc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们在使用 MongoDB 变更流构建 MongoDB 到 BigQuery 数据管道时所获得的经验和面临的挑战</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/56688bea835fbf60509d1c7866873326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lvnw5cWvVpkLEu5s"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@quinten149?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Quinten de Graaf</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8dff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在进入技术细节之前，最好回顾一下我们为什么决定建立这个管道。我们开发它有两个主要原因:</p><ol class=""><li id="3ac5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">在一定规模下，查询 MongoDB 进行分析是没有效率的。</li><li id="9281" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们没有 MongoDB 中的所有数据(例如条带计费信息)。</li><li id="e2d7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">数据管道即服务供应商在一定规模下非常昂贵。并且，通常不提供复制删除记录的方法，如<em class="mg">软删除</em>(例如，使用<code class="fe mh mi mj mk b">deleted_at</code>字段)。</li></ol><h2 id="c5b0" class="ml mm iq bd mn mo mp dn mq mr ms dp mt lf mu mv mw lj mx my mz ln na nb nc nd bi translated">复制无模式数据</h2><p id="98e4" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">在使用这个 MongoDB 数据库时，我们注意到的第一件事是一些集合有一个棘手的<em class="mg">模式</em>。文档内部有嵌套文档，其中一些也是数组。</p><p id="952c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，一个嵌套的文档代表一个一对一的关系，一个数组代表一对多的关系。幸运的是，Big Query 同时支持<a class="ae kv" href="https://cloud.google.com/bigquery/docs/nested-repeated" rel="noopener ugc nofollow" target="_blank">重复字段和</a>嵌套字段。</p><p id="60bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据我们的研究，复制 MongoDB 数据的最常见方式是在集合中使用时间戳字段。该字段通常被命名为<code class="fe mh mi mj mk b">updated_at</code>，并在每次记录被<em class="mg">插入</em>或<em class="mg">更新</em>时被更新。这种方法很容易用批处理方法实现，它只需要查询所需的集合。当将它应用于我们的数据和集合时，我们发现了两个主要问题:</p><ol class=""><li id="ca57" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">并非所有我们想要复制的集合都有这个字段。<strong class="ky ir">没有</strong> <code class="fe mh mi mj mk b"><strong class="ky ir">updated_at</strong></code> <strong class="ky ir">，我们怎么知道哪些记录被更新复制了呢？</strong></li><li id="5970" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">此方法不跟踪已删除的记录。我们只是将它们从原始集合中删除，并且永远不会在我们的大查询表中更新。</li></ol><p id="5e7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，MongoDB 在<code class="fe mh mi mj mk b">oplog</code>中保存了应用于集合的所有更改的日志。从 MongoDB 3.6 开始，您可以使用<a class="ae kv" href="https://docs.mongodb.com/manual/changeStreams/" rel="noopener ugc nofollow" target="_blank">变更流</a> API 来查询它们。这样，集合中的每个变化(包括<code class="fe mh mi mj mk b">delete</code>操作)都会提醒我们。</p><p id="720a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们的目标是构建一个管道，将 MongoDD Change Streams 返回的所有变更事件记录移动到一个大的查询表中，其中包含每个记录的最新状态。</p><h1 id="85cb" class="nj mm iq bd mn nk nl nm mq nn no np mt jw nq jx mw jz nr ka mz kc ns kd nc nt bi translated">建设管道</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/b763612a2f1bc6cea5f267f8b75d6bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vaLfJbvRDY1sWVhv"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">NeONBRAND</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="584a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的第一种方法是在 Big Query 中为我们想要复制的每个集合创建一个变更流表，并从该集合的所有变更流事件中推断出模式。这被证明是相当棘手的。如果在记录中添加了一个新字段，管道应该足够智能，在插入记录之前修改大的查询表。</p><p id="98e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们希望在大查询中尽快获得数据，所以我们采用了另一种方法。将所有变更流事件作为 JSON blob 转储到 BigQuery 中。然后，我们可以使用像<a class="ae kv" href="https://www.getdbt.com/" rel="noopener ugc nofollow" target="_blank"> dbt </a>这样的工具来提取、转换原始的 JSON 数据，并将其转换成合适的 SQL 表。当然，这有一些缺点，但让我们很快就有了端到端的管道。</p><p id="7eb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">管道具有以下组件:</p><ol class=""><li id="20c3" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">Kubernetes ( <code class="fe mh mi mj mk b"><a class="ae kv" href="https://github.com/bufferapp/carden" rel="noopener ugc nofollow" target="_blank">carden</a></code>)中运行的一个服务，它读取每个集合的 MongoDB 变更流，并将其推送到一个简单的大查询表中(追加所有记录)。</li><li id="b9e4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">一个 dbt cronjob，它使用原始数据<a class="ae kv" href="https://docs.getdbt.com/v0.12/docs/materializations#section-incremental" rel="noopener ugc nofollow" target="_blank">增量读取源表，并将一个查询具体化为一个新表</a>。此表包含自上次运行以来更改的每行的最新状态。这是 dbt SQL 在生产环境中的一个示例。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2037" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这两个步骤，我们就有了从 MongoDB 实时流向 Big Query 的数据<strong class="ky ir">。我们还跟踪<em class="mg">删除</em>，并且我们拥有我们正在复制的集合中发生的所有更改(对于需要一段时间内的更改信息的某种分析很有用)。</strong></p><p id="a395" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们在启动 MongoDB 更改流爬行服务之前没有任何数据，因此我们丢失了许多记录。为了解决这个问题，我们决定回填创建假的变化事件。我们转储了 MongoDB 集合，并制作了一个简单的脚本，将文档包装成插入。这些记录被发送到同一个 BigQuery 表中。现在，运行同一个 dbt 模型给我们最终的表，其中包含所有回填的记录。</p><p id="43c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们发现的主要缺点是，我们需要用 SQL 编写所有的提取。这意味着大量额外的 SQL 代码和一些额外的处理。目前，使用 dbt 并不太难。另一个小问题是 BigQuery <a class="ae kv" href="https://stackoverflow.com/questions/52120182/bigquery-json-extract-all-elements-from-an-array" rel="noopener ugc nofollow" target="_blank">本身不支持提取 JSON </a>中编码的数组的所有元素。</p><h1 id="8302" class="nj mm iq bd mn nk nl nm mq nn no np mt jw nq jx mw jz nr ka mz kc ns kd nc nt bi translated">结论</h1><p id="6cdc" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">对我们来说，好处(迭代时间、变更的容易程度、简单的管道)大于坏处。因为我们刚刚开始使用这个管道，所以让一切端到端地工作并快速迭代是非常有用的！让 BigQuery 只附加更改流表作为一个分离来服务我们。在未来，我们计划迁移到 Apache Beam 和 Cloud 数据流，但那是另一篇文章！</p><p id="0252" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你对这些见解感兴趣！你可以在推特上找到我，账号是@davidgasquez 。如果你有任何问题，不要犹豫，尽管来找我。</p></div></div>    
</body>
</html>