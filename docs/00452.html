<html>
<head>
<title>The meaning of “life” and other NLP stories</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">《生命的意义》及其他 NLP 故事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-meaning-of-life-and-other-nlp-stories-4cbe791ce62a?source=collection_archive---------18-----------------------#2019-01-20">https://towardsdatascience.com/the-meaning-of-life-and-other-nlp-stories-4cbe791ce62a?source=collection_archive---------18-----------------------#2019-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="89ed" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">面向语言爱好者的组合语义学 Pythonic 介绍。</h2></div><h2 id="f7a7" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">“意义”的含义</h2><blockquote class="lb"><p id="2dd4" class="lc ld iq bd le lf lg lh li lj lk ll dk translated">"<strong class="ak">我们</strong>被<strong class="ak">的技术困住了，而我们</strong>真正<strong class="ak">想要的</strong>只是<strong class="ak">能工作的东西</strong>。"亚当斯</p></blockquote><p id="07ff" class="pw-post-body-paragraph lm ln iq lo b lp lq jr lr ls lt ju lu ko lv lw lx ks ly lz ma kw mb mc md ll ij bi me translated">尽管在这个人工智能时代，科技巨头做出了种种承诺，各种全新的小玩意迅速充斥着我们的家庭，但我们仍然很容易发现机器完全误解人类语言的令人沮丧的例子。在数千万美元之后，我们得到了这个:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Some A.I. epic fails — I’m sure you have your own top 10.</figcaption></figure><p id="3cec" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">当我们期待这个的时候(顺便问一下，我的喷气背包在哪里？):</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">A.I. writing a piece of music for you (awwww).</figcaption></figure><p id="f2c4" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated"><em class="nd">为什么？</em></p><p id="9d51" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">简而言之，理解语言是非常困难的，因为解决语言之谜意味着在一个同样困难的问题网络中航行，这些问题涉及我们认知能力的极限、逻辑表达的能力以及人类社会的怪癖和偏见:在柏拉图关于这个问题的思想提出多年后，我们仍然远远没有一个好的理论。</p><p id="f101" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">对于“<a class="ae ne" href="https://en.wikipedia.org/wiki/Natural_language_processing" rel="noopener ugc nofollow" target="_blank">自然语言处理</a>”(或“<a class="ae ne" href="https://en.wikipedia.org/wiki/Natural-language_understanding" rel="noopener ugc nofollow" target="_blank">自然语言理解</a>”，<em class="nd"> NLU </em>，就像最近酷孩子说的)来说，显然是<em class="nd">意为</em>的概念:可以说，我们在 NLU 仍然落后的原因之一是，我们对于<em class="nd">意为</em>没有一个好的、统一的观点。由于技术和历史原因，文献在某种程度上分为两种观点:</p><ul class=""><li id="1e7d" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll nk nl nm nn bi translated">有一种“统计”观点，例如由<a class="ae ne" href="https://arxiv.org/pdf/1301.3781.pdf" rel="noopener ugc nofollow" target="_blank"> word2vec </a>和相关<a class="ae ne" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/rvecs.pdf" rel="noopener ugc nofollow" target="_blank">作品</a>举例说明，主要在机器学习社区中进行:这里的焦点主要是词汇项和语义关系，如同义词；通常，这些分析成为下游系统应对挑战的支柱，如情感分析和<a class="ae ne" href="https://github.com/m2dsupsdlclass/lectures-labs/blob/master/labs/06_deep_nlp/NLP_word_vectors_classification_rendered.ipynb" rel="noopener ugc nofollow" target="_blank">文本分类</a>。在一句广告语中，<em class="nd">意为</em>是多维语义空间中的向量；</li><li id="b0a7" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated">有一种关于意义的“功能”观点，例如由<a class="ae ne" href="https://www.press.uchicago.edu/ucp/books/book/distributed/R/bo3685980.html" rel="noopener ugc nofollow" target="_blank">本</a>和<a class="ae ne" href="http://www.computational-semantics.eu/" rel="noopener ugc nofollow" target="_blank">相关的著作</a>举例说明，主要由<a class="ae ne" href="https://mitpress.mit.edu/books/ontological-semantics" rel="noopener ugc nofollow" target="_blank">语言学家</a>，语言哲学家和逻辑学家执行:这里的重点主要是推理的系统规则和语义关系，如蕴涵；典型的任务是自动推理和知识表示。在广告语中，<em class="nd">表示</em>是语言片段的功能(如名词、连接词等)。)到集合论对象(例如集合的元素、函数等)。).</li></ul><p id="ec5c" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">虽然这种区分显然有点过于简单(虽然，例如，非常接近于背景中的<a class="ae ne" href="http://csli-lilt.stanford.edu/ojs/index.php/LiLT/article/view/6\" rel="noopener ugc nofollow" target="_blank"> <em class="nd"> Baroni 等人的</em> </a>)，但这是一个很好的初步近似:第一种方法更实用，更善于解释<a class="ae ne" href="http://cocosci.princeton.edu/papers/vector_space_analogy_cogsci2017_final.pdf" rel="noopener ugc nofollow" target="_blank">词汇概念</a>之间的关系(<a class="ae ne" href="https://www.aclweb.org/anthology/D14-1162" rel="noopener ugc nofollow" target="_blank"> <em class="nd">男人</em>对于<em class="nd">国王</em>，什么<em class="nd">女人</em>对于……？</a>”；第二种比较抽象，善于解释文字<a class="ae ne" href="https://www.jstor.org/stable/25001052" rel="noopener ugc nofollow" target="_blank">如何组合在一起</a>产生复杂的概念。</p><p id="e552" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">为了在深入理论之前立即理解一些实际后果，请考虑您最喜欢的 CRM 中的以下客户表:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/012c04b1010ecb2f9cc8ec2d14403b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*o3P-1fsLjuq9AfY_C7u0bQ.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">A sample customer table recording customers and payments.</figcaption></figure><p id="e479" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">有许多问题我们希望我们的计算机能自动回答:所有的顾客都付款了吗？鲍勃明确付钱了吗？鲍勃比阿达付的多吗？</p><p id="6c73" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">在“统计”视图下(比如，<a class="ae ne" rel="noopener" target="_blank" href="/training-a-goal-oriented-chatbot-with-deep-reinforcement-learning-part-i-introduction-and-dce3af21d383">一个深度学习聊天机器人</a>)，我们会尝试收集许多(<em class="nd">许多！</em>)配对&lt;问题，在这个和类似的设置中回答&gt;，然后想出一些优化程序，让我们的系统准备好回答看不见的问题。在“功能”的观点下，我们将<em class="nd">首先</em>教计算机关于列和它们的关系，然后使用语义的力量通过评估合适的正式语言的表达式来回答看不见的问题。所谓的“作为推理的查询”范式不需要大数据训练，并且随着问题复杂性的增加，可以预测地推广，但它有自己的缺点。</p><p id="6058" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">我们相信这两种传统都使我们对语言的理解有了很大的进步，但是当然没有一种传统能让我们达到 HAL 9000。无论您选择什么武器来应对当前的 NLP 挑战，对这两种观点的深刻理解对于在艰难的现实场景中取得进展都是至关重要的。既然有<a class="ae ne" href="http://w4nderlu.st/teaching/word-embeddings" rel="noopener ugc nofollow" target="_blank">大量最近的材料</a> <strong class="lo ir"> </strong>关于第一个传统已经<a class="ae ne" href="https://www.kaggle.com/pierremegret/gensim-word2vec-tutorial" rel="noopener ugc nofollow" target="_blank">可用</a>，<em class="nd">这个</em>小帖子将作为我们(固执己见的)第二个中基本概念的介绍。</p><p id="86d6" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated"><em class="nd">免责声明:这篇文章主要是为熟悉统计 NLP 工具包(从</em> <a class="ae ne" href="https://en.wikipedia.org/wiki/Katz%27s_back-off_model" rel="noopener ugc nofollow" target="_blank"> <em class="nd">后退语言模型</em> </a> <em class="nd">，到</em><a class="ae ne" href="https://en.wikipedia.org/wiki/Word2vec" rel="noopener ugc nofollow" target="_blank"><em class="nd">word 2 vec</em></a><em class="nd">)但从未接触过形式语义的刺激和危险的数据科学家和受过教育的读者写的。遵循古语“</em>我不能创造的，我不理解的”，<em class="nd">我们强化了共享一个</em> <a class="ae ne" href="https://github.com/jacopotagliabue/tarski-2.0" rel="noopener ugc nofollow" target="_blank"> <em class="nd">小 Python 项目</em> </a> <em class="nd">的概念(完整细节在最后)。另一方面，已经熟悉模型理论但不太熟悉现代编程语言的读者可以使用 repo 来了解“语义计算”如何通过代码来表达(请注意，我们将在这里或那里稍微滥用符号和术语，以专注于建立直觉，而不是开发正式的系统)。</em></p><p id="a125" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated"><strong class="lo ir"> <em class="nd">这个帖子的代码可以在</em></strong><a class="ae ne" href="https://github.com/jacopotagliabue/tarski-2.0" rel="noopener ugc nofollow" target="_blank"><strong class="lo ir"><em class="nd">GitHub</em></strong></a><strong class="lo ir"><em class="nd">上免费获得。</em> </strong></p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="fbc9" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">思想的语言(或者:如何用简单的概念表达复杂的概念)</h2><blockquote class="lb"><p id="517a" class="lc ld iq bd le lf lg lh li lj lk ll dk translated">”<strong class="ak">命题是其真值条件的表达。</strong>”—维特根斯坦，<a class="ae ne" href="https://en.wikipedia.org/wiki/Tractatus_Logico-Philosophicus" rel="noopener ugc nofollow" target="_blank">《逻辑哲学论》</a> (4.431)</p></blockquote><p id="b7b1" class="pw-post-body-paragraph lm ln iq lo b lp lq jr lr ls lt ju lu ko lv lw lx ks ly lz ma kw mb mc md ll ij bi translated">为了理解作为一门学科的形式语义学(以及它与其他方法的不同)，我们需要回到 20 世纪初的一个疯狂的奥地利人身上。<em class="nd">理解一句话的意思是什么？</em></p><blockquote class="od oe of"><p id="6bbd" class="lm ln nd lo b lp my jr lr ls mz ju lu og na lw lx oh nb lz ma oi nc mc md ll ij bi translated">理解一个句子的意思意味着理解它的真值条件，也就是说，理解如果这个句子是真的，这个世界会是什么样子。</p></blockquote><p id="623d" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">所以，要让“狮子比家猫大”成为事实，世界应该是这样的:一种给定类型的猫科动物比另一种更大(真)；要让“狮子比蓝鲸大”成为真，世界应该是这样的，给定类型的猫科动物比给定类型的水生哺乳动物大(假)(请注意:我们能确立句子是真/假的事实与理解它无关；每个人都明白“1517 年 1 月 1 日威尼斯的猫的总数是奇数。”，但没人知道是不是真的)。</p><p id="702c" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">所以如果我们买那个<em class="nd">意=真条件</em>，问题不就解决了吗？实际上<em class="nd">没有</em>，因为可能的句子数量是<em class="nd">无限的</em>:没有一个列表，无论多么大，都会给我们“英语的所有真实条件”。让读者惊讶不已的是，下面这句话——很可能是历史上第一次写在这里<strong class="lo ir">—</strong>——可以毫不费力地理解:</p><blockquote class="od oe of"><p id="86e9" class="lm ln nd lo b lp my jr lr ls mz ju lu og na lw lx oh nb lz ma oi nc mc md ll ij bi translated">46 只企鹅从 Ciad 的一个基因实验室意外逃脱后，在撒哈拉沙漠中失踪。</p></blockquote><p id="49f9" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">这是怎么发生的？资源有限的有限头脑怎么可能无限理解<em class="nd">许多事情？</em></p><p id="b327" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">形式语义就像玩无限乐高:复杂的乐高是用更简单的积木搭建的，更简单的乐高是用基本的乐高积木搭建的；如果你知道砖块是如何组合的，并且有一些砖块作为开始，你可以创造出无数的东西。以非常相似的方式，一个句子的(待定义)含义可以预测地从其成分的(待定义)含义中建立起来:所以如果你知道<em class="nd">企鹅</em>和<em class="nd">撒哈拉</em>的含义，你就可以理解一只企鹅在沙漠中迷路意味着什么。</p><blockquote class="od oe of"><p id="372e" class="lm ln nd lo b lp my jr lr ls mz ju lu og na lw lx oh nb lz ma oi nc mc md ll ij bi translated">形式语义学是研究指令集的学科，在指令集里我们的语言可以被组合在一起。</p></blockquote><p id="54f7" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">如果所有这些对人类来说都很简单，那么检查一些著名的 NLP 架构中的组合性将会很好。以下面的两个句子和<a class="ae ne" href="https://deepmoji.mit.edu/#" rel="noopener ugc nofollow" target="_blank"> DeepMoji </a>为例，这是一个建议表情符号的神经网络(这个例子来自我们的<a class="ae ne" rel="noopener" target="_blank" href="/in-praise-of-artificial-stupidity-60c2cdb686cd">人工智能观点文章</a>):</p><ul class=""><li id="5397" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll nk nl nm nn bi translated">我的航班被延迟了..太神奇了。</li><li id="1dee" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated">我的航班没有延误..太神奇了。</li></ul><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi oj"><img src="../Images/14b07f72c16808898f30afb1f4605a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*62AnAbtZZpmPNjOkkrjrBQ.gif"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">The same emojis are suggested for the sarcastic vs normal sentence (original video <a class="ae ne" href="https://drive.google.com/file/d/1rI0uV_5TsqpxXf2mYQmTxkx_4a3NlxdY/view" rel="noopener ugc nofollow" target="_blank">here</a>).</figcaption></figure><p id="523c" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">这两个句子只有一个单词不同(<em class="nd">而不是</em>)，但我们知道这个单词是“特殊的”。<em class="nd">而不是</em>促成的方式(是的！)上面句子的真值条件被 DeepMoji 完全忽略了，它甚至不拥有一个非常基本的复合性概念；换句话说，在一个句子中添加否定通常不会在一条想象的“意义线上”移动几个点(无论如何解释)(就像在“这个蛋糕(非常)好”中添加“非常”)，而是完全“颠倒”它。</p><p id="2b8e" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">无论 DeepMoji 和类似系统中嵌入了什么“语言理解”,如果我们要捕捉上面的<em class="nd">而不是</em>行为，我们需要一种完全不同的方式来表示<em class="nd">的含义</em>。形式语义学的故事是关于我们如何利用数学使“语言乐高”的概念更加精确和易于处理的故事。</p><p id="b817" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">请注意，这不是一个大团圆结局的故事。</p><h2 id="43c4" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">语义学 101</h2><blockquote class="lb"><p id="177e" class="lc ld iq bd le lf lg lh li lj lk ll dk translated">"在我看来，自然语言和逻辑学家的人工语言之间没有重要的理论区别。"——r·蒙塔古</p></blockquote><p id="bf56" class="pw-post-body-paragraph lm ln iq lo b lp lq jr lr ls lt ju lu ko lv lw lx ks ly lz ma kw mb mc md ll ij bi translated">关于<em class="nd">表示</em>的一个关键问题是，它有两个<em class="nd">元素——回想一下上面那个古怪的奥地利人的定义:</em></p><blockquote class="od oe of"><p id="dc15" class="lm ln nd lo b lp my jr lr ls mz ju lu og na lw lx oh nb lz ma oi nc mc md ll ij bi translated">…理解如果这句话是真的，世界会是什么样子。</p></blockquote><p id="c646" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">所以有一个<em class="nd">句子</em>，没错，但也有<em class="nd">世界</em>:意义，本质上是我们的语言和我们的世界之间的某种关系(从技术上来说，<a class="ae ne" href="https://en.wikipedia.org/wiki/Kripke_semantics" rel="noopener ugc nofollow" target="_blank">多个世界</a>，但事情就变得复杂了)。由于世界是一个相当大且不切实际的东西，我们使用集合论中的对象作为我们的世界模型。在公式和代码之前，我们将首先使用这一部分来建立我们的直觉。</p><p id="55fb" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">我们的第一个玩具语言由以下基本元素组成:</p><pre class="mn mo mp mq gt oo op oq or aw os bi"><span id="ba6f" class="kf kg iq op b gy ot ou l ov ow">names = ['Jacopo', 'Mattia', 'Ryan', 'Ciro']<br/>predicates = ['IsItalian', 'IsAmerican', 'IsCanadian']<br/>connectives = ['and']<br/>negation = ['not']</span></pre><p id="e551" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">基本元素可以根据以下语法规则进行组合:</p><pre class="mn mo mp mq gt oo op oq or aw os bi"><span id="cc15" class="kf kg iq op b gy ot ou l ov ow">a "name + predicate" is a formula<br/>if A is a formula and B is a formula, "A connective B" is a formula<br/>if A is a formula, "negation A" is a formula</span></pre><p id="a92d" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">这意味着下面的句子都是<em class="nd"> L </em>的一部分:</p><pre class="mn mo mp mq gt oo op oq or aw os bi"><span id="b1b6" class="kf kg iq op b gy ot ou l ov ow">Jacopo IsItalian<br/>Mattia IsAmerican and Jacopo IsItalian<br/>not Jacopo IsItalian<br/>...</span></pre><p id="91d6" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">现在是时候介绍一下<em class="nd">语义</em>了:虽然我们可能会被诱惑<em class="nd">使用一些背景知识来解释 L </em>(例如，我的名字是“雅格布”)，但记住<em class="nd"> L </em>中的句子没有任何意义是绝对重要的。由于我们期望复杂事物的意义是从简单事物建立起来的，我们将从<em class="nd">名称</em>和<em class="nd">谓词</em>的意义开始，因为“名称+谓词”是我们需要解释的最简单的句子。我们从论域<em class="nd"> D </em>开始，论域是由一些元素和一些子集组成的集合，然后我们说:</p><ul class=""><li id="2205" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll nk nl nm nn bi translated">名字的意义(它的“外延”)是 D 的一个元素；</li><li id="f2a8" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated">谓词的意义(它的“外延”)是 d 的子集。</li></ul><p id="67b9" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated"><em class="nd"> D </em>是我们模型的通用“容器”:它只是一个“盒子”,里面有表示<em class="nd"> L. </em>中的含义所需的所有部分。如果您将一个示例<em class="nd"> D </em>(如下)可视化，就很容易理解我们如何为“名称+谓词”句子定义<em class="nd">真值条件</em>:</p><ul class=""><li id="9dc6" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll nk nl nm nn bi translated">如果 A 是“名+谓”句，则 A 为真当且仅当<code class="fe ox oy oz op b">name</code>的外延在<code class="fe ox oy oz op b">predicate</code>的外延内。</li></ul><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pa"><img src="../Images/3d781a7ea2019d92211cfec07e7c413d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ba9SFS8isCGoIuT_u7sNVQ.jpeg"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">A sample domain for our toy language L.</figcaption></figure><p id="a6e5" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">比如说:</p><ul class=""><li id="bd77" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll nk nl nm nn bi translated">当且仅当代表<code class="fe ox oy oz op b">Jacopo</code>的<em class="nd"> D </em>中的元素是代表<code class="fe ox oy oz op b">IsItalian</code>的集合的成员时，“Jacopo IsItalian”为真；</li><li id="f56b" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated">当且仅当代表<code class="fe ox oy oz op b">Jacopo</code>的<em class="nd"> D </em>中的元素是代表<code class="fe ox oy oz op b">IsCanadian</code>的集合的成员时，“雅格布是加拿大人”为真。</li></ul><p id="4b68" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">正如我们所了解的，<em class="nd">真值条件</em>不会告诉你什么是真/假，而是告诉你这个世界(更好地说，你的世界模型)对于事物的真/假应该是什么样子。有了我们的定义，我们可以再次查看我们的<em class="nd"> D </em>并且我们可以看到，在我们的例子中，“雅格布·伊斯塔利亚”是真的，而“雅格布·伊斯塔利亚”是假的。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pa"><img src="../Images/fe563d5a90a8d4c6445efca1199759c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwEyzBEukI7SwlytD6v7_w.jpeg"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">The extension of “isItalian” contains the denotation of “Jacopo” (in purple).</figcaption></figure><p id="ac7f" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">当<em class="nd"> L </em>中的一个句子在我们这个集合论的小世界中为真时，我们也说这个句子在模型中是<em class="nd">满足</em>(从技术上讲，对句子来说<em class="nd">为真</em>是对一般公式来说<em class="nd">满足</em>的特例)。既然我们已经为基本句子定义了真值条件，我们就可以通过基本句子来定义复杂句子的真值条件:</p><ul class=""><li id="f569" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll nk nl nm nn bi translated">如果 A 是公式，B 是公式，“A 和 B”为真当且仅当 A 为真，B 为真。</li></ul><p id="62e6" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">比如说:</p><ul class=""><li id="0fe0" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll nk nl nm nn bi translated">当且仅当雅格布·伊斯塔里安和马蒂亚·伊斯塔里安为真且马蒂亚·伊斯塔里安为真时，雅格布·伊斯塔里安和马蒂亚·伊斯塔里安为真。</li></ul><p id="7b5f" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">由于“Jacopo IsItalian”和“Mattia IsAmerican”是“名+谓”句，我们现在可以完整地拼出意思了:</p><ul class=""><li id="9e30" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll nk nl nm nn bi translated">当且仅当代表<code class="fe ox oy oz op b">Jacopo</code>的<em class="nd"> D </em>中的元素是代表<code class="fe ox oy oz op b">IsItalian</code>的集合的成员，代表<code class="fe ox oy oz op b">Mattia</code>的<em class="nd"> D </em>中的元素是代表<code class="fe ox oy oz op b">IsAmerican</code>的集合的成员。</li></ul><p id="0377" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">有了我们的定义，我们可以查看<em class="nd"> D </em>并且看到“雅格布·伊斯塔里安和马蒂亚·伊萨美国”是错误的，因为“马蒂亚·伊萨美国”是错误的:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pa"><img src="../Images/57b860d9a8ecb254e8b9b75f769f1a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ck_T8lNnSZ2mAyvN3b1mww.jpeg"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">The extension of “isAmerican” does not contain the denotation of “Mattia” (in blue).</figcaption></figure><p id="a97d" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">最后，我们可以在我们的<em class="nd">语义</em>中看到<em class="nd">否定</em>如何确实是一个“反转”操作:</p><ul class=""><li id="6be9" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll nk nl nm nn bi translated">如果 A 是一个公式，“非 A”为真当且仅当 A 为假。</li><li id="72c0" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated">“不是雅格布·伊斯塔里安”为真，当且仅当“雅格布·伊斯塔里安”为假。</li><li id="4067" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated">当且仅当代表<code class="fe ox oy oz op b">Jacopo</code>的<em class="nd"> D </em>中的元素不是代表<code class="fe ox oy oz op b">IsItalian</code>的集合的成员时，“not Jacopo IsItalian”为真。</li></ul><p id="e87b" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">显然，为我们的玩具语言<em class="nd"> L </em>指定真值条件对于构建 HAL 9000 并不是非常有用。但即使是这个简单的例子，也应该注意两件事:</p><ol class=""><li id="019f" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll pb nl nm nn bi translated">我们的<em class="nd">语义</em>是完全复合的，并允许<em class="nd">以有限的方式为无限数量的句子</em>分配真值条件:在<em class="nd"> L </em>中没有一个可能的句子被我们的意义定义遗漏。更具表达力的语言会有(更)复杂的组合规则，但总的要点是一样的:一组有限的指令自动概括成无限多的目标句子；</li><li id="399b" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll pb nl nm nn bi translated">我们对<em class="nd"> D </em>的选择只是众多可能性中的一个:我们可以选择一个“Mattia IsAmerican”为真的世界，我们的<em class="nd">语义</em>也是一样的——记住，<em class="nd">语义</em>分配真值条件，但它没有说明这些条件实际上是如何满足的。在现实世界的应用中，我们也经常对<em class="nd">真理</em>感兴趣，因此我们需要将语义与“知识库”相结合，即关于我们所关心的世界的具体事实:当对现实世界的现象建模时，<em class="nd"> D </em>应该被解释为与其“同构”，因此“在<em class="nd"> D </em>中为真”将意味着“在感兴趣的领域中为真”。</li></ol><p id="89c5" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">专业读者可能已经猜到了我们如何通过利用上面的(1)和(2)来构建具有直接价值的应用程序:(1)保证由语义编码的知识很好地一般化；(2)保证在我们仔细选择目标域的范围内，满意度算法将评估所有并且只有我们关心其真实性的句子为真。</p><p id="412e" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">特别是，即使是计算语义学中更简单的程序(比如检查任意公式满意度的代码)也可以被看作是作为推理的的<em class="nd">查询的一个实例(这里支持<a class="ae ne" href="https://www.press.uchicago.edu/ucp/books/book/distributed/R/bo3685980.html" rel="noopener ugc nofollow" target="_blank"/>):</em></p><blockquote class="od oe of"><p id="c332" class="lm ln nd lo b lp my jr lr ls mz ju lu og na lw lx oh nb lz ma oi nc mc md ll ij bi translated">给定一个以某种有用的方式(例如数据库)建模的世界状态，机器能自动回答我们关于感兴趣的领域的问题吗？</p></blockquote><p id="30d6" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">在接下来的章节中，我们将在这样的背景下探索一种稍微复杂一点的语言。</p><p id="6a1b" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">【<strong class="lo ir">额外的技术要点</strong>:如果<em class="nd">语义</em>不以任何方式约束真理——即就语义而言，一个<code class="fe ox oy oz op b">Jacopo isItalian</code>为真的世界和一个<code class="fe ox oy oz op b">Jacopo isCanadian</code>为真的世界一样好——它本身有帮助吗？是的，非常，但是要知道为什么我们需要明白语义学的<em class="nd">核心概念</em>确实是<em class="nd">蕴涵、</em>即研究在什么条件下一个句子 X 在逻辑上被一组句子 Y <em class="nd"> 1 </em>，Y <em class="nd"> 2 </em>，… Y <em class="nd"> n </em>所隐含。特别是，真正的问题语义学设定的答案是:</p><ul class=""><li id="aad5" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll nk nl nm nn bi translated">给定一个域<em class="nd"> D，</em>一个句子<em class="nd"> X，</em>一个句子<em class="nd"> Y </em>，如果<em class="nd"> D </em>中<em class="nd"> X </em>为真，那么<em class="nd"> Y </em>也必然为真吗？</li></ul><p id="8927" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated"><em class="nd">蕴涵</em>也是证明理论的关键概念:事实上，我们对演绎系统和语义之间的<a class="ae ne" href="https://en.wikipedia.org/wiki/G%C3%B6del%27s_completeness_theorem" rel="noopener ugc nofollow" target="_blank">关系有一个惊人的证明，但这个笔记太小，无法包含它。]</a></p><h2 id="472b" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><em class="pc">“查询</em>作为推理”使用计算语义</h2><blockquote class="lb"><p id="38d5" class="lc ld iq bd le lf lg lh li lj lk ll dk translated">"为了理解递归，你必须首先理解递归."— <a class="ae ne" href="https://www.thinkgeek.com/images/products/frontsquare/b2ae_recursion.jpg" rel="noopener ugc nofollow" target="_blank">我的 t 恤</a></p></blockquote><p id="c548" class="pw-post-body-paragraph lm ln iq lo b lp lq jr lr ls lt ju lu ko lv lw lx ks ly lz ma kw mb mc md ll ij bi translated">假设下表摘自我们的 CRM:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/bee280f0f7645f76a9ec9e0ea401250f.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*rfvl6yIsG3Q1iZfq06y4Yw.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">A sample customer table recording customers and payments.</figcaption></figure><p id="762a" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">即使看着这样一个简单的表格，我们也可能会想问很多有趣的问题:</p><ul class=""><li id="90ac" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll nk nl nm nn bi translated">所有顾客都付钱了吗？</li><li id="946a" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated"><em class="nd"> Bob </em>具体付出了吗？</li><li id="2b4f" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated">鲍勃付了五美元吗？</li><li id="adfb" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated"><em class="nd"> …以此类推</em></li></ul><p id="babc" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">我们可以很好地利用我们的框架，为这个领域制定一个语义，然后查询系统以获得我们需要的所有答案(描绘这个用例的 Python 笔记本也包含在<a class="ae ne" href="https://github.com/jacopotagliabue/tarski-2.0" rel="noopener ugc nofollow" target="_blank">的报告</a>中)。因此，第一步是创建一种语言来表示我们的目标领域，例如:</p><pre class="mn mo mp mq gt oo op oq or aw os bi"><span id="4433" class="kf kg iq op b gy ot ou l ov ow">names = ['bob', 'dana', 'ada', 'colin'] + digits [0-9]<br/>unary predicates = ['IsCustomer', 'IsPayment']<br/>binary predicates = ['MadePayment', 'HasTotal']<br/>quantifiers = ['all', 'some']<br/>connectives = ['and']<br/>negation = ['not']</span></pre><p id="576d" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">我们的语言允许我们表达这样的概念:</p><pre class="mn mo mp mq gt oo op oq or aw os bi"><span id="157f" class="kf kg iq op b gy ot ou l ov ow">there is a thing in the domain of discourse which is a customer named bob</span><span id="0ca6" class="kf kg iq op b gy pd ou l ov ow">there is a thing ... X which is a customer, a thing Y which is a payment, and X made Y</span><span id="7918" class="kf kg iq op b gy pd ou l ov ow">there is a thing ... which is a payment and has a total of X</span></pre><p id="2118" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">第二步是建立一个模型，忠实地代表我们的兴趣表。换句话说，我们需要构建一个对象域，即名称和对象之间的映射，并正确地解释谓词扩展，以便表中指定的属性在模型中一致地表示:</p><pre class="mn mo mp mq gt oo op oq or aw os bi"><span id="a4a9" class="kf kg iq op b gy ot ou l ov ow">domain: [1, 2, 3, 4, 5, 6],<br/>constants: {'bob': 1, 'dana': 2, 'ada': 3, 'colin': 4},<br/>extensions: {<br/>  'IsCustomer': [[1], [2], [3], [4]],<br/>  'IsPayment': [[5], [6]],<br/>  'MadePayment': [[1, 5], [2, 6]]<br/>  ...<br/>}</span></pre><p id="26ba" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">一旦完成，我们就可以查询系统，让机器自动计算答案:</p><ul class=""><li id="a62c" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll nk nl nm nn bi translated"><code class="fe ox oy oz op b">Did all customers pay?</code>变成查询<code class="fe ox oy oz op b">For each thing x, if x IsCustomer, there is a y such that y IsPayment and x MadePayment y</code>，评估为<code class="fe ox oy oz op b">False</code> [ <strong class="lo ir">加分技术点</strong>:为了简洁起见，我们一直在跳过涉及<code class="fe ox oy oz op b">all</code>语义的确切细节，其含义远比简单的名称复杂；感兴趣的读者可以探索我们的<a class="ae ne" href="https://github.com/jacopotagliabue/tarski-2.0" rel="noopener ugc nofollow" target="_blank">回购</a>，了解计算<code class="fe ox oy oz op b">all</code>和<code class="fe ox oy oz op b">some</code>含义所需的所有技术步骤。</li><li id="0b07" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated"><code class="fe ox oy oz op b">Did Bob pay?</code>成为查询<code class="fe ox oy oz op b">There is an x such that x IsPayment and bob MadePayment y</code>，被求值为<code class="fe ox oy oz op b">True</code>。</li><li id="80fd" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated"><code class="fe ox oy oz op b">Did Bob pay 5 dollars?</code>成为查询<code class="fe ox oy oz op b">There is an x such that x IsPayment and bob MadePayment x and x HasTotal 5</code>，被评估为<code class="fe ox oy oz op b">True</code> [ <strong class="lo ir">附加技术要点</strong>:为了快速扩展语义以处理数字比较，我们必须 I)在语法规范中引入数字，ii)修改原子公式中的满意度定义，以确保数字映射到自身。显然，全面概括地包含数字需要更多的技巧:鼓励非常不懒惰的读者从现有的框架开始思考如何做到这一点！].</li></ul><p id="1329" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">这不是很棒吗？如果我们的模型反映了底层的客户表，我们可以问<em class="nd">几乎无限多的问题</em>，并确保能够精确地计算出答案——所有这些都只需要几行 Python 代码。</p><h2 id="a9bf" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">从玩具模型到现实</h2><blockquote class="lb"><p id="4250" class="lc ld iq bd le lf lg lh li lj lk ll dk translated">“从理论上来说，理论和实践之间没有区别。实际上是有的。”-y .贝拉</p></blockquote><p id="3bea" class="pw-post-body-paragraph lm ln iq lo b lp lq jr lr ls lt ju lu ko lv lw lx ks ly lz ma kw mb mc md ll ij bi translated">“作为推理的查询”范式具有形式逻辑的所有优雅和美丽:一个小的和很好理解的 Python 脚本可以用来回答目标领域中潜在的无限问题。不幸的是，它也有形式逻辑的所有<em class="nd">缺点</em>，这使得它在实验室之外的直接应用不像你希望的那样简单:</p><ul class=""><li id="b9b5" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll nk nl nm nn bi translated"><em class="nd">语义</em>正如我们所定义的，它仅限于表达一些基本的概念和关系，但我们希望做得更多(例如，我们希望<code class="fe ox oy oz op b">sum</code>关注上面客户表中的数字)。虽然可以扩展框架以覆盖日益复杂的结构，但这需要付出一些复杂性和人工成本；</li><li id="3d92" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated">真实用例中的模型构建需要做出许多艰难的决定:在我们的玩具客户表示例中，我们仍然需要做出重要的选择，如何将表行映射到可以正式查询的域。用例越复杂，数据科学家就越难产生一个紧凑、完整、可扩展的形式域；</li><li id="994e" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated"><em class="nd">查询</em>是用一种正式的语言完成的，这种语言对人类并不友好:用户必须知道如何将英语翻译成某种合乎逻辑的方言才能得到想要的答案。当然，一个<em class="nd">好得多的 UX </em>将为用户提供一个英文搜索栏，并提供一个从自然语言翻译成正式语言的中间层——我们在<a class="ae ne" href="https://tooso.ai/" rel="noopener ugc nofollow" target="_blank">所做的一些工作也是如此——因此</a>利用了这种想法的一个版本，使查询尽可能地人性化[ <strong class="lo ir">为倾向于历史的读者注意</strong>:定义正式语言的语义，然后提供英文到正式语言的翻译可以追溯到开创性的<a class="ae ne" href="http://www.cs.rhul.ac.uk/~zhaohui/montague73.pdf" rel="noopener ugc nofollow" target="_blank"> PTQ</a></li></ul><p id="3f14" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">这些可伸缩性问题和其他技术原因(例如一阶逻辑中的<a class="ae ne" href="https://math.stackexchange.com/questions/2680534/first-order-logic-clauses-decidability" rel="noopener ugc nofollow" target="_blank">完全通用推理的限制</a>)在历史上<a class="ae ne" rel="noopener" target="_blank" href="/in-praise-of-artificial-stupidity-60c2cdb686cd"/>阻止了计算语义像其他 NLP 工具一样在行业中普及。最近，一些<a class="ae ne" href="http://csli-lilt.stanford.edu/ojs/index.php/LiLT/article/view/6%5C" rel="noopener ugc nofollow" target="_blank">研究项目</a>致力于弥合基于向量的观点和基于集合论的观点之间的差距，试图两全其美:统计的可扩展性和灵活性，逻辑的组合性和结构。此外，来自概率编程社区的研究人员正在该框架内工作，将概率和组合性结合起来，以系统地解释语用现象(见我们自己关于主题的文章<a class="ae ne" rel="noopener" target="_blank" href="/fluid-concepts-and-creative-probabilities-785d3c81610a">这里</a>)。</p><blockquote class="od oe of"><p id="aaad" class="lm ln nd lo b lp my jr lr ls mz ju lu og na lw lx oh nb lz ma oi nc mc md ll ij bi translated">在<a class="ae ne" href="https://tooso.ai/" rel="noopener ugc nofollow" target="_blank"> Tooso </a>，我们的愿景一直是弥合人类与数据之间的鸿沟。虽然我们相信没有一个单一的想法能够解决<em class="iq">的含义</em>的谜团，并且这个谜题的许多部分仍然缺失，但我们确实认为，在人类历史上，没有比现在更好的时机来用全新的理论眼光和当今可用的令人难以置信的工程工具来应对这一挑战了。</p><p id="686b" class="lm ln nd lo b lp my jr lr ls mz ju lu og na lw lx oh nb lz ma oi nc mc md ll ij bi translated">在我们完全解决语言之谜之前，有许多用例需要* <em class="iq">一些* </em>语言理解，这可以释放巨大的技术和商业价值。</p></blockquote><p id="f0fa" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">作为最后一个额外的考虑，从科学到“更大的图景”，让我们不要忘记，在这篇文章之后，我们现在应该准备好最终知道“生命”的意义是什么(轶事显然是由著名的语义学家<a class="ae ne" href="https://en.wikipedia.org/wiki/Barbara_Partee" rel="noopener ugc nofollow" target="_blank">芭芭拉·帕蒂</a>引起的):我们必须将它翻译成一个常数符号<em class="nd">生命</em>，并使用一个运算符如<code class="fe ox oy oz op b">|</code>来表明我们正在讨论它在我们的模型中的扩展。所以，说到底，“命”的意义就是<code class="fe ox oy oz op b">|life</code>。也许这就是那个疯狂的奥地利人所说的:</p><blockquote class="od oe of"><p id="a1ef" class="lm ln nd lo b lp my jr lr ls mz ju lu og na lw lx oh nb lz ma oi nc mc md ll ij bi translated">即使所有可能的科学问题都被回答了，生命的问题仍然完全没有被触及。</p></blockquote><p id="70e6" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">但这显然是一个完全不同的故事。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="24cb" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">再见，太空牛仔</h2><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/59acfbe6cfd588c697bf40f35bc48ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:132/format:webp/1*ZAf6t0J2P2b3RtzoSAlK_A.png"/></div></figure><p id="bf77" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">这就是全部，伙计们:有数学倾向的读者有兴趣接受语义的更正式的处理，一般来说，形式逻辑的主题，被邀请从<a class="ae ne" href="https://www.amazon.com/Language-Proof-Logic-David-Barker-Plummer/dp/1575866323" rel="noopener ugc nofollow" target="_blank">语言、证明和逻辑</a>开始，继续<a class="ae ne" href="https://www.amazon.com/Computability-Logic-George-S-Boolos/dp/0521701465" rel="noopener ugc nofollow" target="_blank">可计算性和逻辑</a>，最后用<a class="ae ne" href="https://www.springer.com/us/book/9780792353348" rel="noopener ugc nofollow" target="_blank">一阶模态逻辑</a>探索可能世界的迷人概念。</p><p id="63f9" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">如有要求、疑问、反馈，请联系<a class="ae ne" href="mailto:jacopo.tagliabue@tooso.ai" rel="noopener ugc nofollow" target="_blank">jacopo . taglia bue @ tooso . ai</a>。</p><p id="1465" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">别忘了在<a class="ae ne" href="https://medium.com/tooso" rel="noopener">媒体</a>、<a class="ae ne" href="https://www.linkedin.com/company/tooso" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>、<a class="ae ne" href="https://twitter.com/tooso_ai" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae ne" href="https://www.instagram.com/tooso_ai/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上获取<a class="ae ne" href="http://tooso.ai/" rel="noopener ugc nofollow" target="_blank"> Tooso </a>的最新消息。</p><h2 id="c5d0" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">感谢</h2><p id="c823" class="pw-post-body-paragraph lm ln iq lo b lp pf jr lr ls pg ju lu ko ph lw lx ks pi lz ma kw pj mc md ll ij bi translated">感谢 Tooso 团队的所有成员对本文前一稿的建议和反馈。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="aa82" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Python 3 时代的塔尔斯基</h2><blockquote class="lb"><p id="aa04" class="lc ld iq bd le lf lg lh li lj lk ll dk translated">"真理只能在一个地方找到:代码."<br/> ― <strong class="ak">马丁公司</strong></p></blockquote><p id="c969" class="pw-post-body-paragraph lm ln iq lo b lp lq jr lr ls lt ju lu ko lv lw lx ks ly lz ma kw mb mc md ll ij bi translated">配套的<a class="ae ne" href="https://github.com/jacopotagliabue/tarski-2.0" rel="noopener ugc nofollow" target="_blank"> Github repo </a>包含 Python 3.6 中的一个工作“模型检查器”，即一个 Python 项目，给定一个公式和一些域，自动评估公式是否满足。</p><p id="7f1e" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">虽然代码被大量注释并且非常容易理解，但是我们在这里提供了对其主要部分的非常高级的描述；虽然我们不知道其他 Python 检查器也是以类似的精神构建的，但代码是作为本博客和相关项目的教育工具而不是作为高性能软件编写的(有趣的是，Bos 和 Blackburn 还在他们的书中<a class="ae ne" href="https://www.press.uchicago.edu/ucp/books/book/distributed/R/bo3685980.html" rel="noopener ugc nofollow" target="_blank">哀叹</a>实现“普通的”一阶检查器非常困难)。项目结构如下:</p><pre class="mn mo mp mq gt oo op oq or aw os bi"><span id="76a5" class="kf kg iq op b gy ot ou l ov ow">project_folder</span><span id="3762" class="kf kg iq op b gy pd ou l ov ow">   notebooks<br/>      tarski-2-pandas.ipynb </span><span id="2a7e" class="kf kg iq op b gy pd ou l ov ow">   fol_main.py<br/>   fol_grammar.py<br/>   fol_semantics.py<br/>   fol_models.py</span><span id="e539" class="kf kg iq op b gy pd ou l ov ow">   test_fol_semantics.py</span><span id="5a1f" class="kf kg iq op b gy pd ou l ov ow">   README.md<br/>   requirements.txt</span></pre><p id="670a" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">核心文件如下:</p><ul class=""><li id="9331" class="nf ng iq lo b lp my ls mz ko nh ks ni kw nj ll nk nl nm nn bi translated">展示了如何从静态集合中加载一个模型，实例化语法和语义的类，以及评估一个表达式。</li><li id="4d79" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated"><code class="fe ox oy oz op b">fol_grammar.py</code>是处理检查器语法部分的类——它在内部使用<a class="ae ne" href="https://github.com/lark-parser/lark" rel="noopener ugc nofollow" target="_blank"> lark </a>来解析类似 FOL 的表达式，它有一个内置的递归函数来检索公式中的自由变量。如果你想扩展/改变词汇或语法约定，这就是你应该开始的地方。</li><li id="7c99" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated"><code class="fe ox oy oz op b">fol_semantics.py</code>是处理语义的类——该类公开了<em class="nd">check _ formula _ satisfaction _ in _ model</em>函数，该函数采用一个表达式和一个模型，将公式计算为模型中的<code class="fe ox oy oz op b">True/False</code>。这个类在一个带有<em class="nd">部分</em>赋值的模型中定义满意度，比经典的<a class="ae ne" href="https://en.wikipedia.org/wiki/Alfred_Tarski" rel="noopener ugc nofollow" target="_blank">塔斯基</a>的工作更多地遵循<a class="ae ne" href="https://www.amazon.com/Language-Proof-Logic-David-Barker-Plummer/dp/1575866323" rel="noopener ugc nofollow" target="_blank">这个</a>。如果您想添加语义规则或修改满意度以涵盖额外的数据结构(比方说，数据库而不是 Python 中指定的模型)，这是您应该考虑的地方。</li><li id="b643" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated"><code class="fe ox oy oz op b">fol_models.py</code>包含了一些基本的模型，可以让你开始探索检查器的行为(一些模型对于测试也非常有用)。如果您有自己的目标域要建模，您可以按照提供的示例在这里添加一个 Python 对象，然后使用<code class="fe ox oy oz op b">fol_main.py</code>调用该模型上的检查器。</li><li id="678d" class="nf ng iq lo b lp no ls np ko nq ks nr kw ns ll nk nl nm nn bi translated"><code class="fe ox oy oz op b">test_fol_semantics.py</code>包含一系列测试(我们通常使用<a class="ae ne" href="https://docs.pytest.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> pytest </a>进行 Python 测试)来确保检查器在不同条件下的行为符合预期。</li></ul><p id="e722" class="pw-post-body-paragraph lm ln iq lo b lp my jr lr ls mz ju lu ko na lw lx ks nb lz ma kw nc mc md ll ij bi translated">编码快乐！</p></div></div>    
</body>
</html>