<html>
<head>
<title>Make your Pandas apply functions faster using Parallel Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用并行处理让你的熊猫更快地应用函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/make-your-own-super-pandas-using-multiproc-1c04f41944a1?source=collection_archive---------1-----------------------#2019-05-02">https://towardsdatascience.com/make-your-own-super-pandas-using-multiproc-1c04f41944a1?source=collection_archive---------1-----------------------#2019-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b830" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/python-shorts" rel="noopener" target="_blank">蟒蛇短裤</a></h2><div class=""/><div class=""><h2 id="ebe1" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">超级熊猫侠</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/5003fa25627669e5999d2c1bdf870e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6hslZcybfS5WfkR645FjQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Super Panda</figcaption></figure><p id="89ba" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="md">并行化牛逼。</em>T9】</strong></p><p id="aa3f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们数据科学家已经有了四核、八核、睿频的笔记本电脑。我们使用具有更多内核和计算能力的服务器。</p><p id="5311" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是我们真的利用了我们手头的原始力量吗？T13】</p><p id="9e42" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">相反，我们等待耗时的过程结束。有时是几个小时，当紧急的交付品就在手边的时候。</p><p id="a630" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们能做得更好吗？我们能变得更好吗？</p><p id="4809" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这个名为<strong class="lj jd">'</strong><a class="ae me" href="https://towardsdatascience.com/tagged/python-shorts" rel="noopener" target="_blank"><strong class="lj jd">Python Shorts</strong></a><strong class="lj jd">，‘</strong>的系列帖子中，我将解释由<a class="ae me" href="https://amzn.to/2XPSiiG" rel="noopener ugc nofollow" target="_blank"> Python </a>提供的一些简单构造，一些基本的技巧和我在数据科学工作中经常遇到的一些用例。</p><p id="9326" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="md">这篇帖子讲的是利用我们手头的计算能力，把它应用到我们最常用的数据结构上。</em> </strong></p><h1 id="d882" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">问题陈述</h1><p id="68fe" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq mz ls lt lu na lw lx ly nb ma mb mc im bi translated">我们有一个巨大的熊猫数据框，我们想对它应用一个复杂的函数，这需要很多时间。</p><p id="ab5d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这篇文章中，我将使用 Kaggle 上 Quora 非真诚问题分类的数据，我们需要创建一些数字特征，如长度、标点符号的数量等。这就去。</p><p id="36de" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">比赛是基于内核的比赛，代码需要在 2 小时内运行。所以每一分钟都是至关重要的，有太多的时间花在预处理上。</p><p id="76ae" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以使用并行化来提高代码的性能吗？ </p><p id="56a6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">是的，我们可以。</p><h1 id="9219" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">仅使用单个函数的并行化</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nc"><img src="../Images/137b6005c37e157b88abf0729bb3313b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ltZjDNBvTB54UM6a"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Can we make all our cores run?</figcaption></figure><p id="07ae" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我首先从定义我想用来创建我们的特征的函数开始。是我们希望应用于数据的玩具函数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6028" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以使用下面的函数来使用并行应用。</p><pre class="ks kt ku kv gt nj ng nk nl aw nm bi"><span id="3ef4" class="nn mg it ng b gy no np l nq nr">def parallelize_dataframe(df, func, n_cores=4):<br/>    df_split = np.array_split(df, n_cores)<br/>    pool = Pool(n_cores)<br/>    df = pd.concat(pool.map(func, df_split))<br/>    pool.close()<br/>    pool.join()<br/>    return df</span></pre><p id="a31d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它是做什么的？它将数据帧分成<code class="fe nd ne nf ng b">n_cores</code>个部分，并产生<code class="fe nd ne nf ng b">n_cores</code>进程，这些进程将函数应用于所有部分。</p><p id="f4c0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦它将函数应用于所有分割的数据帧，它就将分割的数据帧连接起来，并将完整的数据帧返回给我们。</p><h2 id="3eac" class="nn mg it bd mh ns nt dn ml nu nv dp mp lq nw nx mr lu ny nz mt ly oa ob mv iz bi translated">我们如何使用它？</h2><p id="195d" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq mz ls lt lu na lw lx ly nb ma mb mc im bi translated">它使用起来非常简单。</p><pre class="ks kt ku kv gt nj ng nk nl aw nm bi"><span id="b498" class="nn mg it ng b gy no np l nq nr">train = parallelize_dataframe(train_df, add_features)</span></pre><h2 id="bf1a" class="nn mg it bd mh ns nt dn ml nu nv dp mp lq nw nx mr lu ny nz mt ly oa ob mv iz bi translated">这有用吗？</h2><p id="6508" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq mz ls lt lu na lw lx ly nb ma mb mc im bi translated">为了检查这个并行化函数的性能，我在我的 Jupyter 笔记本的 Kaggle 内核中对这个函数运行了<code class="fe nd ne nf ng b">%%timeit</code> magic。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/cef78ed1837108b65ffa5004653c8ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKR-8UbD5UabvvS9OZLWig.png"/></div></div></figure><p id="a342" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">与只使用现有功能相比:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi od"><img src="../Images/046eee319e8282071c1180976f76582e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZ7IGJdazYddXZuMI6JfFA.png"/></div></div></figure><p id="87d7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如您所见，我通过使用并行化功能获得了一些性能。它使用的是只有两个 CPU 的 kaggle 内核。</p><p id="02ab" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在实际比赛中，涉及到大量的计算，我使用的<code class="fe nd ne nf ng b">add_features</code>函数要复杂得多。这个并行化功能极大地帮助我减少了处理时间，并获得了<a class="ae me" rel="noopener" target="_blank" href="/what-my-first-silver-medal-taught-me-about-text-classification-and-kaggle-in-general-ebae0df16278">银牌</a>。</p><p id="0dd3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里是带有完整代码的<a class="ae me" href="https://www.kaggle.com/mlwhiz/parallelization-kernel" rel="noopener ugc nofollow" target="_blank">内核</a>。</p><h1 id="466d" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">结论</h1><p id="0948" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq mz ls lt lu na lw lx ly nb ma mb mc im bi translated"><strong class="lj jd">并行化不是银弹；这是铅弹。它不会解决你所有的问题，你仍然需要优化你的功能，但是它是你的武器库中的一个很好的工具。</strong></p><p id="3828" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">时间一去不复返，有时我们也缺少时间。此时，我们应该能够轻松使用并行化。</p><blockquote class="oe"><p id="d453" class="of og it bd oh oi oj ok ol om on mc dk translated">并行化不是银弹，而是铅弹</p></blockquote></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="271e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">另外，如果你想了解更多关于<a class="ae me" href="https://coursera.pxf.io/0JMOOY" rel="noopener ugc nofollow" target="_blank"> Python 3 </a>的知识，我想向密歇根大学推荐一门关于学习<a class="ae me" href="https://coursera.pxf.io/0JMOOY" rel="noopener ugc nofollow" target="_blank">中级 Python </a>的优秀课程。一定要去看看。</p><p id="29c2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">将来我也会写更多初学者友好的帖子。让我知道你对这个系列的看法。在<a class="ae me" href="https://medium.com/@rahul_agarwal" rel="noopener"> <strong class="lj jd">媒体</strong> </a>关注我或者订阅我的<a class="ae me" href="https://mlwhiz.ck.page/a9b8bda70c" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jd">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter <a class="ae me" href="https://twitter.com/MLWhiz" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系到我。</p></div></div>    
</body>
</html>