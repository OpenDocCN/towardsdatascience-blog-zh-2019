<html>
<head>
<title>How to Deploy a Machine Learning Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何部署机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-deploy-a-machine-learning-model-dc51200fe8cf?source=collection_archive---------5-----------------------#2019-08-30">https://towardsdatascience.com/how-to-deploy-a-machine-learning-model-dc51200fe8cf?source=collection_archive---------5-----------------------#2019-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e1bf" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">机器学习</h2><div class=""/><div class=""><h2 id="8050" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用 FastAPI+uvicon 创建生产就绪的 API</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/4de3a5d5b8d16b070a2e99152a261f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jfFiJr4OxVaU882JZBp1Hg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Photo by <a class="ae lh" href="https://unsplash.com/@spacex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">SpaceX</a> on <a class="ae lh" href="https://unsplash.com/search/photos/rocket?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f2fa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated">你在网上看到的任何机器学习文章都在讨论模型的复杂性以及如何正确应用它们。尽管这些文章可能很有趣也很有价值，但只有少数文章考虑了创建模型后会发生什么:</p><blockquote class="mn"><p id="fd2a" class="mo mp it bd mq mr ms mt mu mv mw md dk translated">部署 ML 模型需要哪些步骤？</p></blockquote><p id="923e" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">不幸的是，我能找到的大多数文章都讨论了如何使用 Flask 快速创建端点，但是没有意识到 Flask 本身很难用于生产。</p><p id="cc1e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从命令行运行 Flask 时，您首先看到的是以下内容:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nc"><img src="../Images/e2d75a6dcaaa13ce4bb3052e08d991c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VMiPcNG5Nfg-SNfJ2hqjbw.png"/></div></div></figure><p id="1c14" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">显然，要使它完全投入生产，还需要做更多的工作和考虑。</p><h2 id="bb12" class="nd ne it bd nf ng nh dn ni nj nk dp nl lr nm nn no lv np nq nr lz ns nt nu iz bi translated">部署模型时要考虑的事情</h2><ul class=""><li id="a61d" class="nv nw it lk b ll nx lo ny lr nz lv oa lz ob md oc od oe of bi translated">扩展您的 API</li><li id="0480" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">容器化您的 API 环境</li><li id="b1bb" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">记录您的 API</li><li id="e4f2" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">重新训练您的模型以避免模型漂移</li><li id="4fb7" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">记录您的 API 和模型</li><li id="ea73" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">云还是内部部署？</li></ul><p id="946e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将一起经历几个步骤，让您的 API 为生产做好准备，无论是在本地还是在云上，重点是文档、日志和伸缩。</p><p id="def3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将使用 FastAPI 代替 Flask。这并不是因为 Flask 有什么问题，而是我相信 FastAPI 可以让你更快地投入生产。</p><h2 id="3009" class="nd ne it bd nf ng nh dn ni nj nk dp nl lr nm nn no lv np nq nr lz ns nt nu iz bi translated">文档结构</h2><p id="4a01" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">你可以在这里从<a class="ae lh" href="https://github.com/MaartenGr/ML-API" rel="noopener ugc nofollow" target="_blank">得到所有的数据和文件。对于本指南，请确保您的文档结构如下:</a></p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="b713" class="nd ne it op b gy ot ou l ov ow">.<br/>├── <strong class="op jd">app</strong><br/>│   └── main.py<br/>│   └── sample.log<br/>│   └── <strong class="op jd">data<br/></strong>│         └── encoder.pickle<br/>│         └── features.pickle<br/>│         └── model.pickle<br/>│<br/>├── <strong class="op jd">notebooks<br/></strong>│   └── <!-- -->preprocessing.ipynb<br/>│   └── <!-- -->test_connection.ipynb<br/>│   └── data.csv<br/>│<br/>├── requirements.txt<br/>└── Dockerfile</span></pre><p id="c558" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将有助于防止错误，尤其是在创建 Docker 容器时。</p><h1 id="5518" class="ox ne it bd nf oy oz pa ni pb pc pd nl ki pe kj no kl pf km nr ko pg kp nu ph bi translated">1.准备文件</h1><p id="3f18" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">我们将要部署的模型用于预测人员流动。你可以在这里得到数据<a class="ae lh" href="https://www.kaggle.com/jacksonchou/hr-data-for-analytics" rel="noopener ugc nofollow" target="_blank">。前几行如下所示:</a></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/2f1bae843b77603826e10636f4abf2ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50aJmxiCr7VsghdfqKNdkg.png"/></div></div></figure><p id="cdc7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们首先加载数据并保存我们希望在模型中使用的特征的名称。这有助于跟踪列的顺序。当您指的是薪水时，您不希望意外地输入年龄值。</p><p id="247a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，由于列<em class="pj"> Sales </em>和<em class="pj"> Salary </em>是分类的，我们将应用并保存一个 hot 编码实例。一键编码将一个列转换为具有 0 或 1 的<em class="pj"> n </em>列，其中<em class="pj"> n </em>等于唯一类别的数量。我这样做是因为它在部署您的模型时显示了一些额外的复杂性。</p><p id="d800" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我使用现成的 LightGBM 分类器来预测营业额。该模型被保存，以便可以在我们的 API 中使用。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk pl l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Preprocessing the data and creating the model</figcaption></figure><p id="6b18" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们准备好数据并保存了所有必要的文件之后，是时候开始创建 API 来服务我们的模型了。</p><p id="7f00" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意</strong>:保存模型有几种方法，每种方法都有自己的优缺点。除了酸洗，你还可以使用<a class="ae lh" href="https://scikit-learn.org/stable/modules/model_persistence.html" rel="noopener ugc nofollow" target="_blank"> Joblib </a>或者使用<a class="ae lh" href="https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.Booster.html#lightgbm.Booster.save_model" rel="noopener ugc nofollow" target="_blank"> LightGBM 的内部程序</a>。</p><h1 id="adf6" class="ox ne it bd nf oy oz pa ni pb pc pd nl ki pe kj no kl pf km nr ko pg kp nu ph bi translated">2.生产就绪 API</h1><p id="a233" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">生产通常意味着终端用户可以访问的 API 形式的端点。对于 python 来说，有很多选择，比如<a class="ae lh" href="https://github.com/pallets/flask" rel="noopener ugc nofollow" target="_blank">烧瓶</a>、<a class="ae lh" href="https://github.com/falconry/falcon" rel="noopener ugc nofollow" target="_blank">猎鹰</a>、<a class="ae lh" href="https://github.com/encode/starlette" rel="noopener ugc nofollow" target="_blank">小星星</a>、<a class="ae lh" href="https://github.com/huge-success/sanic" rel="noopener ugc nofollow" target="_blank"> Sanic </a>、<a class="ae lh" href="https://github.com/tiangolo/fastapi" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>、<a class="ae lh" href="https://github.com/tornadoweb/tornado" rel="noopener ugc nofollow" target="_blank">龙卷风</a>等。</p><h2 id="4eb5" class="nd ne it bd nf ng nh dn ni nj nk dp nl lr nm nn no lv np nq nr lz ns nt nu iz bi translated">FastApi</h2><p id="e6d9" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">出于三个原因，我们将在本文中使用 FastApi:</p><ul class=""><li id="5da7" class="nv nw it lk b ll lm lo lp lr pm lv pn lz po md oc od oe of bi translated">像 Flask 一样，您可以用<strong class="lk jd">最小代码</strong>设置一个端点</li><li id="737b" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">它是<strong class="lk jd">难以置信的快</strong>，它的速度与 NodeJS 和 Go 不相上下</li><li id="6c1d" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">它<strong class="lk jd">自动创建</strong>open API(Swagger)和 ReDoc <strong class="lk jd">文档</strong></li></ul><p id="5f73" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，这是个人经验，幸运的是，您可以很容易地将 FastApi 换成其他东西。</p><h2 id="f9cf" class="nd ne it bd nf ng nh dn ni nj nk dp nl lr nm nn no lv np nq nr lz ns nt nu iz bi translated">紫玉米</h2><p id="2f66" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">我们用 Uvicorn 来服务我们的 FastAPI 服务器。与更传统的 WSGI 服务器相比，Uvicorn 是允许异步进程的 ASGI 服务器。这将加快应用程序的速度，并使您更接近生产性能。</p><h2 id="1331" class="nd ne it bd nf ng nh dn ni nj nk dp nl lr nm nn no lv np nq nr lz ns nt nu iz bi translated"><strong class="ak">美国石油学会</strong></h2><p id="209e" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">首先，我们需要安装 FastAPI 和 Uvicorn:</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="3455" class="nd ne it op b gy ot ou l ov ow">pip install fastapi<br/>pip install uvicorn</span></pre><p id="8808" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">安装完必要的包后，我们可以开始创建主文件。在这个文件中，我们确保加载了之前保存的所有必要文件。</p><p id="a5d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们创建一个名为<code class="fe pp pq pr op b">Data</code>的类，它定义了模型中使用的所有变量。这有助于跟踪我们使用的变量，而且还基于我们创建的类创建文档。</p><p id="718f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们创建了预测方法。在这种情况下，数据被提取出来并按正确的顺序排列。像我们之前所做的那样，应用了一键编码。然后，预测以 0 或 1 的形式返回。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk pl l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">main.py</figcaption></figure><p id="f37c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们已经安排好了一切，我们可以从您的控制台使用以下命令加载服务器:</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="28db" class="nd ne it op b gy ot ou l ov ow">uvicorn main:app</span></pre><p id="78ba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pp pq pr op b">main</code>是指文件的名称(main.py ),而<code class="fe pp pq pr op b">app</code>是指 main.py 中 FastApi 实例的名称。如果一切正常，您可以看到服务器运行在<a class="ae lh" href="http://127.0.0.1:8000" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:8000 </a>。</p><p id="45f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要测试它是否返回预测，您可以运行以下代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="4f1b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还可以用<a class="ae lh" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>测试 API，这是一个很棒的 API 开发工具。</p><p id="1acc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然从技术上讲，您的 API 现在可以用于生产，但是包含文档、记录 API 中发生的事情以及将您的解决方案容器化将会很有帮助。</p><h1 id="8ac1" class="ox ne it bd nf oy oz pa ni pb pc pd nl ki pe kj no kl pf km nr ko pg kp nu ph bi translated">3.证明文件</h1><p id="9989" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">很有可能您不是在现有服务中实现 API 的人。如果您记录了端点，以便可以毫无困难地使用它，那就更好了。幸运的是，FastApi 会基于我们之前创建的<code class="fe pp pq pr op b">Data</code>类自动创建文档。</p><p id="b33d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">FastApi 有自动文档内置的方法:OpenApi (Swagger)和 ReDoc。</p><h2 id="7a2b" class="nd ne it bd nf ng nh dn ni nj nk dp nl lr nm nn no lv np nq nr lz ns nt nu iz bi translated">OpenApi</h2><p id="7a80" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">启动 FastAPI 服务器后，您可以访问<a class="ae lh" href="http://127.0.0.1:8000/docs" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/docs</a>查看自动生成的服务器文档。你甚至可以按“试试看”来看看服务器是否如预期的那样工作。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ps"><img src="../Images/31c159047993ae55b0146a62cfe03732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eE_gz9YAVlMWkfX5MKTt6Q.png"/></div></div></figure><h2 id="d265" class="nd ne it bd nf ng nh dn ni nj nk dp nl lr nm nn no lv np nq nr lz ns nt nu iz bi translated">雷多克</h2><p id="2585" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">像 OpenAPI/Swagger 一样，ReDoc 生成参考文档。它通过允许您创建一个高度可定制的基于 react 的模板来扩展它们。FastAPI 在<a class="ae lh" href="http://127.0.0.1:8000/redocs" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/redoc</a>自动创建文档。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/79ed316e39ab7068860e1f2efd0fa18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TxP1FiJ1WdQzzuvWNzy4Bw.png"/></div></div></figure><p id="8a7e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注</strong>:如果你想看 ReDoc 的大范围现场版，可以去看看<a class="ae lh" href="http://redocly.github.io/redoc/" rel="noopener ugc nofollow" target="_blank">http://redocly.github.io/redoc/</a>。</p><h1 id="2f0c" class="ox ne it bd nf oy oz pa ni pb pc pd nl ki pe kj no kl pf km nr ko pg kp nu ph bi translated">4.记录</h1><p id="46c4" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">我见过许多人使用<code class="fe pp pq pr op b">print()</code>语句来跟踪他们代码内部发生的事情。这对小型应用程序来说没问题，但是当您在<em class="pj">开发</em>、<em class="pj">测试</em>、<em class="pj">验收</em>、<strong class="lk jd">、</strong>和<em class="pj">生产</em> (DTAP)之间切换时，您可能不想显示相同的消息。</p><p id="576e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是<strong class="lk jd">日志</strong>的用武之地。它允许您为应用程序设置特定的日志记录级别，并且只在超出该级别时显示消息。</p><p id="ff13" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的 API 将受益于<strong class="lk jd">日志</strong>，主要有两个原因:</p><ul class=""><li id="0cd4" class="nv nw it lk b ll lm lo lp lr pm lv pn lz po md oc od oe of bi translated">我们可以跟踪 API 是否还在工作，以及它遇到了哪些问题</li><li id="07ad" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">我们可以跟踪模型的输入并检查其性能</li></ul><p id="103a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们保留所有输入数据以便进一步分析，这将非常有趣。这将为我们提供以前从未见过的数据信息，并可能改进模型。</p><h2 id="1656" class="nd ne it bd nf ng nh dn ni nj nk dp nl lr nm nn no lv np nq nr lz ns nt nu iz bi translated">日志记录级别</h2><p id="292f" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">有些错误可能不如其他错误有趣。在生产中，您可能希望显示致命错误，而不是应用程序的进度信息。当您调试应用程序时，这可能会有所不同。</p><p id="06d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了解决这个问题，我们可以使用日志记录的<strong class="lk jd">级</strong>:</p><ul class=""><li id="cd0f" class="nv nw it lk b ll lm lo lp lr pm lv pn lz po md oc od oe of bi translated"><code class="fe pp pq pr op b"><strong class="lk jd">DEBUG</strong></code> —调试应用程序时有用的信息。值= 10</li><li id="6151" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><code class="fe pp pq pr op b"><strong class="lk jd">INFO</strong></code> —申请进度信息。值= 20</li><li id="86cb" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><code class="fe pp pq pr op b"><strong class="lk jd">WARNING</strong></code> —关于潜在有害情况的信息。值= 30</li><li id="eebe" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><code class="fe pp pq pr op b"><strong class="lk jd">ERROR</strong></code> —关于非致命错误的信息。值= 40</li><li id="8358" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><code class="fe pp pq pr op b"><strong class="lk jd">CRITICAL</strong></code> —关于严重和致命错误的信息。值= 50</li></ul><p id="972c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们将记录器设置在<code class="fe pp pq pr op b"><strong class="lk jd">WARNING</strong></code>级别，那么将只显示<code class="fe pp pq pr op b"><strong class="lk jd">WARNING</strong></code>、<code class="fe pp pq pr op b"><strong class="lk jd">ERROR</strong></code>和<code class="fe pp pq pr op b"><strong class="lk jd">CRITICAL</strong></code>。</p><h2 id="aa5a" class="nd ne it bd nf ng nh dn ni nj nk dp nl lr nm nn no lv np nq nr lz ns nt nu iz bi translated">本地记录器</h2><p id="d241" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">为了在本地使用记录器，我们初始化记录器并设置其最低级别:</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="b509" class="nd ne it op b gy ot ou l ov ow">import logging</span><span id="9115" class="nd ne it op b gy pu ou l ov ow">app = FastAPI()</span><span id="59fe" class="nd ne it op b gy pu ou l ov ow"># Initialize logging<br/>my_logger = logging.getLogger()<br/>my_logger.setLevel(logging.DEBUG)</span></pre><p id="297d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最低级别现在设置在<code class="fe pp pq pr op b"><strong class="lk jd">DEBUG</strong></code>，这意味着基本上所有级别的记录都会显示。当你将你的模型投入生产时，我建议你将它设置为<code class="fe pp pq pr op b"><strong class="lk jd">WARNING</strong></code>。</p><p id="0904" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要使用记录器，只需调用它并指定日志记录的级别。该消息将被打印到控制台:</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="40d8" class="nd ne it op b gy ot ou l ov ow">my_logger.error("Something went wrong!")</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/74c0bd620caebb67ba77827350f750b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*SuD0b2E9vFZF3EEjxM3hOw.png"/></div></figure><p id="8030" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，你可能想要<strong class="lk jd">保存</strong>日志到一个文件。为此，只需用此语句代替上面的<code class="fe pp pq pr op b">setLevel</code>:</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="d645" class="nd ne it op b gy ot ou l ov ow">logging.basicConfig(level=logging.INFO, file='sample.log')</span></pre><h1 id="ca72" class="ox ne it bd nf oy oz pa ni pb pc pd nl ki pe kj no kl pf km nr ko pg kp nu ph bi translated">5.使用 Docker</h1><p id="0c30" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">既然我们已经有了要部署的 API，我们可能希望使用 Docker 将应用程序容器化。Docker 将您的应用程序及其所有依赖项打包，以确保它在任何环境下都能无缝工作。这使得跨环境部署应用程序变得更加容易，而不需要太多额外的集成步骤。</p><p id="0347" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先确保你已经安装了<a class="ae lh" href="https://docs.docker.com/docker-for-windows/install/" rel="noopener ugc nofollow" target="_blank"> Docker </a>。因为我们希望有一个跨环境的稳定的应用程序，所以为应用程序指定一个<code class="fe pp pq pr op b">requirements.txt</code> <strong class="lk jd"> </strong>是很重要的。</p><p id="3131" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下一步是创建 Dockerfile 本身，它是运行我们的 API 的一个包含版本所需要的。幸运的是，FastAPI 的开发人员已经创建了 python 映像，允许在适当的环境中运行 FastAPI:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk pl l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk">Dockerfile</figcaption></figure><p id="b988" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将上面的代码保存在 docker 文件中，导航到该文件夹并运行以下命令:</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="d11d" class="nd ne it op b gy ot ou l ov ow">docker build -t myimage ./<br/>docker run -d --name mycontainer -p 80:80 myimage</span></pre><p id="edcc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将构建并运行我们在 Dockerfile 文件中指定的映像。</p><p id="0765" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您的 API 现在已经准备好了，可以从<a class="ae lh" href="http://127.0.0.1/docs" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1/docs </a>访问。</p><h1 id="569c" class="ox ne it bd nf oy oz pa ni pb pc pd nl ki pe kj no kl pf km nr ko pg kp nu ph bi translated">结论</h1><p id="6bab" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">在这个(有点)全面的指南中，我们已经经历了为您的模型创建 API 和将应用程序容器化的 5 个步骤。现在，您可以选择在本地托管它，或者通过云解决方案(如 AWS 或 Azure)部署 Docker。</p><p id="f9c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，我试图尽可能全面地阐述这一点，同时包括我认为重要的主题。但是，一些更高级的主题被排除在外，例如:</p><ul class=""><li id="f0d9" class="nv nw it lk b ll lm lo lp lr pm lv pn lz po md oc od oe of bi translated">处理概念漂移</li><li id="da8e" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">保护您的 API</li><li id="d36b" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">配置 Gunicorn 服务器</li><li id="2d33" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">为不同阶段创建单独的 docker 文件(DTAP)</li><li id="6acf" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">使用 CI/CD 自动重新训练您的模型</li><li id="125b" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">使用 Kubeflow 和 Kubernetes 简化生产</li><li id="b360" class="nv nw it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">等等。</li></ul><p id="602b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有的<strong class="lk jd">代码</strong>都可以在这里找到:</p><div class="pw px gp gr py pz"><a href="https://github.com/MaartenGr/ML-API" rel="noopener  ugc nofollow" target="_blank"><div class="qa ab fo"><div class="qb ab qc cl cj qd"><h2 class="bd jd gy z fp qe fr fs qf fu fw jc bi translated">马尔滕格尔/毫升-API</h2><div class="qg l"><h3 class="bd b gy z fp qe fr fs qf fu fw dk translated">关于创建一个生产就绪的 API 来为您的 ML 模型服务的指南。</h3></div><div class="qh l"><p class="bd b dl z fp qe fr fs qf fu fw dk translated">github.com</p></div></div><div class="qi l"><div class="qj l qk ql qm qi qn lb pz"/></div></div></a></div></div><div class="ab cl qo qp hx qq" role="separator"><span class="qr bw bk qs qt qu"/><span class="qr bw bk qs qt qu"/><span class="qr bw bk qs qt"/></div><div class="im in io ip iq"><h1 id="8c5e" class="ox ne it bd nf oy qv pa ni pb qw pd nl ki qx kj no kl qy km nr ko qz kp nu ph bi translated">感谢您的阅读！</h1><p id="fedd" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">如果你像我一样，对人工智能、数据科学或心理学充满热情，请随时在<a class="ae lh" href="https://www.linkedin.com/in/mgrootendorst/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上添加我，或者在<a class="ae lh" href="https://twitter.com/MaartenGr" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p></div></div>    
</body>
</html>