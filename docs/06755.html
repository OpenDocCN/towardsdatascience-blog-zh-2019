<html>
<head>
<title>Things to know before using Julia for Machine-Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Julia 进行机器学习之前需要知道的事情</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/things-to-know-before-using-julia-for-machine-learning-487744c0b9b2?source=collection_archive---------13-----------------------#2019-09-26">https://towardsdatascience.com/things-to-know-before-using-julia-for-machine-learning-487744c0b9b2?source=collection_archive---------13-----------------------#2019-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/51507b008e56191b3e3a4c7ac88bd261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*fep4idD8f924P1D6rlL1uw.jpeg"/></div></figure><p id="99c4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Julia 是一种高级动态编程语言，它本身有一些有趣的特点和特性，这使它成为一种真正有趣且非常独特的语言，值得学习和利用。作为一名数据科学家，没有什么比学习一种新的编程语言来编写人工智能更令人兴奋的了。但是在 Julia 中有一些重要的事情需要注意，有些事情你应该在尝试使用它之前就知道。</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="0a48" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">让这句格言安息吧。</h1><blockquote class="ma mb mc"><p id="39bb" class="jx jy md jz b ka kb kc kd ke kf kg kh me kj kk kl mf kn ko kp mg kr ks kt ku im bi translated">"像 Python 一样走路，像 C 一样奔跑"</p></blockquote><p id="1e06" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我认为关于 Julia 的许多误导性的事情之一是一个源于语言的想法的术语，并且不一定是没有根据的。然而，我相信这个术语给这门语言的新来者提供了很多不准确之处，因为 Julia 的经常用户会说这绝对是对 Julia 的不准确描述。朱丽亚确实是<em class="md">一个特立独行的人。不仅仅是因为它不同的书写语言，还因为它有许多有趣的，有时甚至是令人震惊的怪癖。</em></p><p id="75d3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，Julia 的语法有点类似于 Python，但这种相似性可以在大多数编程语言中找到，尤其是统计语言。如果我，作为一个相当有经验的程序员，必须将语法与任何特定的语言进行比较，我会说微软的 Basic。没错，我们六岁时写的那种愚蠢的语言类似于麻省理工学院新发现的开源编程语言。这也没有太多的注意事项，真的就是这么简单。我对此最大的支持因素可能是 Julia 中函数和方法的实现方式。不相信我？看一看一个小小的对比:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/b444dfc26323e518beeb29b60cb2837e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*R3_kuNJKPZcJVmHG45_c9A.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">A Function from Microsoft Basic</figcaption></figure><p id="75a3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是用 Julia 写的同一个函数。(注意我忘了退货)</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/ee68f8ef93272765094c0b58f1a7d991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-11E4z3p2URrhPAe6npe3g.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">A Function from Julia</figcaption></figure></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="0963" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">不是面向对象的？</h1><p id="d123" class="pw-post-body-paragraph jx jy it jz b ka mv kc kd ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku im bi translated">没错，Julia(技术上)不是面向对象语言。对我来说，这是茱莉亚最大的怪癖，也可能是学习茱莉亚最大的学习曲线。所有的方法都包含在 Julia 库或模块中，<strong class="jz iu">不是构造函数。</strong></p><p id="348b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">比如像 model.fit()函数这样的东西，在 Julia 里是不可以存在的。相反，通常模型有一个 fit 方法，该方法采用一个构造的数据类型，该数据类型通常包含更多的数据。因为我为 Julia 写了一个机器学习和统计模块，你可以看看这里的<a class="ae na" href="https://github.com/emmettgb/Lathe.jl" rel="noopener ugc nofollow" target="_blank"><strong class="jz iu"/>，</a>我将使用它的源代码来解释这在实践中是什么样子，以及到底发生了什么。这里是一个样本<a class="ae na" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/South%20Carolina%20College%20Staff%20Lathe%20Baseline%20Sample.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="jz iu">笔记本</strong> </a>它概述了使用测试，火车分裂，并拟合一个模型<a class="ae na" href="https://github.com/emmettgb/Lathe.jl" rel="noopener ugc nofollow" target="_blank"> <strong class="jz iu">使用车床在朱莉娅</strong> </a> <strong class="jz iu">。</strong></p><pre class="mi mj mk ml gt nb nc nd ne aw nf bi"><span id="564c" class="ng ld it nc b gy nh ni l nj nk">mutable struct meanBaseline<br/>    y :: AbstractArray<br/>end</span></pre><p id="f430" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这些行是模型的构造函数，只需调用一个与之相等的变量，</p><pre class="mi mj mk ml gt nb nc nd ne aw nf bi"><span id="6869" class="ng ld it nc b gy nh ni l nj nk">y = 1,5,3,6,8<br/>model = models.meanBaseline(y)</span></pre><p id="d09e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个模型中没有 X 的原因是因为它只是一个均值基线模型，它将为我们提供连续特征的基线精度，其他模型完全相同，只是有一个 X。</p><p id="f24c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，通常在面向对象的语言中，如<strong class="jz iu"> <em class="md"> Python、</em> </strong>在拟合我们的模型后，我们会使用 model.fit(x，y)方法，但是因为 Julia 中的构造函数不包含方法，所以我们必须在模块的根处使用单独的方法来拟合我们的模型。为此，我使用条件来确定输入模型的()类型。</p><pre class="mi mj mk ml gt nb nc nd ne aw nf bi"><span id="9a80" class="ng ld it nc b gy nh ni l nj nk">function predict(m,x)<br/>if typeof(m) == TurtleShell<br/>        y_pred = pred_turtleshell(m,x)<br/>    end    <br/>if typeof(m) == majBaseline<br/>        y_pred = pred_catbaseline(m,x)<br/>    end    <br/>if typeof(m) == LinearRegression<br/>        y_pred = pred_linearregression(m,x)<br/>    end    <br/>if typeof(m) == meanBaseline<br/>        y_pred = pred_meanbaseline(m,x)<br/>    end    <br/>return(y_pred)<br/>end</span></pre><p id="6865" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，预测模型看起来像这样:</p><pre class="mi mj mk ml gt nb nc nd ne aw nf bi"><span id="c6b0" class="ng ld it nc b gy nh ni l nj nk">models.fit(model,xtrain)</span></pre><p id="e91f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就产生了拟合模型对 x 的预测值。</p><p id="b4aa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所以在我看来，对于数据科学来说，这是一个有趣的命题。有时不得不为每件事调用一个方法可能有点烦人，但对我来说这是受欢迎的，因为它非常不同而且有趣。</p><p id="c4f9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对这类东西的担心只是它对一个典型的数据科学家有多大价值，特别是对于像投资组合或任何严肃的项目这样的东西。不面向对象意味着 Julia 可能需要使用<strong class="jz iu"> PyCall </strong>才能接近 Python 的通用性。即使这样，在 Julia 中创建任何类型的应用程序肯定也不是万无一失的方法。相对于 R，甚至 Scala，Python 最伟大的事情之一就是它有这么多奇妙的库可以做任何事情。你可以用<strong class="jz iu"> Django </strong>和<strong class="jz iu"> Flask </strong>开发 web 应用程序，这些应用程序与<strong class="jz iu"> SQL </strong>数据库一起工作，用多种框架为桌面计算机和移动设备开发应用程序。这变得更容易，主要是因为 Python 是面向对象的。我很想知道 Julia 是否会把它带到任何地方，或者让它保持原样。</p><p id="3153" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这些缺点可能有点关键，因为这并不是这种语言的真正目的。我喜欢把它看作是 Python 和 Spark 之间的桥梁。它在精确操作方面非常出色，像 Python 一样简单，是 Python 的机器学习基础，但具有 Spark 的大数据处理能力。在开始 Julia 数据科学之旅时，这绝对是需要注意的事情。</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="c41a" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">关闭中</h1><p id="578e" class="pw-post-body-paragraph jx jy it jz b ka mv kc kd ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku im bi translated">值得注意的是，Julia 实际上仍处于起步阶段，刚刚走出 1.0 版本。当使用 Julia 时，经常会感觉很陌生，有点过于开源，如果你明白我的意思的话。它给人一种精致、清新的感觉，但与此同时，它可能会让人觉得有点滑稽，尤其是与那些已经被搁置了 15 年以上的语言相比。</p><p id="fe33" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">由于从 1.0.4 版本开始，Julia 的功能不够全面，这无疑会给 Julia 的未来带来更多的变化。我喜欢思考 Python 和 C++的早期版本，这是一个缓慢而艰苦的过程，但是随着越来越多的人开始使用、喜爱和接受 Julia，它可能会作为数据科学的标准工具被更广泛地接受。</p><p id="cdd2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是为什么我一直在为 Julia 开发预测建模和统计库，用更强大的文档和具有简单输入和输出的简单函数使转换变得更容易。我真的很兴奋看到朱莉娅在未来几年将走向何方，谁知道呢？也许 5 年后我们的 Python 帽子就不会这么缝上了，我们会用 Julia Flux 代替 Python 张量。无论如何，对于预测建模、可视化、统计和机器学习来说，Julia 绝对是一个令人敬畏的独特工具。</p></div></div>    
</body>
</html>