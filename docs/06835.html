<html>
<head>
<title>A-Star (A*) Search Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">A 星(A*)搜索算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-star-a-search-algorithm-eb495fb156bb?source=collection_archive---------0-----------------------#2019-09-29">https://towardsdatascience.com/a-star-a-search-algorithm-eb495fb156bb?source=collection_archive---------0-----------------------#2019-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/af09ac7296b824dcfccb4d2d8f357aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*moTQGo8MxftdDnf6exPu2w.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image from Pixabay and created by Author</figcaption></figure><div class=""/><div class=""><h2 id="55b6" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">分步编码的 A-Star 搜索算法</h2></div><p id="8199" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">通过最短的路线到达目的地是我们每天都在做的事情。A-star(也称为 A*)是寻找节点或图之间最短路径的最成功的搜索算法之一。这是一种有根据的搜索算法，因为它使用关于路径成本的信息，并且还使用<a class="ae lt" href="https://en.wikipedia.org/wiki/Heuristic_(computer_science)" rel="noopener ugc nofollow" target="_blank">启发式</a>来找到解决方案。</p><p id="2165" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在本文中，我将重点介绍如何使用简单的 python 代码构建 A-star (A*)搜索算法。我发现许多文章和博客都非常关注理论，但没有太多关于这个项目的信息。我在这里尝试用易于理解的细节一步一步地展示代码。</p><p id="a2f2" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">首先，让我们先来点理论热身。</p><p id="9629" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">A*实现<strong class="kz jj"> <em class="lu">最优性</em> </strong>和<strong class="kz jj"> <em class="lu">完备性</em> </strong>，搜索算法的两个有价值的性质。</p><blockquote class="lv lw lx"><p id="eede" class="kx ky lu kz b la lb kj lc ld le km lf ly lh li lj lz ll lm ln ma lp lq lr ls im bi translated">当搜索算法具有<strong class="kz jj">最优性</strong>时，意味着<strong class="kz jj">保证</strong>找到<strong class="kz jj">最佳可能解</strong>。当一个搜索算法具有<strong class="kz jj">完备性</strong>的性质时，意味着如果一个给定问题<strong class="kz jj">的解</strong>存在，该算法<strong class="kz jj">保证</strong>找到它。</p></blockquote><p id="9bd3" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了理解 A*的工作原理，我们首先需要理解几个术语:</p><ul class=""><li id="0eb8" class="mb mc ji kz b la lb ld le lg md lk me lo mf ls mg mh mi mj bi translated"><strong class="kz jj">节点</strong>(也叫<strong class="kz jj">状态</strong> ) —所有潜在的位置或停止点都有唯一的标识</li><li id="41fa" class="mb mc ji kz b la mk ld ml lg mm lk mn lo mo ls mg mh mi mj bi translated"><strong class="kz jj">转换</strong> —在状态或节点之间移动的动作。</li><li id="1c52" class="mb mc ji kz b la mk ld ml lg mm lk mn lo mo ls mg mh mi mj bi translated"><strong class="kz jj">开始节点— </strong>从哪里开始搜索</li><li id="3681" class="mb mc ji kz b la mk ld ml lg mm lk mn lo mo ls mg mh mi mj bi translated"><strong class="kz jj">目标节点— </strong>停止搜索的目标。</li><li id="6b0f" class="mb mc ji kz b la mk ld ml lg mm lk mn lo mo ls mg mh mi mj bi translated"><strong class="kz jj">搜索空间</strong> —节点的集合，就像棋盘游戏的所有棋盘位置</li><li id="49f3" class="mb mc ji kz b la mk ld ml lg mm lk mn lo mo ls mg mh mi mj bi translated"><strong class="kz jj">成本</strong> —从一个节点到另一个节点的路径的数值(比如距离、时间或财务费用)。</li><li id="1146" class="mb mc ji kz b la mk ld ml lg mm lk mn lo mo ls mg mh mi mj bi translated"><strong class="kz jj"> g(n) </strong> —这代表从<strong class="kz jj">起始节点</strong>到任意节点<strong class="kz jj"> n </strong>的路径的<strong class="kz jj"> <em class="lu">精确成本</em> </strong></li><li id="c131" class="mb mc ji kz b la mk ld ml lg mm lk mn lo mo ls mg mh mi mj bi translated"><strong class="kz jj"> h(n) </strong> —这代表从节点<strong class="kz jj"> n </strong>到目标节点的启发式<strong class="kz jj"> <em class="lu">估计成本</em> </strong>。</li><li id="513f" class="mb mc ji kz b la mk ld ml lg mm lk mn lo mo ls mg mh mi mj bi translated"><strong class="kz jj"> f(n) </strong> —邻居节点 n 中的最低成本</li></ul><p id="dfdf" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">每次 A*进入一个节点，它计算到达所有相邻节点的成本 f(n)(n 是相邻节点)，然后进入 f(n)值最低的节点。</p><p id="3ab1" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们使用以下公式计算这些值:</p><blockquote class="mp"><p id="eaab" class="mq mr ji bd ms mt mu mv mw mx my ls dk translated">f(n) = g(n) + h(n)</p></blockquote><p id="d031" class="pw-post-body-paragraph kx ky ji kz b la mz kj lc ld na km lf lg nb li lj lk nc lm ln lo nd lq lr ls im bi translated">这里我们将解决一个迷宫问题。我们必须在迷宫中找到从起点到终点的最短路径。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/b766481f4b4ade76d4f76d27597adec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*07IW_b2j23Wua3_C-S1jWw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">1) Left: Maze problem 2) Right: Position of every node (2D NumPy array positions) of the Maze (Image by Author)</figcaption></figure><p id="aced" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">对于这个问题，如果有一个有效的步骤可用，从迷宫位置有四个移动(左，右，上，下)。在红色方块位置，不允许移动(像在开始位置，只有向下的运动是可用的，因为向上和向左的移动被墙阻挡，而对于右边是红色方块位置，因此不允许移动)。</p><p id="1d2e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我采用了来自<a class="ae lt" href="https://gist.github.com/ryancollingwood/32446307e976a11a1185a5394d6657bc" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae lt" href="https://medium.com/@nicholas.w.swift/easy-a-star-pathfinding-7e6689c7f7b2" rel="noopener">这个博客</a>的代码，这是一个极好的信息来源。如果你需要更清晰的理论和解释，请阅读帕特里克·莱斯特在 A*上的文章。</p><p id="6910" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">首先，我们将创建下面的类和帮助函数:</p><p id="fba6" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">(1) <strong class="kz jj">类“节点”</strong>可用于为每个节点创建一个对象，其信息为父节点、迷宫中的当前位置和成本值(g，h &amp; f)。</p><p id="e07f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">(2)我们需要定义一个<strong class="kz jj">路径函数</strong>，它将返回从 A*开始到结束节点的路径</p><p id="906d" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们将建立一个<strong class="kz jj">搜索函数</strong>，它将驱动代码逻辑:</p><p id="a926" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">(3.1)初始化所有变量。</p><p id="72a5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">(3.2)将起始节点添加到“尚未访问列表”定义停止条件以避免无限循环。用相对位置来定义运动。</p><p id="bffd" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">重复以下步骤，直到满足停止标准:</p><p id="6f9c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">(3.3)在“尚未访问列表”中寻找 f 成本最低的方块这个方块成为当前的方块。我们还检查是否达到了最大迭代次数</p><p id="4e3e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">(3.4)检查当前方块是否与目标方块相同(意味着我们已经找到路径)</p><p id="16e0" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">(3.5)使用当前正方形并检查与该当前正方形相邻的四个正方形，以更新子节点。如果它是不可移动的，或者如果它在“已访问列表”中，忽略它。否则，以父节点作为当前节点创建新节点，并更新节点的位置。</p><p id="9f29" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">(3.7)检查创建的所有子节点以查看</p><p id="65f5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果它不在“尚未访问列表”中，请将其添加到“尚未访问列表”使当前方块成为该方块的父方块。记录正方形的 f、g 和 h 成本。</p><p id="dd8d" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果它已经在“尚未访问的列表”中，使用 g 成本作为度量，检查一下到那个方块的路径是否更好。较低的 g 成本意味着这是一条更好的路径。如果是，将方块的父方块更改为当前方块，并重新计算方块的 g 和 f 分数。</p><p id="48c1" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">(4) <strong class="kz jj">主程序:</strong>我们将定义迷宫、起点和终点位置。然后，我们将使用搜索功能，如果路径存在，我们可以从路径功能打印路径。</p><p id="2a8f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在，我将一步一步地检查代码中的上述步骤(参考括号中的数字)。</p><p id="9b78" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">首先，我们将为一个节点创建一个类，该类将包含与该节点相关联的所有属性，如节点的父节点、节点的位置以及该节点的所有三个成本(g、h &amp; f)。我们初始化该节点，并构建一个方法来检查该节点与另一个节点是否相等。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nj"><img src="../Images/30ce6f1a6337fd9aaf6e704b5706761e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9FHotmv3iE_khMJwbbGp7g.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image by Author</figcaption></figure><p id="86d9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在我们将构建 path 函数，它将用于返回从起始节点到目标节点(结束节点)的路径。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nj"><img src="../Images/b1d0ca4f385c6a20c4100c2c57882e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRo7GzVVKfJz7ma4p5bp2Q.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image by Author</figcaption></figure><p id="81c9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在我们将定义搜索函数，它有多个步骤。第一步是初始化我们将在函数中使用的节点和列表。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nk"><img src="../Images/d929fa2875d94bc30a9e564ee44c68b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*120SkA9eQUaEfNjBYvbQIA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image by Author</figcaption></figure><p id="86d4" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">将起始节点添加到“尚未访问列表”定义停止条件以避免无限循环。根据相对位置定义移动，这将用于查找子节点和其他相对位置。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nl"><img src="../Images/c02f8c98a06c662a1dc1c2c238787a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPaRkPRu0na9J0U_3L8amQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image by Author</figcaption></figure><p id="0e9a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在我们通过比较所有 f 成本并选择成本最低的节点进行进一步扩展来使用当前节点。我们还检查是否达到了最大迭代次数，设置一个消息并停止执行(避免无限循环)</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nm"><img src="../Images/3e06da9120243e6c3f9d2a108aae6953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnIMOx31LlYdG6QXaa898Q.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image by Author</figcaption></figure><p id="e319" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">从“尚未访问列表”中删除所选节点，并将该节点添加到已访问列表中。现在我们检查是否找到了目标方块。如果我们已经定位了目标方块，那么调用 path 函数并返回。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/b8838ce71cb8fc9a65a0a6621bf0e20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIE-Q2xn5Xkdl13Fkr9hsA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image by Author</figcaption></figure><p id="ea60" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">对于选定的节点，找出所有子节点(使用移动来查找子节点)。获取所选节点的当前位置(这将成为子节点的父节点)<br/> a)检查是否存在有效位置(边界墙将使少数节点无效)<br/> b)如果任何节点位置无效(红色方块)，则忽略该位置<br/> c)添加到所选父节点的有效子节点列表中</p><p id="02ef" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在图中，我们显示黑色圆圈节点是当前节点，绿色圆圈节点是正确的子节点。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi no"><img src="../Images/804201cfad6122860799032aab26059a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7u13O7d5GeTWVf0ilALnA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image by Author</figcaption></figure><p id="13ff" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">对于所有子节点:<br/> a)如果子节点在已访问列表中，则忽略它，并尝试下一个子节点。<br/> b)计算子节点 g、h 和 f 的值。对于 h 启发式算法，此处使用欧几里德距离计算当前节点到达目标节点的成本。<br/> c)如果孩子在“尚未访问列表”中，则忽略它，将孩子移至“尚未访问列表”</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/d83a69e07daea6cc4ce4cf81c7dc4d63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L52QYTAMpoAoUc7viTo5iw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image by Author</figcaption></figure><p id="1d00" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在，最后，我们将运行迷宫的主程序，并获得路径。参考同样使用箭头显示的路径。</p><figure class="nf ng nh ni gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nk"><img src="../Images/1738568d55fcb43a1f47b4c25d0be546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H12zk1Rv9ed58Fo5sssnsg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk">Image by Author</figcaption></figure><h1 id="d9a2" class="nq nr ji bd ns nt nu nv nw nx ny nz oa ko ob kp oc kr od ks oe ku of kv og oh bi translated">结论</h1><p id="d0c8" class="pw-post-body-paragraph kx ky ji kz b la oi kj lc ld oj km lf lg ok li lj lk ol lm ln lo om lq lr ls im bi translated">A-star (A*)是人工智能中一个强大的算法，有着广泛的用途。然而，它只能发挥它的启发功能(考虑到问题的性质，它可以是高度可变的)。A*是寻路最流行的选择，因为它相当灵活。</p><p id="ebf0" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">它已经在许多软件系统中找到应用，从机器学习和搜索优化到游戏开发，其中角色通过复杂的地形和障碍到达玩家。</p><p id="8783" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">你可以在<a class="ae lt" href="https://github.com/BaijayantaRoy/Medium-Article/blob/master/A_Star.ipynb" rel="noopener ugc nofollow" target="_blank">这个</a> GitHub 仓库中找到完整的代码。</p><h2 id="d93e" class="on nr ji bd ns oo op dn nw oq or dp oa lg os ot oc lk ou ov oe lo ow ox og oy bi translated">感谢阅读。你可以在<a class="ae lt" href="http://www.linkedin.com/in/baijayantaroy" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上和我联系。</h2></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><p id="a9f7" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><em class="lu">每月只需 5 美元，就可以无限制地获取最鼓舞人心的内容……点击下面的链接，成为一名媒体会员，支持我的写作。谢谢大家！<br/></em><a class="ae lt" href="https://baijayanta.medium.com/membership" rel="noopener"><strong class="kz jj"><em class="lu"/></strong></a></p></div></div>    
</body>
</html>