<html>
<head>
<title>A Beginner’s Guide to Convolutional Neural Networks (CNNs)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卷积神经网络初学者指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-beginners-guide-to-convolutional-neural-networks-cnns-14649dbddce8?source=collection_archive---------3-----------------------#2019-02-15">https://towardsdatascience.com/a-beginners-guide-to-convolutional-neural-networks-cnns-14649dbddce8?source=collection_archive---------3-----------------------#2019-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="c5df" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">什么是卷积？</strong></h1><p id="9d3a" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">卷积是滤波器修改输入的方式。在卷积网络中，采用多个滤波器来分割图像，并逐个映射它们，学习输入图像的不同部分。想象一下，一个小滤镜从左到右从上到下滑过图像，移动的滤镜正在寻找，比如说，一个黑色的边缘。每次找到一个匹配，它就被映射到输出图像上。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/1b023179349fa54d715dfc2df8f6b49f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjxJxTXYuKrWM67zULmovA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk"><a class="ae mc" href="https://www.cs.columbia.edu/education/courses/course/COMSW4995-7/26050/" rel="noopener ugc nofollow" target="_blank">https://www.cs.columbia.edu/education/courses/course/COMSW4995-7/26050/</a></figcaption></figure><p id="d9db" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">例如，有一张 Eileen Collins 的照片，红色箭头上方的矩阵用作卷积来检测暗边缘。因此，我们看到的图像只强调了暗边。</p><p id="0b12" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">请注意，图像的宽度和高度是二维的。如果图像是彩色的，它被认为具有 RGB 颜色的多一个维度。因此，2D 卷积通常用于黑白图像，而 3D 卷积用于彩色图像。</p><h1 id="7ecd" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">2D 卷积</h1><p id="e156" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们从没有填充的(4 x 4)输入图像开始，我们使用(3 x 3)卷积滤波器来获得输出图像。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mi"><img src="../Images/6c1108e946b661658783b15c4c4e0eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuVRt1T9apScnlA6DLvbZA.png"/></div></div></figure><p id="86c1" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">第一步是用滤镜将输入图像中的黄色区域相乘。每个元素都与相应位置的一个元素相乘。然后你把所有的结果相加，就是一个输出值。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mj"><img src="../Images/d91ec3a52aec65dc6708bc435bec0e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gqDdVjiBDKbfiy73Dla4GQ.png"/></div></div></figure><p id="8f7b" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">数学上是(2 * 1)+(0 * 0)+(1 * 1)+(0 * 0)+(0 * 0)+(0 * 0)+(0 * 0)+(0 * 1)+(1 * 0)= 3</p><p id="ec3a" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">然后，重复相同的步骤，将过滤器移动一列。你得到第二个输出。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mk"><img src="../Images/973ec94b0764dca4e84dc8872223aa8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GBb3QETQiFwJFPpHtbHpAg.png"/></div></div></figure><p id="9b85" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">请注意，您只移动了一列过滤器。滤光器滑过图像的步长称为<strong class="kq iu">步幅</strong>。这里，步幅是 1。重复相同的操作以获得第三个输出。步幅大于 1 将总是缩小图像。如果大小为 1，图像的大小将保持不变。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ml"><img src="../Images/bc6602136ae1fe546ac6aa72c3c8c944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3xnBrDhMHSIVvcvKO6nhGw.png"/></div></div></figure><p id="ff83" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">最后，您将得到最终的输出。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mm"><img src="../Images/c42ae00621fb46dba25d784770d55267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KxJEaBsgYf4iD8WIiIUfEA.png"/></div></div></figure><p id="748c" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">我们看到输出图像的尺寸小于输入图像的尺寸。事实上，大多数情况下都是如此。</p><h1 id="5908" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">3D 卷积</h1><p id="e025" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">3D 卷积就像 2D，除了你要做 3 次 2d 工作，因为有 3 个颜色通道。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mn"><img src="../Images/0f8451fc10db58661ab8b75891c451e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hhV1YD1DCvZZle2ptot49Q.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk"><a class="ae mc" href="https://twitter.com/martin_gorner" rel="noopener ugc nofollow" target="_blank">https://twitter.com/martin_gorner</a></figcaption></figure><p id="203c" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">通常，输出的宽度会变小，就像 2D 案例中输出的大小一样。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mo"><img src="../Images/8570105ab357010530facb4c80bd2d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3h224gPb75UTehulYWYtA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk"><a class="ae mc" href="https://twitter.com/martin_gorner" rel="noopener ugc nofollow" target="_blank">https://twitter.com/martin_gorner</a></figcaption></figure><p id="6ef6" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">如果您想要保持输出图像的宽度和高度不变，而不减小滤镜大小，您可以使用零向原始图像添加填充，并对图像进行卷积切片。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mp"><img src="../Images/b87048b1cc784defa0ee16fa0041231c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HdxsYJWtKYRlhfE91uj74g.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk"><a class="ae mc" href="https://twitter.com/martin_gorner" rel="noopener ugc nofollow" target="_blank">https://twitter.com/martin_gorner</a></figcaption></figure><p id="8edd" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">我们可以应用更多的填充！</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mq"><img src="../Images/8cdc9669d7d0ff49849b2cd69f18df85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mPu7VPPkJlZu4BK2oarBZA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk"><a class="ae mc" href="https://twitter.com/martin_gorner" rel="noopener ugc nofollow" target="_blank">https://twitter.com/martin_gorner</a></figcaption></figure><p id="6a60" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">完成后，结果如下所示:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mr"><img src="../Images/a0a80edbb25497787da32db8cf37b76e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Or4rTWCrcVUDYEs28NWnIw.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk"><a class="ae mc" href="https://twitter.com/martin_gorner" rel="noopener ugc nofollow" target="_blank">https://twitter.com/martin_gorner</a></figcaption></figure><p id="de07" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">当您添加更多滤镜时，它会增加输出图像的深度。如果输出图像的深度为 4，则使用 4 个滤镜。每一层对应于一个滤波器，并学习一组权重。当它在图像上滑动时，它不会在各步之间改变。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ms"><img src="../Images/f4a1792d4bb1689fa88861e4b6758c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EfXAnrwUObQmFtaxcHUlVg.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk"><a class="ae mc" href="https://twitter.com/martin_gorner" rel="noopener ugc nofollow" target="_blank">https://twitter.com/martin_gorner</a></figcaption></figure><p id="5841" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">卷积的输出通道被称为<strong class="kq iu">特征图</strong>。它对其检测到的特征的存在与否和存在程度进行编码。注意，与之前的 2D 滤波器不同，每个滤波器连接到每个输入通道的<strong class="kq iu">。(问题？与 2D 不同，每个滤波器连接到每个输入通道是什么意思？)这意味着它们可以计算复杂的特征。最初，通过查看 R、G、B 通道，但是之后，通过查看诸如各种边缘、形状、纹理和语义特征的学习特征的组合。</strong></p><h1 id="0a56" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">平移不变量</h1><p id="f0c8" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">另一个有趣的事实是，CNN 在某种程度上抵抗平移，例如图像移动一点，这将具有与移动前相似的激活图。这是因为卷积是一个特征检测器，如果它检测的是暗边缘，并且图像被移动到底部，那么暗边缘将不会被检测到，直到卷积被向下移动。</p><h1 id="8c39" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">特例——1D 卷积</h1><p id="77d2" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">1D 卷积包括在这里，因为它通常解释不足，但它有值得注意的好处。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mt"><img src="../Images/3947520956973e460d42ae477e73ab57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmNeaYXaaMK9LTUy--27eA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk"><a class="ae mc" href="https://github.com/GoogleCloudPlatform/tensorflow-without-a-phd" rel="noopener ugc nofollow" target="_blank">https://github.com/GoogleCloudPlatform/tensorflow-without-a-phd</a></figcaption></figure><p id="68d1" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">它们用于减少深度(通道数)。在这种情况下，宽度和高度保持不变。如果要减少水平维度，可以使用池，增加卷积的步幅，或者不添加填充。1D 卷积计算输入通道或特征的加权和，这允许<strong class="kq iu">选择某些对下游有用的特征组合。1D 卷积压缩，因为只有一个它有相同的效果</strong></p><h1 id="220a" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">联营</h1><p id="9008" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">请注意，池化是与卷积分开的一个步骤。池用于减少图像的宽度和高度。请注意，深度由通道的数量决定。顾名思义，它所做的就是在一定大小的窗口中选择最大值。尽管它通常在空间上用于减少图像的 x，y 维度。</p><h1 id="75d1" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">最大池</strong></h1><p id="9fda" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最大池用于通过取窗口中元素的最大值，将给定窗口的大小映射到单个结果来减小图像大小。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mu"><img src="../Images/c5b8c9b0f0afec431070e89368e2d349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cx9Dl9Wu9a0Pazn79hbTlg.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk"><a class="ae mc" href="http://cs231n.github.io/convolutional-networks/" rel="noopener ugc nofollow" target="_blank">http://cs231n.github.io/convolutional-networks/</a></figcaption></figure><h1 id="6543" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">平均池</h1><p id="4a4e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">它与 max-pooling 相同，只是它对窗口进行平均，而不是选择最大值。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mv"><img src="../Images/4a657ab4a6f370205406f4f49160229a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H3N8I_D3bro2v6ym2PItgQ.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk"><a class="ae mc" href="http://cs231n.github.io/convolutional-networks/" rel="noopener ugc nofollow" target="_blank">http://cs231n.github.io/convolutional-networks/</a></figcaption></figure><h1 id="40c1" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">普通设置</strong></h1><p id="d9ac" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了实现 CNN，大多数成功的架构使用一个或多个具有 relu 激活的卷积+池层堆栈，然后是平坦层，然后是一个或两个密集层。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mw"><img src="../Images/e63eb3b3f6f24827758f6cebd92dffe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YUQWVE7rw_KS5pnKCY4t_Q.png"/></div></div></figure><p id="938f" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">随着我们在网络中移动，要素地图在空间上变得更小，在深度上变得更深。要素变得越来越抽象，失去了空间信息。例如，网络知道图像包含一只眼睛，但不确定它在哪里。</p><p id="aacb" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">这是一个典型的美国有线电视新闻网在喀拉斯的例子。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mx"><img src="../Images/e12a3d15641f3e1500d42e0f4cc4e471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SaxZK66Y6TxkINLXOqSQHA.png"/></div></div></figure><p id="1fd3" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">这是你做 model.summary()时的结果</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi my"><img src="../Images/3a8f388927842d76a89c73da70c1615c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3oSikg1Qv-zCL8rbFg-lw.png"/></div></div></figure><p id="7ab5" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">让我们将这些层分解开来，看看我们如何获得这些参数值。</p><h2 id="49db" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">Conv2d_1</h2><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nl"><img src="../Images/879b9c05b3e6bc20789e0b0e43bfa45b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQ5G2BH1UrJ4Pzn0PoXv7Q.png"/></div></div></figure><p id="afd7" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">过滤器尺寸(3 x 3) *输入深度(1) *过滤器数量(32) +偏差 1/过滤器(32) = 320。这里，输入深度是 1，因为它是针对 MNIST 黑白数据的。请注意，在 tensorflow 中，默认情况下，每个卷积层都添加了偏差。</p><h2 id="4e1e" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">最大池 2d 1</h2><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nm"><img src="../Images/e9089184414e1ca9fb83c81a9ed92267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wn45JlL4tLjiPh9vSsNS-w.png"/></div></div></figure><p id="eb92" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">池图层没有参数</p><h2 id="42be" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">Conv2d_2</h2><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nn"><img src="../Images/b65f834534a3ba470d8e47a58db87d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6IWlI9AxugCHZ5_X1--H6Q.png"/></div></div></figure><p id="4596" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">过滤器尺寸(3 x 3) *输入深度(32) *过滤器数量(64) +偏差，每个过滤器 1(64)= 18496</p><h2 id="b885" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">扁平化 _1</h2><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi no"><img src="../Images/4f4be1c728d432e57cebe7858fd07e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uiEaK0UhvJ8ZK3t5qe58PQ.png"/></div></div></figure><p id="1a53" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">它将上面的卷拆分成一个数组。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi np"><img src="../Images/37d4917a9e32969eb2f4ad8dfd1189dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_V3LvBVKuBlLOjxCm7nxzA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk"><a class="ae mc" href="https://github.com/GoogleCloudPlatform/tensorflow-without-a-phd" rel="noopener ugc nofollow" target="_blank">https://github.com/GoogleCloudPlatform/tensorflow-without-a-phd</a></figcaption></figure><h2 id="55e6" class="mz jr it bd js na nb dn jw nc nd dp ka kz ne nf ke ld ng nh ki lh ni nj km nk bi translated">密集 _1</h2><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nq"><img src="../Images/1596bb212145ede53bcf5402acbb36e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ck3kjaIcJH3QP7GZZCX66A.png"/></div></div></figure><p id="3342" class="pw-post-body-paragraph ko kp it kq b kr md kt ku kv me kx ky kz mf lb lc ld mg lf lg lh mh lj lk ll im bi translated">输入维度(128) *输出维度(10) +每个输出神经元一个偏置(10) = 1290</p><h1 id="5d6b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">摘要</h1><p id="d8ba" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">卷积神经网络(CNN)是一种深度神经网络(DNN ),广泛用于计算机视觉或 NLP。在训练过程中，为了使网络达到最佳性能并尽可能准确地对图像和对象进行分类，网络的构建模块被反复改变。</p><h1 id="46ac" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">来源</h1><p id="469c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">本教程基于约书亚·戈登在哥伦比亚大学的应用深度学习课程的讲座。令人惊叹的 3d 图像来自<a class="ae mc" href="https://twitter.com/martin_gorner" rel="noopener ugc nofollow" target="_blank">马丁·戈纳</a>。</p></div></div>    
</body>
</html>