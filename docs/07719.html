<html>
<head>
<title>Multiple Linear Regression from Scratch in Numpy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Numpy 中从零开始的多元线性回归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multiple-linear-regression-from-scratch-in-numpy-36a3e8ac8014?source=collection_archive---------5-----------------------#2019-10-26">https://towardsdatascience.com/multiple-linear-regression-from-scratch-in-numpy-36a3e8ac8014?source=collection_archive---------5-----------------------#2019-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6774" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">线性回归可能是最简单的“机器学习”算法。我打赌你已经使用过很多次了，可能是通过<a class="ae ko" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn </a>或者任何其他为你提供开箱即用解决方案的库。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/e387982c95890d2b7739b003318a806d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uI1FqVosWA14PtSv"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Photo by <a class="ae ko" href="https://unsplash.com/@bendavisual?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Benjamin Davies</a> on <a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cc4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是你有没有问过自己:<strong class="js iu"> <em class="lf">模型实际上是如何在幕后工作的？</em> </strong></p><p id="4f27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，在简单线性回归的情况下(<em class="lf">只有一个特征</em>)，你可以用一个简单的公式计算斜率和截距系数，但是这些公式不能转移到多元回归。如果你对简单线性回归一无所知，可以看看这篇文章:</p><div class="lg lh gp gr li lj"><a rel="noopener follow" target="_blank" href="/simple-linear-regression-from-scratch-in-numpy-871335e14b7a"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">Numpy 中从头开始的简单线性回归</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">机器学习不必复杂——如果用简单的术语解释的话。</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">towardsdatascience.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx kz lj"/></div></div></a></div><p id="3bc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天，我将只关注多元回归，并向您展示如何计算截距和尽可能多的线性代数斜率系数。会有一点数学，但没有手工实现。你应该熟悉像<strong class="js iu">矩阵乘法、矩阵求逆和矩阵转置这样的术语。</strong></p><p id="e545" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果这些听起来像科幻小说，不要害怕，我再一次为你报道:</p><div class="lg lh gp gr li lj"><a rel="noopener follow" target="_blank" href="/linear-algebra-essentials-with-numpy-part-1-af4a867ac5ca"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">Numpy 线性代数基础(第一部分)</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">学习数据科学的基本线性代数技能—第 1/2 部分</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">towardsdatascience.com</p></div></div><div class="ls l"><div class="ly l lu lv lw ls lx kz lj"/></div></div></a></div><p id="5c7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在那篇文章的底部有一个到第二部分的链接，第二部分介绍了矩阵的一些基本概念。现在让我们快速进入这篇文章的结构:</p><ol class=""><li id="3142" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn me mf mg mh bi translated">数学落后</li><li id="4511" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">进口</li><li id="73ce" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">类别定义</li><li id="1120" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">声明助手函数</li><li id="822c" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">声明<strong class="js iu"> <em class="lf"> fit() </em> </strong>函数</li><li id="33fc" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">声明<strong class="js iu"> <em class="lf">预测()</em> </strong>函数</li><li id="19fb" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">做预测</li><li id="c90f" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">结论</li></ol><p id="f01c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我知道有很多事情要谈。我会尽量让它简短，希望你能在 10 分钟内看完整篇文章。</p><p id="8e93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧，我们开始吧！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8922" class="mu mv it bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">数学落后</h1><p id="5d71" class="pw-post-body-paragraph jq jr it js b jt ns jv jw jx nt jz ka kb nu kd ke kf nv kh ki kj nw kl km kn im bi translated">正如我所说的，会有一些数学。但这并没有你想象的那么复杂。你会有你的特征(<strong class="js iu"> <em class="lf"> X </em> </strong>)和目标(<strong class="js iu"> <em class="lf"> y </em> </strong>)。这是如何表达模型的:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/9b27b5b52e3289415605b2afb5f8055e.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/1*0s5Aftk7SC_NSlCETN03qA.png"/></div></figure><p id="81fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中<strong class="js iu"> <em class="lf"> y </em> </strong>为目标变量的向量，<strong class="js iu"> <em class="lf"> X </em> </strong>为特征矩阵，<strong class="js iu"> <em class="lf"> beta </em> </strong>为你要估计的参数向量，<strong class="js iu"><em class="lf">ε</em></strong>为误差项。从数据集中，您需要将特征(<strong class="js iu"> <em class="lf"> X </em> </strong>)从目标(<strong class="js iu"><em class="lf">【y】</em></strong>)中分离出来，并且还需要添加一个<strong class="js iu">矢量，用于截距(<em class="lf">或偏差</em>)项的</strong>到<em class="lf"> X </em> 。</p><p id="0770" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成后，您可以通过以下公式获得系数:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/12c641f41f7f35b4e8abbc7c7e40e57e.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*57G4TZGROaD2SQTtd88pVA.png"/></div></figure><p id="60a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你现在可以看到，你需要了解什么是转置，什么是逆，以及如何乘矩阵。好的一面是，你不会手动操作，因为<em class="lf">数字</em>已经覆盖了你。</p><p id="4578" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">说到数学就差不多了。如果你敢，可以更深入地研究，但这对于本文的完成是不必要的。你现在可以进入下一部分了。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="9d90" class="mu mv it bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">进口</h1><p id="5cc0" class="pw-post-body-paragraph jq jr it js b jt ns jv jw jx nt jz ka kb nu kd ke kf nv kh ki kj nw kl km kn im bi translated"><strong class="js iu"> <em class="lf">我已经答应你纯 Numpy 实现了对吗？</em> </strong>好吧，你也可以使用<em class="lf"> Pandas </em>，但是只能从 CSV 文件中读取数据，其他的都可以用<em class="lf"> Numpy </em>来完成。</p><p id="90a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我还导入了<strong class="js iu"> <em class="lf">警告</em> </strong>模块，这样笔记本就保持干净了:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c75f782d88461288f90112cd9574f6fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*D5H7igmxKerAr0Dr9Dq-Tg.png"/></div></figure><p id="7c9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们来看看波士顿住房数据:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oa"><img src="../Images/e47e421f0c5b56fc96e8640312f7e7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvDDeJKkHcFZnXkZjqvyzw.png"/></div></div></figure><p id="491b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是导入的大部分内容，接下来让我们做一些编码。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="e610" class="mu mv it bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">类别定义</h1><p id="44df" class="pw-post-body-paragraph jq jr it js b jt ns jv jw jx nt jz ka kb nu kd ke kf nv kh ki kj nw kl km kn im bi translated">我决定用<strong class="js iu"> OOP </strong> ( <strong class="js iu"> <em class="lf">面向对象编程</em> </strong>)风格实现多元回归(<em class="lf">普通最小二乘回归</em>)。</p><p id="f97a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你不喜欢 OOP，你可以跳过这一部分，跳到下一部分，在自己的单元格中声明每个函数，但是我建议坚持 OOP 风格。首先，让我们声明一个新类，<strong class="js iu"><em class="lf">ordinallyeastsquares</em></strong>:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/054dc15203e48407f48d53432990773e.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*an9tZuUCw8sVfFW_bezQUw.png"/></div></figure><p id="068f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它还没有做任何事情。现在我们将只声明<strong class="js iu"> <em class="lf"> init </em> </strong>方法，其余的将在下面的章节中介绍。</p><p id="6de7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望用户能够看到回归模型的<strong class="js iu">系数</strong>，所以下面是解决这个问题的方法:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/94f6f13849125dea419ce1ce68ff27c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*xkJWbV2gXzpU6MnaexyTmg.png"/></div></figure><p id="5e8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于<strong class="js iu"> <em class="lf"> init </em> </strong>方法就到此为止，你现在可以继续了。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="66bb" class="mu mv it bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">声明助手函数</h1><p id="b2fa" class="pw-post-body-paragraph jq jr it js b jt ns jv jw jx nt jz ka kb nu kd ke kf nv kh ki kj nw kl km kn im bi translated">如果你花一点时间思考你的模型应该自动为用户做什么，你可能会得到两件事情的列表(<em class="lf">或更多</em>):</p><ol class=""><li id="db6a" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn me mf mg mh bi translated">如果只有一个特征，则对特征进行整形(<strong class="js iu"> <em class="lf"> X </em> </strong>)</li><li id="1521" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">将 1 的向量连接到特征矩阵</li></ol><p id="0701" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你不这样做，你的模型就会失败。没人喜欢那样。</p><p id="a58e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个辅助函数非常简单，你只需要将<strong class="js iu"> <em class="lf"> X </em> </strong>重塑成任何二维图形:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi od"><img src="../Images/7a3bca24406e92b89893ed0aceafff16.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*yq_nG1lql0_ZI1ufB8riew.png"/></div></figure><p id="c1c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于第二个辅助函数，您需要一个向量，其元素数量与您的特征矩阵的一列相同。使用<em class="lf"> numpy </em>你可以生成这个向量并连接它:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/38f38f908047e3315b59c3a971a9ed90.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*PzeaVTdnLa7kSzACJUQJfg.png"/></div></figure><p id="de2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想知道函数名前的下划线是什么，这就是在 Python 中声明一个私有方法的方法。<strong class="js iu"> <em class="lf">怪异吧？</em>T15】</strong></p><p id="2ce7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，这几乎是目前的一切。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="229e" class="mu mv it bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">声明 fit()函数</h1><p id="3a87" class="pw-post-body-paragraph jq jr it js b jt ns jv jw jx nt jz ka kb nu kd ke kf nv kh ki kj nw kl km kn im bi translated">这是你模型的核心。<strong class="js iu"> <em class="lf"> fit() </em> </strong>函数将负责训练模型并进行整形和拼接操作(<em class="lf">调用之前声明的辅助函数</em>)。</p><p id="614a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<strong class="js iu"> <em class="lf"> X </em> </strong>是一维的，就要进行整形。然后，二维表示应该与一的向量连接起来。</p><p id="01dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，您可以使用上面讨论的公式来获得系数。请注意我是如何将它们设置为<strong class="js iu"> <em class="lf">自系数</em> </strong>的，因为我希望最终用户可以访问它们:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi of"><img src="../Images/be5461774331081a77512eb4f9876d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*2kJZqydCBf-TzabOaC7Xtw.png"/></div></figure><p id="9b7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只需再完成一项功能，您就可以开始了！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c473" class="mu mv it bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">声明 predict()函数</h1><p id="461c" class="pw-post-body-paragraph jq jr it js b jt ns jv jw jx nt jz ka kb nu kd ke kf nv kh ki kj nw kl km kn im bi translated">与前一个一样，<strong class="js iu"> <em class="lf">预测()</em> </strong>功能也将是最终用户所必需的。它将用于验证模型并做出新的预测。</p><p id="d8b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们深入探究其背后的逻辑。本质上，您希望用户输入被格式化为列表。第一个系数代表截距或偏差项，所有其他系数需要乘以各自的值<strong class="js iu"><em class="lf">×T36】</em></strong>。所以想法是同时迭代 new <strong class="js iu"> <em class="lf"> X </em> </strong>和所有系数(<em class="lf">不是截距项</em>)并将它们相乘，然后根据结果增加预测:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi og"><img src="../Images/60b3c07398dac2824a2a14c57ba19130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*EmPT-2jzZ62vXLdO_feMUw.png"/></div></figure><p id="8598" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lf">挺整齐的吧？</em> </strong>好了，事情就是这样，你现在可以用这个类来做一个实例，然后再来做预测。</p><p id="c720" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来看看怎么做。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b04f" class="mu mv it bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">做预测</h1><p id="0b1d" class="pw-post-body-paragraph jq jr it js b jt ns jv jw jx nt jz ka kb nu kd ke kf nv kh ki kj nw kl km kn im bi translated">在本文的前面，我们加载了波士顿住房数据集。现在该构造特征矩阵和目标向量了——或者说白了就是<strong class="js iu"> <em class="lf"> X </em> </strong>和<strong class="js iu"> <em class="lf"> y </em> </strong>:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/fdfbbf21956550dad1528a97dc8c3834.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*jwui_z0SrvpJao-XSnYB6A.png"/></div></figure><p id="f379" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以像往常一样在这里进行训练测试分割，但是我决定不这样做，只是为了保持文章简洁。创建一个<strong class="js iu"><em class="lf">ordinallyeastsquares</em></strong>的实例，并使<strong class="js iu"> <em class="lf"> X </em> </strong>和<strong class="js iu"> <em class="lf"> y </em> </strong>符合它——就像您对<strong class="js iu"><em class="lf">Scikit-Learn</em></strong>:l</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/8d2aaa6e02db6354ed9de0eda702838a.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*A350MsVMeYYnAYC35BkNnQ.png"/></div></figure><p id="c290" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">训练结束了。您可以像这样访问系数:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/b92f4e04be6118608c6a0b0c6d4b6127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*CmEpjhQJQWZAzjPxkd04HQ.png"/></div></figure><p id="f515" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lf">甜蜜吧？</em> </strong>假设你要对第一行<strong class="js iu"> <em class="lf"> X </em> </strong>做一个预测:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/42a58eb83ccf9418a0916725c9cd2eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*wrKuHy6l31wfa3_EEy0a7Q.png"/></div></figure><p id="3d01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一切正常。或者如果您想对<strong class="js iu"> <em class="lf"> X </em> </strong>中的每一行进行预测:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/518ecb3801a9e2d7adaa3ca5927c1b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*ztR6cTFPY4ITHxeFFfCS1A.png"/></div></figure><p id="df77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，一切看起来都很好。你现在可以去计算一些指标，比如<strong class="js iu"> <em class="lf"> MSE </em> </strong>，但这不是本文的重点。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c6fe" class="mu mv it bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">在你离开之前</h1><p id="9ccf" class="pw-post-body-paragraph jq jr it js b jt ns jv jw jx nt jz ka kb nu kd ke kf nv kh ki kj nw kl km kn im bi translated">尝试手工实现这个普通的最小二乘回归可能是个好主意。我是说用笔和纸。但不是用这个数据集，定义一两个特征和两三个观察值，并尝试手工计算。</p><p id="4fa9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这并不难，但是一旦完成，你会对为什么一切都正常运转更有信心。谢天谢地，后面的线性代数概念很简单，可以很快学会。然后，您可以使用 Python 来验证结果。</p><p id="ae92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望一切都尽可能的干净，但是如果你有不明白的地方，请随时联系我。 </p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="d95e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">喜欢这篇文章吗？成为 <a class="ae ko" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="lf">中等会员</em> </a> <em class="lf">继续无限制的学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="lg lh gp gr li lj"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">通过我的推荐链接加入 Medium-Dario rade ci</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">medium.com</p></div></div><div class="ls l"><div class="om l lu lv lw ls lx kz lj"/></div></div></a></div></div></div>    
</body>
</html>