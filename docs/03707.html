<html>
<head>
<title>Dynamically split/create multiple datasets from single dataset in SAS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 SAS 中从单个数据集动态拆分/创建多个数据集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dynamically-split-create-multiple-datasets-from-single-dataset-in-sas-7a6ea1f5f15d?source=collection_archive---------9-----------------------#2019-06-12">https://towardsdatascience.com/dynamically-split-create-multiple-datasets-from-single-dataset-in-sas-7a6ea1f5f15d?source=collection_archive---------9-----------------------#2019-06-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/c2907e2ed52af520b759fd611bf0a878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*q27jYcyl4NJMyx0Mf0pjEg.png"/></div></figure><p id="0bc5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">将一个数据集分割成多个数据集是 SAS 程序员经常面临的挑战。例如，将从世界各地收集的数据分割成独特的国别数据集，其中每个数据集只包含特定于该国的数据。在这种情况下，程序员经常被迫对程序进行硬编码，并使用多个循环来完成工作，这不是一种好的做法。然而，SAS 为这个问题提供了一个漂亮的、一次性的、可重用的解决方案。让我们直接进入它。</p><h1 id="72cb" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">导入数据集</h1><p id="0ac9" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">我们有以下全球销售数据集(<em class="ly"> Worldwide_Sales.xls </em>):</p><blockquote class="lz ma mb"><p id="48e6" class="jx jy ly jz b ka kb kc kd ke kf kg kh mc kj kk kl md kn ko kp me kr ks kt ku im bi translated">所有数据集和代码文件都可以在 GitHub(<em class="it"/><a class="ae mf" href="https://github.com/pramodkumavat/createMultipleDatasets/" rel="noopener ugc nofollow" target="_blank"><em class="it">【https://github.com/pramodkumavat/createMultipleDatasets/</em></a><em class="it"/>)找到。</p></blockquote><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mg"><img src="../Images/1eed0f34b40d59563ffa6faffecda7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XBBe4JI04etcMePs"/></div></div></figure><p id="7391" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们首先将这个数据集导入到我们的 SAS 环境中。</p><p id="cc8b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">页（page 的缩写）s:请将数据集文件<em class="ly"> Worldwide_Sales.xls </em>复制到您的 SAS 工作目录<em class="ly"> myfolders </em>中。</p><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="d02c" class="mu kw it mq b gy mv mw l mx my">proc import out=work.sales<br/>datafile='/folders/myfolders/Worldwide_Sales.xls'<br/>dbms=xls replace;<br/>getnames=yes;<br/>run;</span></pre><p id="903c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">运行上面的代码将把我们的数据集作为<em class="ly"> work.sales </em>库加载到 SAS 中。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mz"><img src="../Images/54490585553af7fa6d89bbf7b3da09db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*adWl6yz1xhMINYKl"/></div></div></figure><p id="396e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要理解导入代码中使用的各种选项，这个<a class="ae mf" href="https://stats.idre.ucla.edu/sas/faq/how-do-i-readwrite-excel-files-in-sas/" rel="noopener ugc nofollow" target="_blank"> FAQ </a>就是你所需要的。</p><h1 id="dfda" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">创建多个数据集</h1><p id="2e5c" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">业务需求表明，我们必须从全球数据集创建国家唯一的数据集。这样创建的每个数据集将包含该特定国家的销售数据。为此，我们首先需要从数据集中提取唯一的国家名称。</p><h1 id="b04a" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">步骤 1:提取唯一的国家名称</h1><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="7f49" class="mu kw it mq b gy mv mw l mx my">proc sort data=work.sales out=work.unique (keep=Country)<br/>nodupkey;<br/>by country;<br/>run;</span></pre><p id="9cc2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">运行上面的代码将为我们提供数据集中唯一的国家名称。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi na"><img src="../Images/cac3ecd53484ea4a31f66e22e47d7c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*U4FZ5RWn7wuTnx70qYtOrg.jpeg"/></div></figure><p id="ae9a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一旦我们提取了国家名称，现在让我们创建我们的神奇代码，在单个<em class="ly">数据</em>语句中动态创建国家级数据集。</p><h1 id="f4ad" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">步骤 2:动态创建多个数据集</h1><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="d718" class="mu kw it mq b gy mv mw l mx my">data _null_;<br/>set work.unique;<br/>call execute('data ' !! compress(Country) !! '; set work.sales; where Country = "' !! Country !! '"; run;');<br/>run;</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nb"><img src="../Images/6698c52fb4696dbb7caa69f7fcbf020b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xyLmSmUA1WKSZatb"/></div></div></figure><p id="1ad9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">正如您在上面的输出中所看到的，在左侧，我们看到已经创建了国家唯一的数据集。</p><h1 id="3a73" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">幕后的魔法</h1><p id="a26a" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">让我们一行一行地理解代码的每一个方面，这使得魔术成为可能。</p><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="3dc7" class="mu kw it mq b gy mv mw l mx my">data _null_;</span></pre><p id="1e74" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将输出<em class="ly">数据</em>设置为<em class="ly"> _null_ </em>，因为我们不想创建单个数据集，而是一次创建多个数据集，这一点我们稍后会看到。</p><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="cdc8" class="mu kw it mq b gy mv mw l mx my">set work.unique;</span></pre><p id="c774" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将输入数据集设置为<em class="ly"> work.unique </em>，其中包含唯一的国家名称。我们这样做是因为我们希望在每次迭代中创建独特的国家级数据集。</p><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="531b" class="mu kw it mq b gy mv mw l mx my">call execute('data ' !! compress(Country) !! '; set work.sales; where Country = "' !! Country !! '"; run;');<br/>run;</span></pre><p id="a266" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这才是真正的交易！您可能已经注意到，我们在<em class="ly"> call execute() </em>语句中编写了一个嵌套查询。如前所述，SAS 提供了这个漂亮的解决方案来创建多个数据集，而不使用多个循环。</p><p id="bbde" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在<em class="ly"> execute() </em>调用中，我们以<em class="ly">数据</em>语句开始，然后附加上我们唯一的国家名称。<em class="ly">国家</em>这里只是来自我们<em class="ly"> work.unique </em>数据集的变量。<em class="ly"> compress </em>函数应用于<em class="ly"> Country </em>变量，因为我们的国家名称中有空格(例如，新西兰、英国)。这个<em class="ly"> compress </em>函数在创建唯一数据集时删除国家名称中的空格。</p><p id="63d5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后我们放分号(<em class="ly">；</em>)结束我们的<em class="ly">数据</em>步骤，然后将输入数据集设置为<em class="ly"> work.sales </em>。很明显，我们将输入设置为父数据集<em class="ly"> work.sales </em>，使用它我们将创建唯一的数据集。然后，我们放入<em class="ly"> where </em>条件，以便它从父数据集中挑选国家级数据。然后，我们用<em class="ly"> run </em>语句结束嵌套查询，并关闭<em class="ly"> execute() </em>调用。代码的最后一个<em class="ly"> run </em>语句是为了结束外部查询。</p><h1 id="768b" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">完整代码</h1><p id="b4c3" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">我在这里粘贴完整的 SAS 代码供您参考。这个 SAS 代码(<em class="ly">dynamicmultipledatasets . SAS</em>)以及使用的数据集(<em class="ly"> Worldwide_Sales.xls </em>)可以从 GitHub <a class="ae mf" href="https://github.com/pramodkumavat/createMultipleDatasets/" rel="noopener ugc nofollow" target="_blank">这里</a>下载。</p><pre class="mh mi mj mk gt mp mq mr ms aw mt bi"><span id="73b9" class="mu kw it mq b gy mv mw l mx my">* Importing the dataset in SAS;</span><span id="9d74" class="mu kw it mq b gy nc mw l mx my">proc import out=work.sales<br/>datafile='/folders/myfolders/Worldwide_Sales.xls'<br/>dbms=xls replace;<br/>getnames=yes;<br/>run;</span><span id="5da1" class="mu kw it mq b gy nc mw l mx my">* Extracting country names from the dataset;</span><span id="79da" class="mu kw it mq b gy nc mw l mx my">proc sort data=work.sales out=work.unique (keep=Country)<br/>nodupkey;<br/>by country;<br/>run;</span><span id="f5a4" class="mu kw it mq b gy nc mw l mx my">* Creating multiple datasets from the parent dataset;</span><span id="7a71" class="mu kw it mq b gy nc mw l mx my">data _null_;<br/>set work.unique;<br/>call execute('data ' !! compress(Country) !! '; set work.sales; where Country = "' !! Country !! '"; run;');<br/>run;</span></pre><p id="e9a1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">希望这对你有帮助。请评论您的反馈/建议。干杯！</p></div></div>    
</body>
</html>