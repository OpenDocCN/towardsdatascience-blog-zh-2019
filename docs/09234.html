<html>
<head>
<title>Data Wrangling using Pandas library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Pandas 库的数据争论</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-wrangling-using-pandas-library-ae26f8bbbdd2?source=collection_archive---------22-----------------------#2019-12-06">https://towardsdatascience.com/data-wrangling-using-pandas-library-ae26f8bbbdd2?source=collection_archive---------22-----------------------#2019-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7c49" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本文中，我们将看到一些最有用的技术，用于清理和处理熊猫图书馆的数据。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4640210c7263bff19126a58b9efe4b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xPN1TMIK_kHoVBcQLKErYA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@ikukevk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae kv" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4fec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据科学涉及数据的处理，以便数据可以很好地与数据算法一起工作。数据角力是处理数据的过程，如合并、分组和连接等。Pandas 库提供了有用的函数来支持数据争论任务。</p><p id="7087" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果你问任何数据分析师、数据科学家或统计学家，他们把大部分时间花在哪个任务上，答案将是数据清理或数据争论和数据操纵，而不是编码或运行使用数据的模型。</p><p id="af70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">与 Python 争论数据的目标:</strong></p><ul class=""><li id="c4dd" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">从众多来源收集数据以揭示更深刻的情报。</li><li id="5834" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">及时向业务/数据分析师提供可操作的准确数据。</li><li id="699d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">减少收集和整理的时间。简而言之，在数据被使用之前对其进行清理。</li><li id="bdeb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">让数据分析师和科学家专注于数据分析，而不是争论。</li><li id="6200" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">帮助组织中的高层领导做出更好的决策。</li></ul><p id="1a85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在本文中讨论以下主题。</p><ul class=""><li id="ee02" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">数据探索</li><li id="aedb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">查找缺失值</li><li id="b0a7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">过滤数据</li><li id="f09b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">整理</li><li id="c1d7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">合并和串联</li></ul><h1 id="9d0e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">数据探索</h1><p id="db5d" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在对数据进行任何操作之前，第一步是定位文件(csv、excel 和 xlsx 等)。)，然后通过内置的 Pandas 函数读取它。在我的例子中，我将<code class="fe nd ne nf ng b"><em class="nh">train.csv</em></code>文件存储在我正在处理的同一个目录中。</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="01c1" class="nm mh iq ng b gy nn no l np nq">import pandas as pd<br/>df = pd.read_csv('train.csv')<br/>df.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/bb7853b5596bca85db13925d3536a852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eyJFUqpfLYrH6P86U31orw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Top 5 rows</figcaption></figure><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="8529" class="nm mh iq ng b gy nn no l np nq">df.dtypes</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/7dc50867e4d1bf59a61888fa0ff3a410.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*x0NUpq-AQw1cdLSFgPD-Sw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Output</figcaption></figure><p id="6fc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的代码摘录中，我们探索了我们的数据及其类型。现在我们通过<code class="fe nd ne nf ng b"><em class="nh">describe()</em></code>函数来描述数据。</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="0dbf" class="nm mh iq ng b gy nn no l np nq">df.describe()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/203af25eb72d48adacbff5edf2bd9590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2bi5zEsekrJHEvGobNaOfQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Statistics of data</figcaption></figure><p id="2533" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b"><em class="nh">describe()</em></code>给出了关于数据的见解和一些有用的统计数据，如平均值、最小值和最大值等。</p><h1 id="bc2b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">处理缺失值</h1><p id="8a75" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">你的数据集可能包含许多缺失和重复的值，因此在对它们应用任何机器学习算法之前，我们(数据科学家)有责任处理它们。如果我们为我们的机器学习模型提供尽可能多的干净和准确的数据，那么我们训练的模型就会预测尽可能多的准确预测。</p><p id="a924" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以将总缺失值总结如下:</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="64c3" class="nm mh iq ng b gy nn no l np nq">df.isna().sum()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1d7fd872e37a547b3f022e2260fba363.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*x6YCnWhJTZkVRRET292fsQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Sum of missing values</figcaption></figure><p id="1118" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经确定了数据集中缺失的值，现在我们有几个选项来处理它们，要么我们可以删除那些包含缺失值的行，要么我们可以计算平均值、最小值、最大值和中值等。如果缺失值的行数占百分比很大(大约。20% — 30%)，那么放弃它们将不是一个好的选择。所以你的工作是检验各种技术并明智地采取行动。</p><p id="907d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的输出可以看出，<code class="fe nd ne nf ng b"><em class="nh">Embarked</em></code>列中缺失值的数量只有 2，但是<code class="fe nd ne nf ng b"><em class="nh">Cabin</em></code>和<code class="fe nd ne nf ng b"><em class="nh">Age</em></code>列的数量很大，所以我们不能忽略它们。首先，我们将删除包含列<code class="fe nd ne nf ng b"><em class="nh">Embarked</em></code>中缺失值的行，然后计算列<code class="fe nd ne nf ng b"><em class="nh">Age</em></code>的平均值，并用平均值填充它们，并从数据集中删除列<code class="fe nd ne nf ng b"><em class="nh">Cabin</em></code>。</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="1efd" class="nm mh iq ng b gy nn no l np nq"># fill in the missing values in 'Age' column<br/>age_mean_value=df['Age'].mean()<br/>df['Age']=df['Age'].fillna(age_mean_value)</span></pre><p id="17f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拆下立柱<code class="fe nd ne nf ng b"><em class="nh">Cabin</em></code></p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="517a" class="nm mh iq ng b gy nn no l np nq">df.drop("Cabin",axis=1,inplace=True)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/02adafe574bf4ab51119e9da84e76314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OuYJ5UMtpDGpTCoUmZq6nw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Dataset after dropping Cabin Colum</figcaption></figure><h1 id="8d6c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">过滤数据</h1><p id="acc0" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">下面这段代码对年龄大于 40 的整个数据集进行筛选，这意味着它将只包含那些列年龄大于 40 的行。</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="1f99" class="nm mh iq ng b gy nn no l np nq">filtered_age = df[df.Age&gt;40]<br/>filtered_age</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/a4b514cf6bdf6033451129019e1e38c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UtcKkJssKwhD1xBVWeTERw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Filtered by age&gt;40</figcaption></figure><p id="0252" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，最初有 891 行，按年龄过滤后，只剩下 150 行。</p><h1 id="34a0" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">整理</h1><p id="c1e0" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><code class="fe nd ne nf ng b"><em class="nh">sort_values</em></code>功能可以帮助你对数据帧进行升序或降序排序。默认情况下<code class="fe nd ne nf ng b"><em class="nh">sort_values</em></code>函数使用<code class="fe nd ne nf ng b"><em class="nh">quick sort</em></code>算法进行排序，如果您想使用<code class="fe nd ne nf ng b"><em class="nh">heap sort</em></code>或<code class="fe nd ne nf ng b"><em class="nh">merge sort</em></code>等。然后可以使用<code class="fe nd ne nf ng b"><em class="nh">kind</em></code>关键字。</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="c0f2" class="nm mh iq ng b gy nn no l np nq"># let's sort the column Name in ascending order<br/>sorted_passengers = df.sort_values('Name',ascending=True,kind ='heapsort')<br/># now print the sorted data<br/>sorted_passengers.head(10)</span></pre><p id="ede1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我根据<code class="fe nd ne nf ng b"><em class="nh">Name</em></code>对数据集进行了排序</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/46091be6995b5551df8ec4df18d8ad9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZBK8bPABld2cd8JLXzbGew.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Sorted Dataset</figcaption></figure><h1 id="f80d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">合并和串联</h1><p id="b960" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Pandas 有<code class="fe nd ne nf ng b"><em class="nh">merge</em></code>函数来合并两个数据帧，这是一个非常简单的函数。我已经从数据集中提取了上面两行和下面两行，并通过<code class="fe nd ne nf ng b"><em class="nh">Pandas</em></code> <code class="fe nd ne nf ng b"><em class="nh">merge</em></code>函数将它们组合起来。</p><p id="a16b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b"><em class="nh">head()</em></code>和<code class="fe nd ne nf ng b"><em class="nh">tail()</em></code>函数分别返回顶行和底行，而<code class="fe nd ne nf ng b"><em class="nh">outer</em></code>帮助合并两个不常用的行。</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="9a68" class="nm mh iq ng b gy nn no l np nq">merged_df = pd.merge(df.head(2),df.tail(2),how='outer',indicator=True)<br/>merged_df</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/0e350ccfc401eaf208c222d318258d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gILEV6mq87bcYqfDwypVxw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Merged two dataframe</figcaption></figure><h1 id="b5aa" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="24c2" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们已经看到了如何使用 Pandas 库处理和清理数据集，以及如何执行各种技术来清理数据集。</p><p id="73b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对这篇文章有任何疑问，请随时问我，我会尽力解决你的疑问。</p><p id="2fa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要获取我的 Jupyter 笔记本和数据集，请点击<a class="ae kv" href="https://github.com/himanshujbd/Data_Wrangling" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="72d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢读这篇文章，你也可以访问我的<a class="ae kv" href="http://thehimanshuverma.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">网站</strong> </a> <strong class="ky ir"> </strong>，在那里我会定期发布文章。</p><p id="a126" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://mailchi.mp/b08da935e5d9/himanshuverma" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅</strong> </a>我的邮件列表，直接在您的收件箱中提前获得我的文章，或者关注我自己在 Medium 上发表的文章<a class="ae kv" href="https://medium.com/the-code-monster" rel="noopener"><strong class="ky ir">The Code Monster</strong></a>以完善您的技术知识。</p><h1 id="a4eb" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">了解你的作者</h1><p id="847c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">希曼舒·维尔马毕业于印度勒克瑙的 APJ 阿卜杜勒·卡拉姆大学博士。他是 Android &amp; IOS 开发人员、机器学习和数据科学学习者、金融顾问和博客作者。</p></div></div>    
</body>
</html>