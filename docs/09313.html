<html>
<head>
<title>Deep Java Library(DJL) — a Deep Learning Toolkit for Java Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度 Java 库(DJL)——面向 Java 开发人员的深度学习工具包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deep-java-library-djl-a-deep-learning-toolkit-for-java-developers-55d5a45bca7e?source=collection_archive---------24-----------------------#2019-12-09">https://towardsdatascience.com/deep-java-library-djl-a-deep-learning-toolkit-for-java-developers-55d5a45bca7e?source=collection_archive---------24-----------------------#2019-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="4a2e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener" target="_blank" href="https://towardsdatascience.com/data-science-in-the-real-world/home">现实世界中的数据科学</a></h2><div class=""/><div class=""><h2 id="dac0" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">亚马逊发布深度 Java 库(DJL ),为 Java 开发者提供深度学习的快速入门</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/039be8bdb3feb3cae79db5fbe24115ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHYALqg37kPMT1_dhsrp4A.jpeg"/></div></div></figure></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="fcaf" class="pw-post-body-paragraph lh li iq lj b lk ll ka lm ln lo kd lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated"><a class="ae md" href="https://djl.ai/" rel="noopener ugc nofollow" target="_blank"> Deep Java Library (DJL) </a>，是亚马逊创建的开源库，用于在 Java 中本地开发机器学习(ML)和深度学习(DL)模型，同时简化深度学习框架的使用。</p><p id="a5b5" class="pw-post-body-paragraph lh li iq lj b lk ll ka lm ln lo kd lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">我最近用 DJL 开发了一个鞋类分类模型，发现这个工具包超级直观和易用；很明显，在设计和 Java 开发人员将如何使用它上花了很多心思。DJL API 抽象出常用的功能来开发模型和编排基础设施管理。我发现用于训练、测试和运行推理的高级 API 允许我使用 Java 和 ML 生命周期的知识，用最少的代码在不到一个小时的时间内开发一个模型。</p><h1 id="5a0a" class="me mf iq bd mg mh mi mj mk ml mm mn mo kf mp kg mq ki mr kj ms kl mt km mu mv bi translated">鞋类分类模型</h1><p id="0ae2" class="pw-post-body-paragraph lh li iq lj b lk mw ka lm ln mx kd lp lq my ls lt lu mz lw lx ly na ma mb mc ij bi translated">鞋类分类模型是使用监督学习训练的多类分类计算机视觉(CV)模型，它将鞋类分类为四类标签之一:靴子、凉鞋、鞋子或拖鞋。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/83befb5dcf4e17a2c3c53a915dea7117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*75qRjJcA9ztr-AxVyOsPjg.jpeg"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Image 1: footwear data (source UT Zappos50K)</figcaption></figure><h2 id="4a16" class="ng mf iq bd mg nh ni dn mk nj nk dp mo lq nl nm mq lu nn no ms ly np nq mu iw bi translated">关于数据</h2><p id="dff2" class="pw-post-body-paragraph lh li iq lj b lk mw ka lm ln mx kd lp lq my ls lt lu mz lw lx ly na ma mb mc ij bi translated">开发精确的 ML 模型最重要的部分是使用来自可靠来源的数据。鞋类分类模型的数据源是由德克萨斯大学奥斯汀分校提供的数据集，可免费用于学术和非商业用途。鞋子数据集由从<a class="ae md" href="https://www.zappos.com/" rel="noopener ugc nofollow" target="_blank">Zappos.com</a>收集的 50，025 张带标签的目录图片组成。</p><h2 id="2905" class="ng mf iq bd mg nh ni dn mk nj nk dp mo lq nl nm mq lu nn no ms ly np nq mu iw bi translated">训练鞋类分类模型</h2><p id="0fdb" class="pw-post-body-paragraph lh li iq lj b lk mw ka lm ln mx kd lp lq my ls lt lu mz lw lx ly na ma mb mc ij bi translated">训练是通过给学习算法训练数据来产生 ML 模型的过程。术语模型是指在训练过程中产生的工件；该模型包含在训练数据中发现的模式，并可用于进行预测(或推断)。在开始培训过程之前，我设置了本地开发环境。你将需要 JDK 8(或更高版本)，IntelliJ，一个用于训练的 ML 引擎(像<a class="ae md" href="https://mxnet.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache MXNet </a>)，一个指向你的引擎路径的环境变量和 DJL 的构建依赖。</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="52fe" class="ng mf iq ns b gy nw nx l ny nz">dependencies <strong class="ns ja">{</strong></span><span id="2cdb" class="ng mf iq ns b gy oa nx l ny nz">compile "org.apache.logging.log4j:log4j-slf4j-impl:2.12.1"</span><span id="7236" class="ng mf iq ns b gy oa nx l ny nz">compile "ai.djl:api:0.2.0"</span><span id="4cb5" class="ng mf iq ns b gy oa nx l ny nz">compile "ai.djl:basicdataset:0.2.0"</span><span id="48de" class="ng mf iq ns b gy oa nx l ny nz">compile "ai.djl:examples:0.2.0"</span><span id="1f59" class="ng mf iq ns b gy oa nx l ny nz">compile "ai.djl:model-zoo:0.2.0"</span><span id="ea91" class="ng mf iq ns b gy oa nx l ny nz">compile "ai.djl.mxnet:mxnet-model-zoo:0.2.0"</span><span id="14f8" class="ng mf iq ns b gy oa nx l ny nz">runtimeOnly "ai.djl.mxnet:mxnet-native-mkl:1.6.0-a:osx-x86_64"</span><span id="ab14" class="ng mf iq ns b gy oa nx l ny nz"><strong class="ns ja">}</strong></span></pre><p id="d4ee" class="pw-post-body-paragraph lh li iq lj b lk ll ka lm ln lo kd lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">通过成为引擎和深度学习框架不可知者，DJL 忠于 Java 的座右铭，“编写一次，在任何地方运行(WORA)。开发人员可以编写一次运行在任何引擎上的代码。DJL 目前提供了 Apache MXNet 的实现，这是一个简化深度神经网络开发的 ML 引擎。DJL API 使用 JNA，Java 原生访问，来调用相应的 Apache MXNet 操作。从硬件的角度来看，培训是在我的笔记本电脑上使用 CPU 进行的。然而，为了获得最佳性能，DJL 团队建议使用至少带有一个 GPU 的机器。如果你没有可用的 GPU，总有一个选项可以在<a class="ae md" href="https://aws.amazon.com/ec2/" rel="noopener ugc nofollow" target="_blank">亚马逊 EC2 </a>上使用 Apache MXNet。DJL 的一个很好的特性是，它提供了基于硬件配置的自动 CPU/GPU 检测，以始终确保最佳性能。</p><h2 id="0674" class="ng mf iq bd mg nh ni dn mk nj nk dp mo lq nl nm mq lu nn no ms ly np nq mu iw bi translated">从源加载数据集</h2><p id="244c" class="pw-post-body-paragraph lh li iq lj b lk mw ka lm ln mx kd lp lq my ls lt lu mz lw lx ly na ma mb mc ij bi translated">鞋类数据保存在本地，并使用 DJL <code class="fe oc od oe ns b">ImageFolder</code>数据集加载，该数据集可以从本地文件夹中检索图像。用 DJL 的术语来说，一个<code class="fe oc od oe ns b">Dataset</code>只是保存训练数据。有些数据集实现可用于下载数据(基于您提供的 URL)、提取数据以及自动将数据分成定型集和验证集。自动分离是一个有用的功能，因为绝不使用训练模型所用的相同数据来验证模型的性能是很重要的。训练验证数据集用于在数据中查找模式；验证数据集用于在训练过程中估计鞋类模型的准确性。</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="176f" class="ng mf iq ns b gy nw nx l ny nz"><em class="ob">//identify the location of the training data</em>String trainingDatasetRoot = <strong class="ns ja">"src/test/resources/imagefolder/train"</strong>;</span><span id="2d45" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">//identify the location of the validation data</em>String validateDatasetRoot = <strong class="ns ja">"src/test/resources/imagefolder/validate"</strong>;</span><span id="1673" class="ng mf iq ns b gy oa nx l ny nz">//create training ImageFolder dataset<br/>ImageFolder trainingDataset = initDataset(trainingDatasetRoot);</span><span id="84b0" class="ng mf iq ns b gy oa nx l ny nz">//create validation ImageFolder dataset<br/>ImageFolder validateDataset = initDataset(validateDatasetRoot);</span><span id="5fb4" class="ng mf iq ns b gy oa nx l ny nz"><strong class="ns ja">private </strong>ImageFolder initDataset(String datasetRoot) <strong class="ns ja">throws </strong>IOException {</span><span id="6f4e" class="ng mf iq ns b gy oa nx l ny nz">     ImageFolder dataset = <strong class="ns ja">new </strong>ImageFolder<br/>          .Builder()<br/>          .setRepository(<strong class="ns ja">new    <br/>              </strong>SimpleRepository(Paths.get(datasetRoot))).optPipeline(</span><span id="6a27" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">     // create preprocess pipeline<br/>     </em><strong class="ns ja">new </strong>Pipeline()<br/>          .add(<strong class="ns ja">new </strong>Resize(NEW_WIDTH, NEW_HEIGHT))<br/>          .add(<strong class="ns ja">new </strong>ToTensor()))<br/>          .setSampling(BATCH_SIZE,<strong class="ns ja">true</strong>)<br/>          .build();</span><span id="f7f0" class="ng mf iq ns b gy oa nx l ny nz">     dataset.prepare();<br/>     <strong class="ns ja">return </strong>dataset;<br/>}</span></pre><p id="efa3" class="pw-post-body-paragraph lh li iq lj b lk ll ka lm ln lo kd lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">当在本地构建数据时，我没有深入到 UTZappos50k 数据集确定的最细粒度级别，如脚踝、膝盖高、小腿中部、膝盖以上等。靴子的分类标签。我的本地数据保存在最高级别的分类中，只包括靴子、凉鞋、鞋子和拖鞋。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/8214d52d2a92c9600ea570226acadd35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cTOumuoqtjkNscGO"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Image 2: structure of local training data</figcaption></figure><h2 id="2ef1" class="ng mf iq bd mg nh ni dn mk nj nk dp mo lq nl nm mq lu nn no ms ly np nq mu iw bi translated">训练模型</h2><p id="de8e" class="pw-post-body-paragraph lh li iq lj b lk mw ka lm ln mx kd lp lq my ls lt lu mz lw lx ly na ma mb mc ij bi translated">现在，我已经将鞋类数据分为训练集和验证集，我将使用神经网络来训练模型。</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="804e" class="ng mf iq ns b gy nw nx l ny nz"><strong class="ns ja">public</strong> final class <strong class="ns ja">Training</strong> extends <strong class="ns ja">AbstractTraining</strong> {</span><span id="629c" class="ng mf iq ns b gy oa nx l ny nz">     . . .</span><span id="a036" class="ng mf iq ns b gy oa nx l ny nz">     <strong class="ns ja">@Override</strong><br/>     <strong class="ns ja">protected</strong> <strong class="ns ja">void</strong> <strong class="ns ja">train</strong>(Arguments arguments) <strong class="ns ja">throws</strong> IOException {<br/> <br/>          . . .</span><span id="443a" class="ng mf iq ns b gy oa nx l ny nz"><strong class="ns ja">          try </strong>(Model model = Models.getModel(NUM_OF_OUTPUT, <br/>                                   NEW_HEIGHT, NEW_WIDTH)) {</span><span id="33c3" class="ng mf iq ns b gy oa nx l ny nz">               TrainingConfig config = setupTrainingConfig(loss);</span><span id="8f54" class="ng mf iq ns b gy oa nx l ny nz">               <strong class="ns ja">try </strong>(Trainer trainer = model.newTrainer(config)) {      <br/>                    trainer.setMetrics(metrics);<br/>                    trainer.setTrainingListener(<strong class="ns ja">this</strong>);<br/>                    Shape inputShape = <strong class="ns ja">new </strong>Shape(1, 3, NEW_HEIGHT, <br/>                                                 NEW_WIDTH);<br/>          <br/>                    <em class="ob">// initialize trainer with proper input shape<br/>                    </em>trainer.initialize(inputShape);</span><span id="5d4e" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">                    //find the patterns in data<br/>                    </em>fit(trainer, trainingDataset, <br/>                        validateDataset, <strong class="ns ja">"build/logs/training"</strong>);</span><span id="c3df" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">                    //set model properties<br/>                    </em>model.setProperty(<strong class="ns ja">"Epoch"</strong>, <br/>                                      String.valueOf(EPOCHS));<br/>                    model.setProperty(<strong class="ns ja">"Accuracy"</strong>, <br/>                                      String.format(<strong class="ns ja">"%.2f"</strong>,         <br/>                                          getValidationAccuracy()));</span><span id="bf5f" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">                    //save the model after done training for <br/>                    //inference later model saved <br/>                    //as shoeclassifier-0000.params<br/>                    </em>model.save(Paths.get(modelParamsPath), <br/>                               modelParamsName);</span><span id="5619" class="ng mf iq ns b gy oa nx l ny nz">               }<br/>          }<br/>}</span></pre><p id="432a" class="pw-post-body-paragraph lh li iq lj b lk ll ka lm ln lo kd lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">通过将训练数据输入到<a class="ae md" href="https://djl-ai.s3.amazonaws.com/java-api/0.1.0/index.html" rel="noopener ugc nofollow" target="_blank">模块</a>开始训练。用 DJL 的术语来说，<code class="fe oc od oe ns b">Block</code>是形成神经网络的可组合单元。你可以组合积木(就像乐高积木一样)形成一个复杂的网络。在训练过程的最后，一个<code class="fe oc od oe ns b">Block</code>代表一个完全训练好的模型。第一步是通过调用<code class="fe oc od oe ns b">Models.getModel(NUM_OF_OUTPUT, NEW_HEIGHT, NEW_WIDTH)</code>获得一个模型实例。<code class="fe oc od oe ns b">getModel()</code>方法创建一个空模型，构造神经网络，将神经网络设置到模型上。</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="c2c4" class="ng mf iq ns b gy nw nx l ny nz"><em class="ob">/*<br/>Use a neural network (ResNet-50) to train the model</em></span><span id="0d76" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">ResNet-50 is a deep residual network with 50 layers; good for image classification<br/>*/</em></span><span id="f6e8" class="ng mf iq ns b gy oa nx l ny nz"><strong class="ns ja">public class </strong>Models {<br/>     <strong class="ns ja">public static </strong>ai.djl.Model getModel(<strong class="ns ja">int </strong>numOfOutput, <br/>                                         <strong class="ns ja">int </strong>height, <strong class="ns ja">int </strong>width) <br/>     {<br/>         <em class="ob">//create new instance of an empty model<br/>         </em>ai.djl.Model model = ai.djl.Model.newInstance();</span><span id="304f" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">         //Block is a composable unit that forms a neural network;<br/>         //combine them like Lego blocks to form a complex network<br/>         </em>Block resNet50 = <strong class="ns ja">new </strong>ResNetV1.Builder()<br/>              .setImageShape(<strong class="ns ja">new </strong>Shape(3, height, width))<br/>              .setNumLayers(50)<br/>              .setOutSize(numOfOutput)<br/>              .build();</span><span id="7cdc" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">         //set the neural network to the model         <br/>         </em>model.setBlock(resNet50);<br/>         <strong class="ns ja">return </strong>model;</span><span id="b60c" class="ng mf iq ns b gy oa nx l ny nz">     }<br/>}</span></pre><p id="0fc4" class="pw-post-body-paragraph lh li iq lj b lk ll ka lm ln lo kd lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">下一步是通过调用<code class="fe oc od oe ns b">model.newTrainer(config)</code>方法来设置和配置一个<code class="fe oc od oe ns b">Trainer</code>。config 对象是通过调用<code class="fe oc od oe ns b">setupTrainingConfig(loss)</code>方法初始化的，该方法设置训练配置(或超参数)来确定如何训练网络。</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="dc4e" class="ng mf iq ns b gy nw nx l ny nz"><strong class="ns ja">private static </strong>TrainingConfig setupTrainingConfig(Loss loss) {<br/>     <em class="ob">// epoch number to change learning rate<br/>     </em><strong class="ns ja">int</strong>[] epoch = {3, 5, 8};</span><span id="a05c" class="ng mf iq ns b gy oa nx l ny nz"><strong class="ns ja">     int</strong>[] steps = Arrays<br/>                       .stream(epoch)<br/>                       .map(k -&gt; k * 60000 /  BATCH_SIZE).toArray();</span><span id="38f5" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">     //initialize neural network weights using Xavier initializer<br/>     </em>Initializer initializer = <strong class="ns ja">new </strong>XavierInitializer(<br/>         XavierInitializer.RandomType.UNIFORM,<br/>         XavierInitializer.FactorType.AVG, 2);</span><span id="dd34" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">     //set the learning rate<br/>     //adjusts weights of network based on loss<br/>     </em>MultiFactorTracker learningRateTracker = LearningRateTracker<br/>          .multiFactorTracker()<br/>          .setSteps(steps)<br/>          .optBaseLearningRate(0.01f)<br/>          .optFactor(0.1f)<br/>          .optWarmUpBeginLearningRate(1e-3f)<br/>          .optWarmUpSteps(500)<br/>          .build();</span><span id="5ae8" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">     //set optimization technique<br/>     //minimizes loss to produce better and faster results<br/>     //Stochastic gradient descent<br/>     </em>Optimizer optimizer = Optimizer<br/>          .sgd()<br/>          .setRescaleGrad(1.0f / BATCH_SIZE)<br/>          .setLearningRateTracker(learningRateTracker)<br/>          .optMomentum(0.9f)<br/>          .optWeightDecays(0.001f)<br/>          .optClipGrad(1f)<br/>          .build();</span><span id="2438" class="ng mf iq ns b gy oa nx l ny nz"><strong class="ns ja">     return new </strong>DefaultTrainingConfig(initializer, loss)<br/>          .setOptimizer(optimizer)<br/>          .addTrainingMetric(<strong class="ns ja">new </strong>Accuracy())<br/>          .setBatchSize(BATCH_SIZE);<br/>}</span></pre><p id="943c" class="pw-post-body-paragraph lh li iq lj b lk ll ka lm ln lo kd lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">为训练设置了多个超参数:</p><ul class=""><li id="4ec0" class="og oh iq lj b lk ll ln lo lq oi lu oj ly ok mc ol om on oo bi translated"><code class="fe oc od oe ns b"><strong class="lj ja">newHeight</strong></code>和<code class="fe oc od oe ns b"><strong class="lj ja">newWidth</strong></code> —图像的形状。</li><li id="8d9e" class="og oh iq lj b lk op ln oq lq or lu os ly ot mc ol om on oo bi translated"><code class="fe oc od oe ns b"><strong class="lj ja">batchSize</strong></code> —用于训练的批量；根据你的模型选择合适的尺寸。</li><li id="7aa5" class="og oh iq lj b lk op ln oq lq or lu os ly ot mc ol om on oo bi translated"><code class="fe oc od oe ns b"><strong class="lj ja">numOfOutput</strong></code> —标签的数量；鞋类分类有 4 个标签。</li><li id="665d" class="og oh iq lj b lk op ln oq lq or lu os ly ot mc ol om on oo bi translated"><code class="fe oc od oe ns b"><strong class="lj ja">loss</strong></code> —损失函数根据衡量模型好坏的真实标签评估模型预测。</li><li id="be99" class="og oh iq lj b lk op ln oq lq or lu os ly ot mc ol om on oo bi translated"><code class="fe oc od oe ns b"><strong class="lj ja">Initializer</strong></code> —标识初始化方法；在这种情况下，Xavier 初始化。</li><li id="5a91" class="og oh iq lj b lk op ln oq lq or lu os ly ot mc ol om on oo bi translated"><code class="fe oc od oe ns b"><strong class="lj ja">MultiFactorTracker</strong></code> —配置学习率选项。</li><li id="baf5" class="og oh iq lj b lk op ln oq lq or lu os ly ot mc ol om on oo bi translated"><code class="fe oc od oe ns b"><strong class="lj ja">Optimizer</strong></code>:最小化损失函数值的优化技术；在这种情况下，随机梯度下降(SGD)。</li></ul><p id="b4ab" class="pw-post-body-paragraph lh li iq lj b lk ll ka lm ln lo kd lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">下一步是设置<code class="fe oc od oe ns b">Metrics</code>，一个训练监听器，并用正确的输入形状初始化<code class="fe oc od oe ns b">Trainer</code>。<code class="fe oc od oe ns b">Metrics</code>在培训期间收集和报告关键绩效指标(KPI ),这些指标可用于分析和监控培训绩效和稳定性。接下来，我通过调用<code class="fe oc od oe ns b">fit(trainer, trainingDataset, validateDataset, <strong class="lj ja">“build/logs/training”</strong>) </code>方法开始训练过程，该方法迭代训练数据并存储在模型中找到的模式。</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="f93d" class="ng mf iq ns b gy nw nx l ny nz"><strong class="ns ja">public void </strong>fit(Trainer trainer, Dataset trainingDataset, Dataset validateDataset,String outputDir) <strong class="ns ja">throws </strong>IOException {</span><span id="287d" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">     // find patterns in data<br/>     </em><strong class="ns ja">for </strong>(<strong class="ns ja">int </strong>epoch = 0; epoch &lt; EPOCHS; epoch++) <br/>     {<br/>         <strong class="ns ja">for </strong>(Batch batch : trainer.iterateDataset(trainingDataset)) <br/>         {<br/>              trainer.trainBatch(batch);<br/>              trainer.step();<br/>              batch.close();<br/>         }<br/> <br/>         <em class="ob">//validate patterns found<br/>         </em><strong class="ns ja">if </strong>(validateDataset != <strong class="ns ja">null</strong>) {<br/>           <strong class="ns ja">for </strong>(Batch batch:             <br/>                trainer.iterateDataset(validateDataset)){<br/>                     trainer.validateBatch(batch);<br/>                     batch.close();<br/>           }<br/>         }</span><span id="2f9c" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">         //reset training and validation metric at end of epoch<br/>         </em>trainer.resetTrainingMetrics();</span><span id="34af" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">         //save model at end of each epoch<br/>         </em><strong class="ns ja">if </strong>(outputDir != <strong class="ns ja">null</strong>) {<br/>              Model model = trainer.getModel();<br/>              model.setProperty(<strong class="ns ja">"Epoch"</strong>, String.valueOf(epoch));<br/>              model.save(Paths.get(outputDir), <strong class="ns ja">"resnetv1"</strong>);<br/>         }<br/>      }<br/>}</span></pre><p id="3a8f" class="pw-post-body-paragraph lh li iq lj b lk ll ka lm ln lo kd lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">在训练的最后，使用<code class="fe oc od oe ns b">model.save(Paths.get(modelParamsPath), modelParamsName)</code>方法，一个运行良好的经验证的模型工件及其属性被保存在本地。培训过程中报告的指标如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/881f3d301295f6909781d6f1cc445cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JmnQXZCzZRcKdEfh"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Image 3: metrics reported during training</figcaption></figure><h2 id="b190" class="ng mf iq bd mg nh ni dn mk nj nk dp mo lq nl nm mq lu nn no ms ly np nq mu iw bi translated">运行推理</h2><p id="19d8" class="pw-post-body-paragraph lh li iq lj b lk mw ka lm ln mx kd lp lq my ls lt lu mz lw lx ly na ma mb mc ij bi translated">现在我有了一个模型，我可以用它对我不知道分类(或目标)的新数据进行推断(或预测)。在设置了模型和要分类的图像的必要路径之后，我使用<code class="fe oc od oe ns b">Models.getModel(NUM_OF_OUTPUT, NEW_HEIGHT, NEW_WIDTH)</code>方法获得一个空的模型实例，并使用<code class="fe oc od oe ns b">model.load(Paths.get(modelParamsPath), modelParamsName)</code>方法初始化它。这将加载我在上一步中训练的模型。接下来，我使用<code class="fe oc od oe ns b">model.newPredictor(translator)</code>方法，用指定的<code class="fe oc od oe ns b">Translator</code>初始化一个<code class="fe oc od oe ns b">Predictor</code>。你会注意到我将一个<code class="fe oc od oe ns b">Translator</code>传递给了<code class="fe oc od oe ns b">Predictor</code>。在 DJL 术语中，<code class="fe oc od oe ns b">Translator</code>提供模型预处理和后处理功能。例如，对于 CV 模型，需要将图像重塑为灰度；a <code class="fe oc od oe ns b">Translator</code>可以帮你做到这一点。<code class="fe oc od oe ns b">Predictor</code>允许我使用<code class="fe oc od oe ns b">predictor.predict(img)</code>方法对加载的<code class="fe oc od oe ns b">Model</code>进行推理，传入图像进行分类。我做的是单个预测，但是 DJL 也支持批量预测。推理存储在<code class="fe oc od oe ns b">predictResult</code>中，其中包含每个标签的概率估计。一旦推理完成，模型自动关闭，使得 DJL 记忆有效。</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="989b" class="ng mf iq ns b gy nw nx l ny nz"><strong class="ns ja">private </strong>Classifications predict() <strong class="ns ja">throws </strong>IOException, ModelException, TranslateException  {<br/>     <br/>     <em class="ob">//the location to the model saved during training<br/>     </em>String modelParamsPath = <strong class="ns ja">"build/logs"</strong>;</span><span id="11f5" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">     //the name of the model set during training<br/>     </em>String modelParamsName = <strong class="ns ja">"shoeclassifier"</strong>;</span><span id="3046" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">     //the path of image to classify<br/>     </em>String imageFilePath = <strong class="ns ja">"src/test/resources/slippers.jpg"</strong>;</span><span id="322a" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">     //Load the image file from the path<br/>     </em>BufferedImage img =       <br/>          BufferedImageUtils.fromFile(Paths.get(imageFilePath));</span><span id="7fad" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">     //holds the probability score per label<br/>     </em>Classifications predictResult;</span><span id="5bc8" class="ng mf iq ns b gy oa nx l ny nz"><strong class="ns ja">     try </strong>(Model model = Models.getModel(NUM_OF_OUTPUT, NEW_HEIGHT, NEW_WIDTH)) {</span><span id="5bc4" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">          //load the model<br/>          </em>model.load(Paths.get(modelParamsPath), modelParamsName);</span><span id="993b" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">          //define a translator for pre and post processing<br/>          </em>Translator&lt;BufferedImage, Classifications&gt; translator =       <br/>                <strong class="ns ja">new </strong>MyTranslator();</span><span id="83f9" class="ng mf iq ns b gy oa nx l ny nz"><em class="ob">          //run the inference using a Predictor<br/>          </em><strong class="ns ja">try </strong>(Predictor&lt;BufferedImage, Classifications&gt; predictor =  <br/>                 model.newPredictor(translator)) {<br/>                      predictResult = predictor.predict(img);<br/>          }<br/>       }</span><span id="36b7" class="ng mf iq ns b gy oa nx l ny nz"><strong class="ns ja">     return </strong>predictResult;<br/>}</span></pre><p id="9aa1" class="pw-post-body-paragraph lh li iq lj b lk ll ka lm ln lo kd lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">推论(每张图片)及其相应的概率得分如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ou"><img src="../Images/2f8b7cd011998a1550105095ee3047a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Z8wc2mp6a6GbBsFKgUVgg.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Image 4: Inference for boots</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ov"><img src="../Images/4d88ecf1494853d6a8425a478b124430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aJRmGjPH4dnYH1m10MdETA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Image 5: Inference for sandals</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ou"><img src="../Images/1c1247d520a7e2e590ca5d31c04b8a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xaXs6LibSdkK9Iywv0lfxA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Image 6: Inference for shoes</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ow"><img src="../Images/ef4665fb3a2bdac17d6b6f452b89866d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZZrTtSpfsIrT7oiVCXNjw.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Image 7: Inference for slippers</figcaption></figure><h2 id="997f" class="ng mf iq bd mg nh ni dn mk nj nk dp mo lq nl nm mq lu nn no ms ly np nq mu iw bi translated">外卖和后续步骤</h2><p id="29c5" class="pw-post-body-paragraph lh li iq lj b lk mw ka lm ln mx kd lp lq my ls lt lu mz lw lx ly na ma mb mc ij bi translated">我从 90 年代末开始开发基于 Java 的应用程序，并在 2017 年开始了我的机器学习之旅。如果当时 DJL 在的话，我的旅程会容易得多。我强烈建议希望过渡到机器学习的 Java 开发人员给 DJL 一个机会。在我的例子中，我从头开始开发了鞋类分类模型；然而，DJL 也允许开发人员以最小的努力部署预先训练好的模型。DJL 还提供了现成的流行数据集，允许开发人员立即开始使用 ML。在开始学习 DJL 之前，我建议你对 ML 生命周期有一个牢固的理解，并且熟悉常见的 ML 术语。一旦你对 ML 有了一个基本的理解，你就可以很快熟悉 DJL API。</p><p id="6168" class="pw-post-body-paragraph lh li iq lj b lk ll ka lm ln lo kd lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">亚马逊有开源的 DJL，在那里可以在 DJL <a class="ae md" href="https://djl.ai/" rel="noopener ugc nofollow" target="_blank">网站</a>和<a class="ae md" href="https://javadoc.djl.ai/" rel="noopener ugc nofollow" target="_blank"> Java 库 API 规范</a>页面找到关于该工具包的更多详细信息。鞋类分类模型的代码可以在<a class="ae md" href="http://bit.ly/deep-java" rel="noopener ugc nofollow" target="_blank"> GitLab </a>上找到。祝您的 ML 之旅好运，如果您有任何问题，请随时联系我。</p></div></div>    
</body>
</html>