<html>
<head>
<title>Importing JSON files for Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为数据科学导入 JSON 文件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lots-of-json-29873d3abfdf?source=collection_archive---------10-----------------------#2019-02-21">https://towardsdatascience.com/lots-of-json-29873d3abfdf?source=collection_archive---------10-----------------------#2019-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7459" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用 Python 操作 JSON 文件的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ee4b9fe1a4fa64522f62b36b71952e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbR3zTt7fMf1H_efMgNriA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/photos/p0j-mE6mGo4?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Lorenzo Herrera</a> on <a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8d3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近看了一篇<a class="ae ky" href="https://veekaybee.github.io/2019/02/13/data-science-is-different/" rel="noopener ugc nofollow" target="_blank">的博文</a>，关于 2019 年数据科学家的重要工具。其中一个工具是 JSON……很多 JSON。</p><p id="a4d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我学习的早期，我在 kaggle 上偶然发现了基于<a class="ae ky" href="https://www.kaggle.com/roamresearch/prescriptionbasedprediction" rel="noopener ugc nofollow" target="_blank">处方的预测数据集</a>。太完美了。作为一名药学背景的学生，我想探索药物数据。只有一个问题…</p><blockquote class="lv"><p id="6a55" class="lw lx it bd ly lz ma mb mc md me lu dk translated">数据在 JSON 里…</p></blockquote><p id="0be6" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">JSON 或 JavaScript Object Notation 是一种“轻量级的数据交换格式…机器很容易解析和生成。”</p><p id="31a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们说“对人类来说读和写很容易”。但是，当我第一次将 JSON 文件加载到 dataframe 中时，我会有不同的看法。</p><p id="5045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们将探索一些在数据科学工作流的数据清理和预处理步骤中有用的方法，并希望让您相信 JSON 确实易于人类读写。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="774e" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">入门指南</h1><p id="d179" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们可以使用<code class="fe no np nq nr b">%%bash</code> magic 打印我们的文件样本:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="8da8" class="nw ms it nr b gy nx ny l nz oa">%%bash <br/>head ../input/roam_prescription_based_prediction.jsonl</span><span id="4df2" class="nw ms it nr b gy ob ny l nz oa">{<br/>  "cms_prescription_counts": {<br/>    "CEPHALEXIN": 23, <br/>    "AMOXICILLIN": 52, <br/>    "HYDROCODONE-ACETAMINOPHEN": 28},<br/>  "provider_variables": {<br/>    "settlement_type": "non-urban", <br/>    "generic_rx_count": 103, <br/>    "specialty": "General Practice", <br/>    "years_practicing": 7, <br/>    "gender": "M", <br/>    "region": "South", <br/>    "brand_name_rx_count": 0}, <br/>  "npi": "1992715205"}</span></pre><p id="3744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里我们可以看到 JSON 数据看起来像一个 Python 字典。那没那么可怕！</p><p id="6fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的字典里很容易读懂。使用 pandas read_json 方法的 json 文件:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="c8c7" class="nw ms it nr b gy nx ny l nz oa">raw_data = pd.read_json("../input/roam_prescription_based_prediction.jsonl",<br/>                        lines=True,<br/>                        orient='columns')<br/><br/>raw_data.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/0542eb8b1bb07c8b5a1ec49a240e9cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UmX76XvnYqtKtzt5N_JO0A.png"/></div></div></figure><p id="5eff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在唯一的问题是，我们有嵌套的列值…并且在这一点上不完全可用。让我们探索一些解包这些值的方法。</p><h1 id="81a9" class="mr ms it bd mt mu od mw mx my oe na nb jz of ka nd kc og kd nf kf oh kg nh ni bi translated">列表理解</h1><p id="472d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">列表理解是解开 provider_variables 列中数据的一种简单方法。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="afe5" class="nw ms it nr b gy nx ny l nz oa">provider = pd.DataFrame([md for md in df.provider_variables])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/37bbf23a6db2ee4ca51112aaa666a1d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L3E08J1QtU5LEJiMeR0WCA.png"/></div></div></figure><p id="db18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完美！我们现在有了提供者变量的数据框架！但是我想说，如果没有某种密钥，这些数据不会给我们带来太多好处。让我们将提供商的 npi 编号添加到该数据帧中，并将 NPI 列设置为索引:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="9021" class="nw ms it nr b gy nx ny l nz oa">provider['npi'] = raw_data.npi<br/>provider.set_index('npi', inplace=True)<br/>provider.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/937d47815e9fc4670b95bb6758281736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HsglZrokDjo85112Dh2HKw.png"/></div></div></figure><h1 id="4fb3" class="mr ms it bd mt mu od mw mx my oe na nb jz of ka nd kc og kd nf kf oh kg nh ni bi translated">JSON 正常化</h1><p id="850f" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">Pandas 的<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.json.json_normalize.html" rel="noopener ugc nofollow" target="_blank"> json_normalize </a>方法是展平数据的另一个选择:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="885d" class="nw ms it nr b gy nx ny l nz oa">from pandas.io.json import json_normalize<br/>provider = json_normalize(data=raw_data.provider_variables)<br/>provider.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/37bbf23a6db2ee4ca51112aaa666a1d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L3E08J1QtU5LEJiMeR0WCA.png"/></div></div></figure><h2 id="40fa" class="nw ms it bd mt ok ol dn mx om on dp nb li oo op nd lm oq or nf lq os ot nh ou bi translated">方法效率</h2><p id="2ed3" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">因此，我们有两个选项可以产生相同的结果。使用哪种方法更好？</p><p id="45d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<a class="ae ky" href="https://ipython.readthedocs.io/en/stable/interactive/magics.html" rel="noopener ugc nofollow" target="_blank">魔法</a>命令<code class="fe no np nq nr b">%timeit</code>来查找每个语句的执行时间:</p><p id="a81a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">列表理解:</strong></p><p id="d970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">729 毫秒，每循环 8.21 毫秒(平均标准时间戴夫。7 次运行，每次 1 个循环)</p><p id="8172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> JSON 正常化:</strong></p><p id="e8b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每循环 4.72 秒 104 毫秒(平均标准偏差。戴夫。7 次运行，每次 1 个循环)</p><p id="264e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以看到列表理解方法执行得更快。</p><h1 id="67b4" class="mr ms it bd mt mu od mw mx my oe na nb jz of ka nd kc og kd nf kf oh kg nh ni bi translated">结论</h1><p id="fee8" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在本文中，我们学习了如何用 Python 操作 JSON 数据。我们学习了如何展平嵌套数据并将其转换为数据帧。</p><p id="f62a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望了解到 JSON 文件并没有那么糟糕！</p></div></div>    
</body>
</html>