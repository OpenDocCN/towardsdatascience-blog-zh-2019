<html>
<head>
<title>Building distributed apps: first approximation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建分布式应用程序:第一近似值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-distributed-apps-first-approximation-2bbab777f6b2?source=collection_archive---------28-----------------------#2019-04-08">https://towardsdatascience.com/building-distributed-apps-first-approximation-2bbab777f6b2?source=collection_archive---------28-----------------------#2019-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7ce0ee598fd49da882b673eeeb989c42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u4If3GpMU-jXmKRH"/></div></div></figure><p id="e2ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<a class="ae kz" rel="noopener" target="_blank" href="/building-distributed-apps-zero-approximation-b0c4b16f92d3">之前的文章</a>中，我们已经讨论了反应式架构的理论基础。现在是时候讨论数据流、实现反应式 Erlang/Elixir 系统的方法以及其中包含的消息交换模式了:</p><ul class=""><li id="5538" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">请求-响应</li><li id="33b3" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">请求分块响应</li><li id="de38" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">带请求的响应</li><li id="5a03" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">发布-订阅</li><li id="5bc1" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">反向发布-订阅</li><li id="4b31" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">任务分配</li></ul></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="3ab3" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">SOA、MSA 和消息传递</h1><p id="35e8" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">SOA 和 MSA 是定义系统开发规则的服务架构。反过来，消息传递为我们提供了实现它们的原语。</p><p id="f931" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不想提倡任何特定类型的建筑。我完全赞成使用完全满足某个项目或业务需求的实践。无论我们选择什么样的范例，系统组件都应该用 Unix 方式来创建:具有最小连接性的组件实现不同的系统实体。API 方法对实体执行基本操作。</p><p id="68ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">消息传递，从名字就能猜到，是一个消息代理。它的主要目的是接收和发送信息。此外，它还负责消息发送接口、创建逻辑数据通信通道、路由、平衡和处理系统级故障。</p><p id="8f81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正在开发的消息传递并不试图与 Rabbitmq 竞争或取代它。其主要特点如下:</p><ul class=""><li id="f944" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><em class="my">分布式自然</em>。可以在集群的任何节点上创建交换，尽可能靠近利用它们的代码。</li><li id="00e7" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><em class="my">简约</em>。面向可用性和样板代码的最小化。</li><li id="fe02" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><em class="my">更好的性能</em>。我们并不试图复制 Rabbitmq 的功能。我们只是强调架构和传输层，并将它们嵌入到 OTP 中，同时降低成本。</li><li id="56b8" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><em class="my">灵活性</em>。每个服务都可以集成许多交换模式。</li><li id="ab54" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><em class="my">容错</em>体现在设计中。</li><li id="33b9" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><em class="my">可扩展性</em>。信息与应用一起成长。随着负载的增加，我们可以将一些交换点放在不同的机器上。</li></ul><p id="acef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="my">注意。</em> <strong class="kd iu"> </strong>就代码组织而言，元项目也就是伞状项目非常适合 Erlang/Elixir 中的复杂系统。所有的项目代码都位于一个存储库中——保护伞项目。同时，微服务被尽可能地隔离，并执行由独立实体负责的简单操作。在这种方法下，很容易支持整个系统的 API。您还可以毫不费力地进行更改并编写单元测试或综合测试。</p><p id="82fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在服务架构中，组件直接或通过代理进行交互。从消息传递的角度来看，每个服务都有多个生命阶段:</p><ul class=""><li id="1b8f" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><em class="my">服务初始化</em>。在这一阶段，初始化和启动流程及其所有依赖项。</li><li id="a5e6" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><em class="my">创建交易所</em>。服务可以使用节点配置中给定的静态交换，也可以动态创建交换。</li><li id="7d6c" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><em class="my">服务注册</em>。服务必须在 exchange 上注册才能处理请求。</li><li id="8a89" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><em class="my">正常工作</em>。在这种模式下，服务处理用户的请求。</li><li id="715b" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><em class="my">过程的终止</em>。有两种可能的终止方式:正常终止和崩溃终止。在第一种情况下，服务从交换机断开并停止。然而，在崩溃的情况下，消息传递执行处理故障的场景之一。</li></ul><p id="6d07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这看起来可能有点复杂，但是如果你看一下代码，实际上并没有那么糟糕。本文稍后将给出一些代码示例。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="d1a1" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">交换</h1><p id="328f" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">交换是消息服务的内部过程。它在定义的消息交换模式中提供不同系统组件之间的交互逻辑。</p><p id="60cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下面的所有示例中，组件通过交换进行交互，交换的组合创建了消息传递。</p><h1 id="0c31" class="lv lw it bd lx ly mz ma mb mc na me mf mg nb mi mj mk nc mm mn mo nd mq mr ms bi translated">消息交换模式(MEP)</h1><p id="282a" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">一般来说，所有的 MEP 都可以分为双向和单向模式。前者意味着对收到的信息作出反应，后者则不然。客户机-服务器体系结构中双向 MEP 的一个经典例子是请求-响应模板。让我们仔细看看这个和它的修改。</p><h1 id="01ea" class="lv lw it bd lx ly mz ma mb mc na me mf mg nb mi mj mk nc mm mn mo nd mq mr ms bi translated">请求-响应或 RPC</h1><p id="d48b" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">当我们需要从另一个进程获得响应时，就会用到 RPC。这个过程可以在同一个节点开始，甚至可以位于不同的洲。下图展示了通过消息传递实现的客户端-服务器交互。</p><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/48c754f5a5c8835db57b138609410655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UKhmtY3EwYTqQPE5"/></div></div></figure><p id="2e05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为消息传递是完全异步的，所以客户端的交换包括两个阶段:</p><ul class=""><li id="65c2" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">发送请求。</li></ul><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="d054" class="no lw it nk b gy np nq l nr ns">messaging:request(Exchange, ResponseMatchingTag, RequestDefinition, HandlerProcess)</span></pre><p id="4a66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="my">交换</em>是唯一的交换名称</p><p id="d4f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="my"> ResponseMatchingTag </em>用于处理响应的本地标签。例如，当属于不同用户的几个相同的请求被发送时。</p><p id="65db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="my">请求定义</em><em class="my"/>请求体</p><p id="e822" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="my">处理器流程</em>处理器 PID。这个过程将得到一个服务器响应。</p><ul class=""><li id="1500" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">收到回应</li></ul><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="5c51" class="no lw it nk b gy np nq l nr ns">handle_info(#'$msg'{exchange = EXCHANGE, tag = ResponseMatchingTag,message = ResponsePayload}, State)</span></pre><p id="bc4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="my"> ResponsePayload </em>是服务器响应。</p><p id="1373" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于服务器，该过程也分两个阶段进行:</p><ol class=""><li id="1d9c" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky nt lg lh li bi translated">Exchange 初始化</li><li id="2fa3" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky nt lg lh li bi translated">请求的处理</li></ol><p id="7d1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种模式可以用代码来说明。假设我们必须创建一些简单的服务来提供精确时间的方法。</p><p id="0cf8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，让我们将 API 定义代码放入<strong class="kd iu"> api.hrl </strong>:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="3a03" class="no lw it nk b gy np nq l nr ns">%% =====================================================</span><span id="8189" class="no lw it nk b gy nu nq l nr ns">%%  entities</span><span id="413c" class="no lw it nk b gy nu nq l nr ns">%% =====================================================</span><span id="305a" class="no lw it nk b gy nu nq l nr ns">-record(time, {</span><span id="a3a9" class="no lw it nk b gy nu nq l nr ns">   unixtime :: non_neg_integer(),</span><span id="1787" class="no lw it nk b gy nu nq l nr ns">   datetime :: binary()</span><span id="c3d3" class="no lw it nk b gy nu nq l nr ns">}).</span><span id="1b93" class="no lw it nk b gy nu nq l nr ns">-record(time_error, {</span><span id="6b8a" class="no lw it nk b gy nu nq l nr ns">   code :: non_neg_integer(),</span><span id="3039" class="no lw it nk b gy nu nq l nr ns">   error :: term()</span><span id="bbd4" class="no lw it nk b gy nu nq l nr ns">}).</span><span id="c82e" class="no lw it nk b gy nu nq l nr ns">%% =====================================================</span><span id="89be" class="no lw it nk b gy nu nq l nr ns">%%  methods</span><span id="4ef6" class="no lw it nk b gy nu nq l nr ns">%% =====================================================</span><span id="55cc" class="no lw it nk b gy nu nq l nr ns">-record(time_req, {</span><span id="31e4" class="no lw it nk b gy nu nq l nr ns">   opts :: term()</span><span id="3eb2" class="no lw it nk b gy nu nq l nr ns">}).</span><span id="bdb7" class="no lw it nk b gy nu nq l nr ns">-record(time_resp, {</span><span id="e9d1" class="no lw it nk b gy nu nq l nr ns">   result :: #time{} | #time_error{}</span><span id="ce65" class="no lw it nk b gy nu nq l nr ns">}).</span></pre><p id="f5b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们在<strong class="kd iu"> time_controller.erl </strong>中定义服务控制器</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="a686" class="no lw it nk b gy np nq l nr ns">%% The example shows the main code only. If you insert it into gen_server pattern, you will get a proper working service.</span><span id="4ed7" class="no lw it nk b gy nu nq l nr ns">%% gen_server initialization</span><span id="c6de" class="no lw it nk b gy nu nq l nr ns">init(Args) -&gt;</span><span id="ab7d" class="no lw it nk b gy nu nq l nr ns">   %% connection to exchange</span><span id="f68a" class="no lw it nk b gy nu nq l nr ns">   messaging:monitor_exchange(req_resp, ?EXCHANGE, default, self())</span><span id="8b82" class="no lw it nk b gy nu nq l nr ns">   {ok, #{}}.</span><span id="7f9c" class="no lw it nk b gy nu nq l nr ns">%% processing of exchange disconnection events. The same happens if an exchange hasn’t been run yet.</span><span id="5203" class="no lw it nk b gy nu nq l nr ns">handle_info(#exchange_die{exchange = ?EXCHANGE}, State) -&gt;</span><span id="dbaf" class="no lw it nk b gy nu nq l nr ns">   erlang:send(self(), monitor_exchange),</span><span id="564d" class="no lw it nk b gy nu nq l nr ns">   {noreply, State};</span><span id="2486" class="no lw it nk b gy nu nq l nr ns">%% API processing</span><span id="6b17" class="no lw it nk b gy nu nq l nr ns">handle_info(#time_req{opts = _Opts}, State) -&gt;</span><span id="dbbf" class="no lw it nk b gy nu nq l nr ns">   messaging:response_once(Client, #time_resp{</span><span id="e611" class="no lw it nk b gy nu nq l nr ns">      result = #time{ unixtime = time_utils:unixtime(now()),       datetime = time_utils:iso8601_fmt(now())}</span><span id="8598" class="no lw it nk b gy nu nq l nr ns">   });</span><span id="c838" class="no lw it nk b gy nu nq l nr ns">   {noreply, State};</span><span id="9f63" class="no lw it nk b gy nu nq l nr ns">%% gen_server termination</span><span id="f1a6" class="no lw it nk b gy nu nq l nr ns">terminate(_Reason, _State) -&gt;</span><span id="0e1f" class="no lw it nk b gy nu nq l nr ns">   messaging:demonitor_exchange(req_resp, ?EXCHANGE, default, self()),</span><span id="097e" class="no lw it nk b gy nu nq l nr ns">   ok.</span></pre><p id="9a2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">客户端代码放在<strong class="kd iu"> client.erl. </strong>向服务发送请求，我们可以在客户端的任何部分调用消息请求 API:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="c4f5" class="no lw it nk b gy np nq l nr ns">case messaging:request(?EXCHANGE, tag, #time_req{opts = #{}}, self()) of</span><span id="5dd6" class="no lw it nk b gy nu nq l nr ns">    ok -&gt; ok;</span><span id="a2d4" class="no lw it nk b gy nu nq l nr ns">    _ -&gt; %% repeat or fail logic</span><span id="fba9" class="no lw it nk b gy nu nq l nr ns">end</span></pre><p id="c7af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们不知道系统的状态，因为它依赖于请求到达时各种系统组件的状态。当请求到来时，消息传递可能还没有运行，或者服务控制器可能还没有准备好处理请求。这就是为什么我们必须检查消息响应并处理失败。</p><p id="df12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果请求被提交，服务可以用一个响应或一个失败来回答。让我们在<em class="my"> handle_info </em>中处理这两种情况:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="b42a" class="no lw it nk b gy np nq l nr ns">handle_info(#'$msg'{exchange = ?EXCHANGE, tag = tag, message = #time_resp{result = #time{unixtime = Utime}}}, State) -&gt;</span><span id="b7b1" class="no lw it nk b gy nu nq l nr ns">    ?debugVal(Utime),</span><span id="834c" class="no lw it nk b gy nu nq l nr ns">    {noreply, State};</span><span id="39e3" class="no lw it nk b gy nu nq l nr ns">handle_info(#'$msg'{exchange = ?EXCHANGE, tag = tag, message = #time_resp{result = #time_error{code = ErrorCode}}}, State) -&gt;</span><span id="29d8" class="no lw it nk b gy nu nq l nr ns">    ?debugVal({error, ErrorCode}),</span><span id="8f95" class="no lw it nk b gy nu nq l nr ns">    {noreply, State};</span></pre><h1 id="a6f2" class="lv lw it bd lx ly mz ma mb mc na me mf mg nb mi mj mk nc mm mn mo nd mq mr ms bi translated">请求分块响应</h1><p id="b4ca" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">更安全的做法是不要发送太大的消息，因为它们可能会影响系统的总体响应能力和性能。如果一个响应占用了太多的内存，那么拆分就至关重要。</p><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/e392727a3c21601f42e047552a9f2727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/0*qqpR1DD8chGBvO30"/></div></figure><p id="8303" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有几个例子:</p><ul class=""><li id="5fe5" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">组件正在交换二进制数据，例如一些文件。将响应分成小块有助于我们处理任何大小的文件，并防止内存溢出。</li><li id="fbb4" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">清单例如，我们需要选择数据库中巨大表格的所有行，并将其传输到另一个组件。</li></ul><p id="9a10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种反应有时看起来像一列火车。无论如何，1024 条 1mb 的消息比一条 1gb 的消息要好。</p><p id="cf6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Erlang 集群带来了额外的好处，因为响应绕过交换机直接到达接收方，所以减少了交换机和网络的负载。</p><h1 id="7d80" class="lv lw it bd lx ly mz ma mb mc na me mf mg nb mi mj mk nc mm mn mo nd mq mr ms bi translated">带请求的响应</h1><p id="ddfc" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">这是一个非常罕见的构建对话系统的 RPC 模式的修改。</p><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/08c01d1b3d021fffb639f4ad07479b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/0*1EeRLq8ix3ok0mzW"/></div></figure></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="4111" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">发布-订阅(数据分布树)</h1><p id="1745" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">事件驱动系统在数据准备好的时候向用户交付数据。系统更倾向于推模型，而不是拉或轮询模型。这个特性使我们在不断请求和等待数据时不会浪费资源。</p><p id="8b73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该图显示了向订阅某个主题的用户分发消息的过程。</p><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/882b01f8d967aa2e36ac383abf146db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S92ZnrK1PDvxRRgP"/></div></div></figure><p id="2987" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种模式应用的一个经典案例是状态分布:它可以是计算机游戏中的游戏世界、金融交易中的市场数据或数据馈送中的有用信息。</p><p id="1320" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看一下用户代码:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="6970" class="no lw it nk b gy np nq l nr ns">init(_Args) -&gt;</span><span id="eee9" class="no lw it nk b gy nu nq l nr ns">   %% subscribe to exchange, routing key = key</span><span id="1ba3" class="no lw it nk b gy nu nq l nr ns">   messaging:subscribe(?SUBSCRIPTION, key, tag, self()),</span><span id="5a0f" class="no lw it nk b gy nu nq l nr ns">   {ok, #{}}.</span><span id="5a7e" class="no lw it nk b gy nu nq l nr ns">handle_info(#exchange_die{exchange = ?SUBSCRIPTION}, State) -&gt;</span><span id="eaba" class="no lw it nk b gy nu nq l nr ns">    %% if an exchange is unavailable, we are trying to reconnect to it</span><span id="6002" class="no lw it nk b gy nu nq l nr ns">    messaging:subscribe(?SUBSCRIPTION, key, tag, self()),</span><span id="2fd5" class="no lw it nk b gy nu nq l nr ns">    {noreply, State};</span><span id="a7d2" class="no lw it nk b gy nu nq l nr ns">%% process received messages</span><span id="856d" class="no lw it nk b gy nu nq l nr ns">handle_info(#'$msg'{exchange = ?SUBSCRIPTION, message = Msg}, State) -&gt;</span><span id="d7f5" class="no lw it nk b gy nu nq l nr ns">    ?debugVal(Msg),</span><span id="6ae9" class="no lw it nk b gy nu nq l nr ns">    {noreply, State};</span><span id="a973" class="no lw it nk b gy nu nq l nr ns">%% if a consumer stops, disconnect from exchange</span><span id="09f4" class="no lw it nk b gy nu nq l nr ns">terminate(_Reason, _State) -&gt;</span><span id="b922" class="no lw it nk b gy nu nq l nr ns">    messaging:unsubscribe(?SUBSCRIPTION, key, tag, self()),</span><span id="5fa6" class="no lw it nk b gy nu nq l nr ns">    ok.</span></pre><p id="acf0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">发布者可以通过函数调用在任何合适的地方发布消息:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="ba42" class="no lw it nk b gy np nq l nr ns">messaging:publish_message(Exchange, Key, Message)</span></pre><p id="fbd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="my">交易所</em>交易所名称、</p><p id="9ab9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="my">键</em>路由键、</p><p id="06be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="my">信息</em>有效载荷。</p><h1 id="df1c" class="lv lw it bd lx ly mz ma mb mc na me mf mg nb mi mj mk nc mm mn mo nd mq mr ms bi translated">反向发布-订阅</h1><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/ea82460305293c46257256f7e59f5704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yaapxaXcTkMouDpz"/></div></div></figure><p id="05a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们反转发布-订阅时，我们得到一个有利于日志记录的模式。生产者和消费者可以有很大的不同。该图显示了一个消费者和多个生产者的情况。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="7473" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">任务分配模式</h1><p id="b648" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">几乎每个项目都向我们提出了延期处理任务的挑战，比如生成报告、发送通知、从第三方系统获取数据。通过增加工人，系统容量很容易扩展。现在剩下的就是组成一群工人，并在他们之间平均分配任务。</p><p id="72d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们考虑一个有三个工人的例子。在分配任务的阶段，我们面临着分配的公平性和工人超负荷的问题。Round-robin 将负责提供公平性，而 prefetch_limit 将防止工人过载。在临时模式下，prefetch_limit 不允许一个工人获得所有任务。</p><p id="54df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">消息控制队列和处理优先级。工人来了就有任务。任何任务都可以成功完成，也可以失败。</p><ul class=""><li id="ae5b" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><em class="my">消息传递:当消息被成功处理时，ack(Tack) </em>被调用</li><li id="4d1c" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><em class="my">信息:nack(Tack) </em>在所有紧急情况下都会被调用。任务返回后，消息会将其重新发送给另一个工作人员。</li></ul><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/71c7000b3690d54976ce034a036a4698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VZle1dGFgOLeUSsW"/></div></div></figure><p id="8f05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们假设在处理 3 个任务时发生了复杂的故障。工人 1 在获得任务后崩溃，并且未能通知交换。在这种情况下，当<em class="my">确认</em>超时时，交换将任务重定向到另一个工作者。出于某种原因，工人 3 拒绝了该任务并发送了<em class="my"> nack。</em>结果，这个任务被另一个设法完成它的工人处理掉了。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="9f06" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">初步结论</h1><p id="33e0" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">在本文中，我们仔细研究了分布式系统的主要构件。我们还对它们在 Erlang/Elixir 中的实现有了基本的了解。</p><p id="b1d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过组合基本模式，您可以构建复杂的范例来应对新出现的挑战。</p><p id="1680" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一部分将集中在管理服务、路由和平衡的一些一般性问题上。我们还将讨论系统可伸缩性和容错性的实际方面。</p><p id="19c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二部分的结尾。</p><p id="6fba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">照片由<a class="ae kz" href="https://unsplash.com/photos/UXfi8LyqGDk" rel="noopener ugc nofollow" target="_blank">马里乌斯·克里斯滕森</a></p><p id="1688" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用 websequencediagrams.com 制作的插图</p></div></div>    
</body>
</html>