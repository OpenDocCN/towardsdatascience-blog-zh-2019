<html>
<head>
<title>Scraping and Exploring The SP500 with R Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 R 刮和探索 SP500 第 1 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploring-the-sp500-with-r-part-1-scraping-data-acquisition-and-functional-programming-56c9498f38e8?source=collection_archive---------10-----------------------#2019-04-05">https://towardsdatascience.com/exploring-the-sp500-with-r-part-1-scraping-data-acquisition-and-functional-programming-56c9498f38e8?source=collection_archive---------10-----------------------#2019-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="80d4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">刮擦、数据采集和功能编程</h2></div><p id="2a4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天，我想通过一个简单的例子，使用函数式编程和整洁的迭代概念，将抓取、对 Yahoo finance api 的调用、数据连接和简单的资产分析结合起来。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/3378c0f46f33a41a6aac3eeb4c74280c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6-QdVL1GBENc5skt"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">photo credit: <a class="ae lr" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">https://unsplash.com</a></figcaption></figure><h1 id="9745" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最终目标:</h1><p id="1369" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我想确定过去 3 个月哪些 SP500 资产的平均回报率最高。</p><h2 id="69f1" class="mq lt iq bd lu mr ms dn ly mt mu dp mc ko mv mw me ks mx my mg kw mz na mi nb bi translated"><strong class="ak">这个</strong> <a class="ae lr" href="https://medium.com/@Psr1/exploring-the-sp500-with-r-part-2-asset-analysis-657d3c1caf60" rel="noopener"> <strong class="ak">分析的最终结果</strong> </a> <strong class="ak">就是这个图表:</strong></h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="63bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个图表的制作，资产分析，回答我的问题，会在这个系列 的第二部分<a class="ae lr" href="https://medium.com/@Psr1/exploring-the-sp500-with-r-part-2-asset-analysis-657d3c1caf60" rel="noopener"> <strong class="kh ir">中讲到。</strong></a></p><h1 id="f1d8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">介绍和 Tidyverse:</h1><p id="4d88" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在今天的分析中，我将使用 R 编程语言。如果你过去读过我在 Linkedin 或 Medium 上的任何帖子，你可能已经注意到我通常用 python 编程。总的来说，我更喜欢 python 编程语言，因为它的语法更简单，应用更广泛，也更容易投入生产。</p><p id="88da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">潮间带生态系统:</strong></p><p id="a121" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 R 编程语言中，有一组包组成了所谓的<a class="ae lr" href="https://www.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> tidyverse </strong> </a>。这些软件包主要由 Rstudio 的工程师和数据科学家维护，并提供了一种简单、集成和统一的方法来操作 r 中的数据。tidyverse 围绕着<a class="ae lr" href="https://vita.had.co.nz/papers/tidy-data.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">整理数据</strong> </a>这是 Hadley Wickham 创造的一个术语，用来描述数据，其中:</p><ul class=""><li id="23e8" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">每个变量都是一列</li><li id="ad97" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">每个观察(或案例)都是一行</li></ul><p id="a859" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天我将利用几个图书馆。在下面的代码块中，我导入了我将要使用的库。</p><pre class="lc ld le lf gt ns nt nu nv aw nw bi"><span id="9c4e" class="mq lt iq nt b gy nx ny l nz oa"># for scraping<br/>library(rvest)<br/># blanket import for core tidyverse packages<br/>library(tidyverse)<br/># tidy financial analysis <br/>library(tidyquant)<br/># tidy data cleaning functions<br/>library(janitor)</span></pre><p id="705f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我要做的下一件事是用今天的日期定义一个变量。然后我从今天减去 3 个月。这将返回另一个 date 对象，指示 3 个月前的某一天。我需要这个，因为我想得到每个股票最近 3 个月的价格数据。</p><pre class="lc ld le lf gt ns nt nu nv aw nw bi"><span id="9cb3" class="mq lt iq nt b gy nx ny l nz oa"># save current system date to a variable<br/>today &lt;- Sys.Date()<br/># subtract 3 months from the current date<br/>date = today %m+% months(-3)<br/>print(date)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/d3ebcbda23e81859e526e74935d35222.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/1*SOA9vlk0zx1YHNS_TpeFTA.png"/></div></figure><h1 id="88d8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">一个股票</h1><p id="f774" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我将使用 tidyquant 包获取所有 SP500 证券交易所的财务数据。tidyqunat 包的核心函数是 tq_get()，可以用来获取股票的各种信息。如果我将一个包含股票代号的字符串传递给 tq_get()，它将返回开盘、盘高、盘低、收盘或 OHLC 数据。我将 SP500 的报价器^GSPC 传递给 tq_get()函数。</p><pre class="lc ld le lf gt ns nt nu nv aw nw bi"><span id="f75b" class="mq lt iq nt b gy nx ny l nz oa"># pass SP500 ticker ^GSPC to tq_get function<br/>one_ticker = tq_get("^GSPC", from = date)<br/>one_ticker %&gt;% <br/>  head()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oc"><img src="../Images/cf7d5987c55471de7977efc196cea87d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSBIkv74i6uuE_YOhn2Ajg.png"/></div></div></figure><p id="deac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面有几件事需要注意</p><ul class=""><li id="84e0" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">tq_get()返回一个整洁的数据帧</li><li id="b475" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">股票代码名称不在数据帧中</li><li id="7e03" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">%&gt;%运算符称为管道。它将前面的对象作为第一个参数传递给后面的函数。</li></ul><h1 id="5620" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">放大第 1 部分—获得所有 505 个分笔成交点的向量:</h1><p id="b642" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我想要所有 SP500 售票员的 OHLC 数据。为了做到这一点，我需要做几件事:</p><ul class=""><li id="617b" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">创建所有 SP500 证券交易所的向量</li><li id="6081" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">迭代这个向量并对向量的每个元素调用 tq_get()，为向量中的每个元素返回一个 dataframe</li><li id="c185" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">将所有这些数据帧组合成一个数据帧</li></ul><p id="cfbe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哇！听起来有点复杂，对吧？幸运的是，有了 R，这将变得非常简单。维基百科有一个包含所有 505 家 SP500 证券交易所(一些公司，如谷歌，有多个资产类别)的表格，位于以下网址:</p><p id="f878" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">https://en.wikipedia.org/wiki/List_of_S%26P_500_companies<a class="ae lr" href="https://en.wikipedia.org/wiki/List_of_S%26P_500_companies" rel="noopener ugc nofollow" target="_blank"/></p><p id="9447" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了得到所有的 SP500 ticker，我们将使用 rvest 包来清理这个表。rvest 包是 R 中的一个简单的刮包，非常类似于 python 的美汤。在编程的上下文中，抓取被定义为以编程方式从互联网和网页上收集人类可读的内容。</p><p id="d29d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的代码中，我抓取了维基百科表格，并创建了一个包含所有 SP500 证券交易所的向量:</p><ul class=""><li id="8c81" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">我首先将维基百科的 URL 赋给一个变量</li><li id="0c60" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">从 URL 读入 html</li><li id="21af" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">选择正确的 html 节点并提取 html 表格</li><li id="10c8" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">对股票代号做了一个小小的改动，因为雅虎财经用了一个“_”而不是“.”对于某些符号名称</li></ul><p id="e60e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">抓取最困难的部分是找出 xpath 或 css 来指示选择哪些 html 节点。我真的不太了解 html 或 css，但是使用 Google Chrome 我能够找到正确的 xpath(下面会有更多相关内容)。</p><pre class="lc ld le lf gt ns nt nu nv aw nw bi"><span id="3964" class="mq lt iq nt b gy nx ny l nz oa"># get the URL for the wikipedia page with all SP500 symbols<br/>url &lt;- "<a class="ae lr" href="https://en.wikipedia.org/wiki/List_of_S%26P_500_companies" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/List_of_S%26P_500_companies</a>"<br/># use that URL to scrape the SP500 table using rvest<br/>tickers &lt;- url %&gt;%<br/>  # read the HTML from the webpage<br/>  read_html() %&gt;%<br/>  # one way to get table<br/>  #html_nodes(xpath='//*[<a class="ae lr" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>="mw-content-text"]/div/table[1]') %&gt;%<br/>  # easier way to get table<br/>  html_nodes(xpath = '//*[<a class="ae lr" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>="constituents"]') %&gt;% <br/>  html_table()<br/>#create a vector of tickers<br/>sp500tickers &lt;- tickers[[1]]<br/>sp500tickers = sp500tickers %&gt;% mutate(Symbol = case_when(Symbol == "BRK.B" ~ "BRK-B",<br/>                                           Symbol == "BF.B" ~ "BF-B",<br/>                                            TRUE ~ as.character(Symbol)))</span></pre><h2 id="0214" class="mq lt iq bd lu mr ms dn ly mt mu dp mc ko mv mw me ks mx my mg kw mz na mi nb bi translated">如何使用 Google Chrome 找到我传递给 html_nodes 函数的 xpath:</h2><ul class=""><li id="8828" class="ne nf iq kh b ki mk kl ml ko od ks oe kw of la nj nk nl nm bi translated">去 https://en.wikipedia.org/wiki/List_of_S%26P_500_companies<a class="ae lr" href="https://en.wikipedia.org/wiki/List_of_S%26P_500_companies" rel="noopener ugc nofollow" target="_blank"/></li><li id="4155" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">右击网页，选择检查选项</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi og"><img src="../Images/1daf3191c51ecd423cc3ba2e0d1096d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*38DmIWFgt4aVg7FzhM2uCg.png"/></div></figure><ul class=""><li id="e522" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">大多数网页内容通常在 html 文档的主体中。我们会扩大那部分。看起来会像这样:</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/bc0aaa5f7496e443cb81c30d37683377.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*GnDShJcWHEfLP0ghj8OctQ.png"/></div></figure><ul class=""><li id="41ea" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">查看网页时，我可以看到我想要的表格就在第一个 h2 标题的下方:</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oi"><img src="../Images/d6ff94745951160d9eccb4812a710710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zhge3H80lHcdSsLT7YM3dA.png"/></div></div></figure><ul class=""><li id="dc87" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">在浏览了页面结构后，我找到了第一个 h2 标题和我想要放在它下面的表格</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/61b3baf710bf341678170135e4fc8633.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*LErvj_goGgW_evZ7zsuDZw.png"/></div></figure><ul class=""><li id="bb33" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">我可以点击这个表，右键点击并复制这个表所需要的 xpath</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/55bb56456e2263d19ede6eba168420fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*tloKkE86Rm0M2VOVVc6Lcg.png"/></div></figure><ul class=""><li id="1bc7" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">XPath =//*[<a class="ae lr" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@ id</a>= " constituents "]，这就是传递给 html_nodes 的内容</li></ul><pre class="lc ld le lf gt ns nt nu nv aw nw bi"><span id="7034" class="mq lt iq nt b gy nx ny l nz oa">html_nodes(xpath = '//*[<a class="ae lr" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>="constituents"]'</span></pre><h1 id="598d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">向上扩展第 2 部分— Purrr、迭代和函数式编程:</h1><p id="dc1b" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">迭代是指以编程方式重复一个步骤或一组步骤，重复一定的次数，或者直到达到某个条件。</p><p id="e03b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，当我们在任何编程语言中迭代时，我们使用循环，通常是 for 循环。我需要迭代 SP500 ticker 向量中的每个元素，并将其传递给函数 tq_get()。我可以用 for 循环做到这一点，但是使用 purrr 包是一个更好的主意。R 中的循环很慢，很难读懂。purrr 包提供了一套用于迭代和函数式编程的函数，可以很好地与 tidyverse 的其余部分集成。map()中 purrr 的核心函数。大多数编程语言(包括我最喜欢的一个 python)都有一个 map 函数，用于将一个函数应用于一个对象的所有元素。</p><p id="7ce5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">函数式编程</strong>是一种编程范式，与<a class="ae lr" href="https://softwareengineering.stackexchange.com/questions/179965/functional-programming-compared-to-oop-with-classes" rel="noopener ugc nofollow" target="_blank">类</a>相反，函数构建程序的结构和逻辑。在函数式编程中，通常避免使用 For 循环。相反，函数被映射或应用于列表或其他对象。</p><p id="601b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如哈德利·韦翰在他的《高级 R 书》中所说:</p><p id="e3e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“很难准确描述什么是功能性<em class="mp">风格</em>，但通常我认为它意味着将一个大问题分解成更小的部分，然后用一个功能或功能组合来解决每个部分。当使用函数式风格时，您努力将问题的组成部分分解成独立操作的孤立函数。每个函数本身都简单易懂；复杂性是通过以各种方式组合函数来处理的。”</p><p id="c840" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用一个例子来看看 purrr 中的迭代和 for 循环的区别。这两种操作大致相同:</p><pre class="lc ld le lf gt ns nt nu nv aw nw bi"><span id="ff2b" class="mq lt iq nt b gy nx ny l nz oa"># get a sequence of the numbers 1 to 5<br/>numbers = seq(1:5)<br/>print('for loop')</span><span id="d363" class="mq lt iq nt b gy ol ny l nz oa"># for loop <br/>for (i in numbers){<br/>  <br/>  print(i)<br/>}</span><span id="2ad2" class="mq lt iq nt b gy ol ny l nz oa">print('purrr :)')</span><span id="9430" class="mq lt iq nt b gy ol ny l nz oa"># purr functional programming approach<br/>list = map(numbers, print)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi om"><img src="../Images/d0fdb688e88fd15d235bd735fabb450e.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*ypS2rbPj-4wAiCaWancCxQ.png"/></div></figure><p id="66c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">需要注意的几件事:</strong></p><ul class=""><li id="8412" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">for 循环和 map 函数都对向量中的每个元素进行运算<strong class="kh ir"/></li><li id="c8ea" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">map 函数返回一个嵌套的列表，其中每个条目都是在该列表中调用的函数的结果，该函数针对的是被迭代的对象中的一个条目。我把它赋给一个变量列表，以避免它被打印出来。</li><li id="849d" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">使用 purrr 的 map 函数只需要一行代码和很少的代码</li><li id="7700" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">使用 purrr 的地图功能更容易阅读</li></ul><h2 id="222b" class="mq lt iq bd lu mr ms dn ly mt mu dp mc ko mv mw me ks mx my mg kw mz na mi nb bi translated">好吧，现在让我们迭代得到所有 505 SP500 ticker！</h2><p id="8d4e" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">首先，我需要编写一个函数来迭代或应用到向量的每个元素。我不能简单地将 tq_get()与 map()一起使用，因为它不会将 ticker 名称作为 dataframe 的一列返回。为了获得带有数据帧的 ticker，我将使用 dplyr 中的 mutate()函数创建一个带有 ticker 名称的新列。</p><pre class="lc ld le lf gt ns nt nu nv aw nw bi"><span id="46b7" class="mq lt iq nt b gy nx ny l nz oa">get_symbols = function(ticker = "AAPL"){<br/>  df = tq_get(ticker, from = date) %&gt;% mutate(symbol = rep(ticker, length(date)))<br/>}</span></pre><p id="606f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我将这个函数与 map()结合使用来遍历所有符号的列表。这将返回一个嵌套列表，其中包含每个 ticker 的数据帧。我使用 dplyr bind_rows()函数将数据帧按行绑定在一起，创建一个包含所有 SP500 报价机的数据帧。</p><pre class="lc ld le lf gt ns nt nu nv aw nw bi"><span id="0600" class="mq lt iq nt b gy nx ny l nz oa">#create the dataframe of SP500 data by interating over our list of symbols and call our get symbols function each time<br/>#the map function accomplishes this</span><span id="07a0" class="mq lt iq nt b gy ol ny l nz oa">tickers_df = map(symbols, get_symbols) %&gt;% bind_rows()</span></pre><p id="45a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还希望这个数据帧包含来自维基百科表的信息，最重要的是公司的名称。这可以通过用符号连接两个数据帧来实现。</p><pre class="lc ld le lf gt ns nt nu nv aw nw bi"><span id="c337" class="mq lt iq nt b gy nx ny l nz oa">tickers_df = tickers_df %&gt;% <br/>  # left join with wikipedia data<br/>  left_join(sp500tickers, by = c('symbol' = 'Symbol')) %&gt;% <br/>  # make names R compatible<br/>  clean_names() %&gt;% <br/>  # keep only the columns we need<br/>  select(date:security, gics_sector, gics_sub_industry)</span></pre><p id="d077" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">加入数据后，我们应该做一个快速的健全检查，以确保我们有所有 505 SP500 ticker</p><pre class="lc ld le lf gt ns nt nu nv aw nw bi"><span id="6a68" class="mq lt iq nt b gy nx ny l nz oa">tickers_df %&gt;% <br/># select just the symbol column<br/>select(symbol)%&gt;% <br/># get the distinct values<br/>distinct()%&gt;% <br/># count the distinct values <br/>count() %&gt;% <br/># we can use select to rename columns <br/>select("Total Number of Tickers" = n)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi on"><img src="../Images/d4ee3f52f334c32cb93d4a9571b59582.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*zEuOR28-CKUdPB2muee4fA.png"/></div></figure><p id="7498" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以检查数据帧的前几行，以确认我们已经获得了想要的数据:</p><pre class="lc ld le lf gt ns nt nu nv aw nw bi"><span id="27a1" class="mq lt iq nt b gy nx ny l nz oa">tickers_df %&gt;% <br/>  head()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oo"><img src="../Images/f7ebda5b66809a600e671c9f5ee50a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wMaG5dh-jCOuInpBV-ijNg.png"/></div></div></figure><p id="9664" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完美！正如我们所料。</p><p id="48bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">总结:</strong></p><p id="4a9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一篇博文中，我们有:</p><ul class=""><li id="9397" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">了解了 tidyverse 生态系统和 tidyquant 的基础知识</li><li id="92b2" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">学习了整洁迭代和函数式编程的基础知识</li><li id="cc62" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">学会了如何利用 rvest 和 chrome 从维基百科收集数据</li><li id="973b" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">学会了如何从阅读单一资产转移到整个 SP500</li></ul><p id="7d38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">中的</strong> <a class="ae lr" href="https://medium.com/@Psr1/exploring-the-sp500-with-r-part-2-asset-analysis-657d3c1caf60" rel="noopener">中的<strong class="kh ir">下一篇</strong> </a> <strong class="kh ir"> : </strong></p><p id="cb92" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我来回答我原来的问题:</p><p id="6da0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">过去 3 个月，哪些 SP500 资产的平均回报率最高？</strong></p><p id="7065" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意一些事情:</p><ul class=""><li id="eaad" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">使用 TQ _ index(“SP500”)，您可以更容易地获得所有 SP500 股票的列表。这个函数需要 XLConnect 库。我目前在本地机器上导入并运行这个库时遇到了问题。</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="ab gu cl op"><img src="../Images/88d7d2cc992803e45faef60f42c02cf9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*kkScs3UM5wBWw6XvdQHo6g.png"/></div></figure><ul class=""><li id="f1fe" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">tq_get()实际上接受报价器列表，所以没有必要使用 map()</li><li id="7504" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">我有意以这种方式编写代码，以演示所描述的概念</li></ul><p id="2eeb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">声明:在大学里，我用 SP500 数据和 python 做了一个项目。分享这个项目是违反班级政策的。虽然我在这里做的事情有些类似，但我使用的是完全不同的编程语言，回答的是完全不同的问题。鉴于我之前陈述，我断言这并不违反课程政策。我有意使用 R 编程语言，而不是 python，以完全避免任何问题，并尊重我以前的教授的意愿。</p><p id="3dbf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lr" href="https://github.com/pysr1/medium_sp500" rel="noopener ugc nofollow" target="_blank">代码可以在这里找到</a></p><p id="9069" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是另一个关于抓取的很好的资源，对写这篇文章有一点帮助。</p><p id="6a0b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lr" href="https://medium.com/@kyleake/wikipedia-data-scraping-with-r-rvest-in-action-3c419db9af2d" rel="noopener">https://medium . com/@ ky leake/Wikipedia-data-scraping-with-r-rvest-in-action-3c 419 db 9 af 2d https://medium . com/@ ky leake/Wikipedia-data-scraping-with-r-rvest-in-action-3c 419 db 9 af 2d</a></p></div><div class="ab cl oq or hu os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ij ik il im in"><p id="0bba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="mp">注来自《走向数据科学》的编辑:</em> </strong> <em class="mp">虽然我们允许独立作者根据我们的</em> <a class="ae lr" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="mp">规则和指导方针</em> </a> <em class="mp">发表文章，但我们不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae lr" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="mp">读者术语</em> </a> <em class="mp">。</em></p></div></div>    
</body>
</html>