<html>
<head>
<title>Dealing with Missing Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理缺失数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dealing-with-missing-data-17f8b5827664?source=collection_archive---------20-----------------------#2019-07-28">https://towardsdatascience.com/dealing-with-missing-data-17f8b5827664?source=collection_archive---------20-----------------------#2019-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3dec5df566649760c678e01b354ae176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FqLrsmS1F0q8yhguBw9q5w.jpeg"/></div></div></figure><p id="8c39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi kz translated"><span class="l la lb lc bm ld le lf lg lh di">我</span>最近完成了一个使用机器学习预测宫颈癌的项目 Jupyter 笔记本和所有相关的原始资料都可以在这个 GitHub <a class="ae li" href="https://github.com/giorosati/dsc-3-final-project-online-ds-pt-100118" rel="noopener ugc nofollow" target="_blank"> repo </a>中找到。该项目的挑战之一是如何处理许多预测变量中的缺失值。本文描述了我是如何处理这些缺失数据的。</p><p id="ca7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">许多机器学习模型在遇到缺失数据时会抛出一个错误，并且有许多方法(和观点！)用于处理缺失值。最简单的方法之一是用某个特定变量的平均值来填充缺失值，我见过很多项目都是采用这种方法。它又快又简单，有时还能有好的效果。更困难的是，通过比较缺失值的记录和没有缺失该因子值的类似记录，使用复杂的方法来估算缺失值。每种方法都有优点和缺点，在我看来，最好的选择总是根据具体情况而定。</p><p id="81ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于这是我的第一个涉及重大缺失值的机器学习项目，我决定采取一种容易解释的方法，即逐个查看每个因素，以更好地了解每个因素的分布。为此，我查看了计数图、箱线图和中心性度量(均值、中值、众数)。在评估这些信息后，我使用了以下一种或多种方法来处理缺失的信息:</p><ol class=""><li id="53c8" class="lj lk it kd b ke kf ki kj km ll kq lm ku ln ky lo lp lq lr bi translated">如果因子缺少很大比例记录的值，请从数据集中删除该因子。</li><li id="9e16" class="lj lk it kd b ke ls ki lt km lu kq lv ku lw ky lo lp lq lr bi translated">如果一小部分记录缺少某个因子的值，请删除这些记录。</li><li id="dc05" class="lj lk it kd b ke ls ki lt km lu kq lv ku lw ky lo lp lq lr bi translated">向分类因子添加新选项。例如，如果因子有三个值:“val_1”、“val_2”、“val_3”，则可以添加一个额外的“未知”值。现在，因子将有四个值:“val_1”、“val_2”、“val_3”和“未知”。</li><li id="9901" class="lj lk it kd b ke ls ki lt km lu kq lv ku lw ky lo lp lq lr bi translated">将布尔因子转换为具有 3 个可能值的分类因子:“真”、“假”和“未知”。</li><li id="7760" class="lj lk it kd b ke ls ki lt km lu kq lv ku lw ky lo lp lq lr bi translated">创建一个新的布尔因子，将每条记录分类为包含(或不包含)有关该因子的信息。当然，这使得原始因子中的值仍然缺少一些信息。在这种情况下，原始因子的缺失值将使用剩余选项之一来填充。</li><li id="afc8" class="lj lk it kd b ke ls ki lt km lu kq lv ku lw ky lo lp lq lr bi translated">用该因子的平均值、中值或众数填充缺失值。</li><li id="59c6" class="lj lk it kd b ke ls ki lt km lu kq lv ku lw ky lo lp lq lr bi translated">用该因子中已经存在的值之一填充缺失的布尔值或分类值。可以使用因子中出现的每个值的相同比例来随机分配该值，或者如果有一个值出现频率最高，则缺失的值可以用最常见的值来填充。</li></ol><p id="a3b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我所处理的数据集中的因子的概述，显示了每个因子的缺失数据百分比，红色文本表示某个因子缺失信息。该信息最初是在委内瑞拉加拉加斯的“加拉加斯大学医院”收集的，由 35 个变量组成，包括 858 名患者的人口统计信息、习惯和历史医疗记录。出于隐私考虑，一些患者决定不回答一些问题，因此产生了缺失值。该数据集来自于 2017 年 5 月首次在线发表的一篇研究论文。</p><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lx"><img src="../Images/a9c746cfc443b615051b6f79b5505e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndsuXhbgY08_dD_xZO0Tlg.png"/></div></div></figure><p id="a166" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大多数变量都缺少数据，包括具有布尔值和数值的变量。因为我的策略涉及为多个因素重复创建相同的图和统计数据，所以我为此创建了一个函数:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="fdc1" class="mh mi it md b gy mj mk l ml mm">def countplot_boxplot(column, df):<br/>    fig = plt.figure(figsize=(15,20))<br/>    fig.suptitle(column, size=20)<br/>    <br/>    ax1 = fig.add_subplot(2,1,1)<br/>    sns.countplot(dataframe[column])<br/>    plt.xticks(rotation=45)</span><span id="1441" class="mh mi it md b gy mn mk l ml mm">ax2 = fig.add_subplot(2,1,2)<br/>    sns.boxplot(dataframe[column])<br/>    plt.xticks(rotation=45)<br/>    plt.show()<br/>    <br/>    print('Min:', dataframe[column].min())<br/>    print('Mean:', dataframe[column].mean())<br/>    print('Median:', dataframe[column].median())<br/>    print('Mode:', dataframe[column].mode()[0])<br/>    print('Max:', dataframe[column].max())<br/>    print('**********************')<br/>    print('% of values missing:', (dataframe[column].isna().sum() / len(dataframe))*100)</span></pre><p id="cce5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于我想要创建一个新的布尔因子的情况，我创建了一个函数:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="0b23" class="mh mi it md b gy mj mk l ml mm">def new_bool(df, col_name):<br/>    bool_list = []<br/>    for index, row in df.iterrows():<br/>        value = row[col_name]<br/>        value_out = 1<br/>        if pd.isna(value):<br/>            value_out = 0</span><span id="1a6f" class="mh mi it md b gy mn mk l ml mm">    bool_list.append(value_out)</span><span id="28ca" class="mh mi it md b gy mn mk l ml mm">    return bool_list</span></pre><p id="8578" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我还创建了几个简单的函数，使传递列名作为参数来填充缺失值变得容易:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="d249" class="mh mi it md b gy mj mk l ml mm"># function to replace missing values with the median</span><span id="5408" class="mh mi it md b gy mn mk l ml mm">def fillna_median(column, dataframe):<br/>    dataframe[column].fillna(dataframe[column].median(), inplace=True)<br/>    print (dataframe[column].value_counts(dropna=False))<br/>    <br/>    <br/># function to replace missing values with the mean</span><span id="c799" class="mh mi it md b gy mn mk l ml mm">def fillna_mean(column, dataframe):<br/>    dataframe[column].fillna(dataframe[column].mean(), inplace=True)<br/>    print (dataframe[column].value_counts(dropna=False))</span><span id="aa62" class="mh mi it md b gy mn mk l ml mm"># function to replace missing values with a value provided</span><span id="8937" class="mh mi it md b gy mn mk l ml mm">def fillna_w_value(value, column, dataframe):<br/>    dataframe[column].fillna(value, inplace=True)<br/>    print(dataframe[column].value_counts(dropna=False))</span></pre></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="dfcd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看一个因子的例子，我创建了一个新的布尔因子，然后用中值填充原始因子中缺少的值。首先，我将运行 countplot_boxplot 函数:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="7ac1" class="mh mi it md b gy mj mk l ml mm">countplot_boxplot('Number of sexual partners', df2)</span></pre><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/acb8378ef66339c972223bbb9d374426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMyI2od0DOqlVcnZFQY11w.png"/></div></div></figure><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6d9b" class="mh mi it md b gy mj mk l ml mm">Min: 1.0<br/>Mean: 2.527644230769231<br/>Median: 2.0<br/>Mode: 2.0<br/>Max: 28.0<br/>**********************<br/>% of values missing: 3.0303030303030303</span></pre><p id="471a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在选择如何填充缺失的信息之前，我希望保留包含在 3%的记录中的信息，这些记录缺失了该因子的值。通过调用上面显示的函数，我创建了一个名为“is_number_partners_known”的新布尔因子:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="b610" class="mh mi it md b gy mj mk l ml mm">df['is_number_partners_known'] = new_bool(df, 'Number of sexual partners')</span></pre><p id="9dfa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然我已经获得了这些信息，我就来看看源因素的分布。平均值和众数都是 2.0，但是平均值被上限值的异常值拉高了。我选择用中位数(2.0)来填充缺失的值。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f4b5" class="mh mi it md b gy mj mk l ml mm">fillna_median('Number of sexual partners', df2)</span></pre></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="e15e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们来看一个具有非常偏斜的分布和高得多的缺失值百分比的因子。同样，首先我运行我的函数来查看分布。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="5fa4" class="mh mi it md b gy mj mk l ml mm">countplot_boxplot('Hormonal Contraceptives (years)', df2)</span></pre><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/e5c1aef47fd41323f7af5745f35854ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4EOYT1BVsfN0oINHOgTe3Q.png"/></div></div></figure><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="ae62" class="mh mi it md b gy mj mk l ml mm">Min: 0.0<br/>Mean: 2.2564192013893343<br/>Median: 0.5<br/>Mode: 0.0<br/>Max: 30.0<br/>**********************<br/>% of values missing: 12.587412587412588</span></pre><p id="3bc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止，零是该因素最常见的值，然而该值的范围长达 30 年，在该范围的较高区域有几个异常值。这些高异常值将平均值拉得远远高于中值。可以使用众数(0)或中位数(0.5)来填充缺失值。由于超过 12%的记录缺少某个值，因此该选择可能会对模型的性能产生重大影响，尤其是当该因素在给定的预测模型中很重要时。我选择用模式(0)填充缺失的值。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="55db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于最后一个示例，我们来看两个单独的布尔标准因子:</p><ul class=""><li id="636f" class="lj lk it kd b ke kf ki kj km ll kq lm ku ln ky mw lp lq lr bi translated">性病:结肠瘤病</li><li id="9bad" class="lj lk it kd b ke ls ki lt km lu kq lv ku lw ky mw lp lq lr bi translated">性病:艾滋病</li></ul><p id="648c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个布尔因子(“STDs”，也是布尔型)的“父”列与其所有“子”列具有相同的缺失值百分比(大约 12%)。我之前选择用 False(零)填充父因子的缺失值。然后，我选择用 False(零)填充所有“儿童”因素(每个因素代表一种不同的性传播疾病)中缺失的值。后来，当我为数据集中的所有因素运行相关矩阵时，我注意到有两行是空白的。这就是我如何发现在这两个因素中，零是唯一发生的价值。这些因素中的原始数据只有假(零)或缺失。当我用零填充缺失值时，因子不包含任何信息，因为每个记录都有相同的 False 值。我选择从数据集中删除这两个因素。</p><p id="693b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在对所有因素重复上述过程之后，我检查了整个数据库中 NaN 的计数:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="e7dd" class="mh mi it md b gy mj mk l ml mm">df2.isna().sum()</span></pre><p id="1798" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面的输出显示不再有丢失的值——这正是我需要看到的。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="c719" class="mh mi it md b gy mj mk l ml mm">Age                                   0<br/>Number of sexual partners             0<br/>First sexual intercourse              0<br/>Num of pregnancies                    0<br/>Smokes                                0<br/>Smokes (years)                        0<br/>Smokes (packs/year)                   0<br/>Hormonal Contraceptives               0<br/>Hormonal Contraceptives (years)       0<br/>IUD                                   0<br/>IUD (years)                           0<br/>STDs                                  0<br/>STDs (number)                         0<br/>STDs:condylomatosis                   0<br/>STDs:vaginal condylomatosis           0<br/>STDs:vulvo-perineal condylomatosis    0<br/>STDs:syphilis                         0<br/>STDs:pelvic inflammatory disease      0<br/>STDs:genital herpes                   0<br/>STDs:molluscum contagiosum            0<br/>STDs:HIV                              0<br/>STDs:Hepatitis B                      0<br/>STDs:HPV                              0<br/>STDs: Number of diagnosis             0<br/>STDs: Time since first diagnosis      0<br/>STDs: Time since last diagnosis       0<br/>Dx:Cancer                             0<br/>Dx:CIN                                0<br/>Dx:HPV                                0<br/>Dx                                    0<br/>Hinselmann                            0<br/>Schiller                              0<br/>Citology                              0<br/>Biopsy                                0<br/>is_number_partners_known              0<br/>is_first_intercourse_known            0<br/>is_number_pregnancies_known           0<br/>dtype: int64</span></pre><p id="f262" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据现在已经准备好被分成训练组和测试组，用于我将要探索的监督学习模型。更多信息，请看这里的 Jupyter 笔记本<a class="ae li" href="https://github.com/giorosati/dsc-3-final-project-online-ds-pt-100118" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="2460" class="mh mi it bd mx my mz dn na nb nc dp nd km ne nf ng kq nh ni nj ku nk nl nm nn bi translated">数据集引用:</h2><p id="ae03" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">凯尔温·费尔南德斯、海梅·卡多佐和杰西卡·费尔南德斯。具有部分可观察性的迁移学习应用于宫颈癌筛查。伊比利亚模式识别和图像分析会议。斯普林格国际出版公司，2017 年。<a class="ae li" href="https://archive.ics.uci.edu/ml/datasets/Cervical+cancer+%28Risk+Factors%29" rel="noopener ugc nofollow" target="_blank">https://archive . ics . UCI . edu/ml/datasets/宫颈癌+癌症+% 28 风险+因素%29# </a></p></div></div>    
</body>
</html>