<html>
<head>
<title>Time Intelligence calculations in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R 中的时间智能计算</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-intelligence-in-r-1216e4a3c547?source=collection_archive---------28-----------------------#2019-12-17">https://towardsdatascience.com/time-intelligence-in-r-1216e4a3c547?source=collection_archive---------28-----------------------#2019-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ab1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是时间智能？</h2></div><h1 id="da0a" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">什么是时间智能？</h1><p id="8312" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">时间智能只是在日期或时间周期内进行计算。例如，您可能会收到一个常见的请求，即获取一年中按月汇总的总销售额，或者计算产品的 YTD 总销售额和去年同期的销售额，以比较和计算增长。根据我自己的实践经验，我将分享一些在 R 中使用<strong class="lc iu"> tidyverse </strong>和<strong class="lc iu"> lubridate </strong>包进行这些计算的方法</p><h2 id="167d" class="lw kj it bd kk lx ly dn ko lz ma dp ks lj mb mc ku ln md me kw lr mf mg ky mh bi translated">阅读和准备我们的数据集</h2><p id="8a33" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本练习中，我在 Excel 中创建了一个虚拟数据集。该数据集包含从 2017 年 1 月 2 日到 2019 年 9 月 30 日的销售额</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1ab6" class="lw kj it mn b gy mr ms l mt mu">library(tidyverse) #Data manipulation<br/>library(lubridate) #For working with date and time<br/></span><span id="f081" class="lw kj it mn b gy mv ms l mt mu">sale_data &lt;- read_xlsx("C:\\Users\\ACER\\Desktop\\regression_test.xlsx") %&gt;% <br/>    mutate(Date = ymd(Date))</span></pre><ul class=""><li id="bcdd" class="mw mx it lc b ld my lg mz lj na ln nb lr nc lv nd ne nf ng bi translated">使用<strong class="lc iu"> read_xlsx </strong>函数读入我们的数据集</li><li id="8ba5" class="mw mx it lc b ld nh lg ni lj nj ln nk lr nl lv nd ne nf ng bi translated">在<strong class="lc iu"> mutate </strong>函数中，我们传递了<strong class="lc iu"> ymd </strong>函数来将我们的<strong class="lc iu"> Date </strong>列转换为 Date 类型</li></ul><figure class="mi mj mk ml gt nn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/fc7ac28d7cd840f607e79025866fa0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*sgg9OVsXKRD8spOfwAsovQ.png"/></div></figure><ul class=""><li id="6fef" class="mw mx it lc b ld my lg mz lj na ln nb lr nc lv nd ne nf ng bi translated">这是我们数据集的样子</li></ul><h2 id="4b46" class="lw kj it bd kk lx ly dn ko lz ma dp ks lj mb mc ku ln md me kw lr mf mg ky mh bi translated">一些基本计算</h2><p id="c376" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们从一些基本的时间智能计算开始。您可能会收到的一个常见请求是显示每月的总销售额</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="8ae2" class="lw kj it mn b gy mr ms l mt mu">sale_data %&gt;% <br/>    group_by(Year=year(Date),Month=month(Date,label = T)) %&gt;% <br/>    summarise(total_sales=sum(Offered_Calls,na.rm = T))</span></pre><ul class=""><li id="d0b7" class="mw mx it lc b ld my lg mz lj na ln nb lr nc lv nd ne nf ng bi translated">在<strong class="lc iu"> group_by </strong>之后，我创建了<strong class="lc iu">年</strong>和<strong class="lc iu">月</strong>列，之后使用<strong class="lc iu">summary</strong>函数得到<strong class="lc iu"> total_sales </strong>。还有另一种方法也是一样</li></ul><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="c2ba" class="lw kj it mn b gy mr ms l mt mu">sale_data %&gt;% <br/>    group_by(Monthly=floor_date(Date,unit = "1 month")) %&gt;% <br/>    summarise(total_sales=sum(Offered_Calls,na.rm = T))</span></pre><ul class=""><li id="3504" class="mw mx it lc b ld my lg mz lj na ln nb lr nc lv nd ne nf ng bi translated">基本上，我使用 lubdridate 的<strong class="lc iu"> floor_date </strong>函数将日期列四舍五入到最近的月份，然后计算<strong class="lc iu">总销售额</strong></li></ul><figure class="mi mj mk ml gt nn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/28a96536ca679467e33afece159cae8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*V_LluJ3zeiZ6pbkEcfYdlA.png"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Code output</figcaption></figure><p id="02f5" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj nv ll lm ln nw lp lq lr nx lt lu lv im bi translated">如果有人要求 2019 年 1 月至 6 月的总销售额，并与去年同期进行比较以查看变化，会怎么样？</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="22af" class="lw kj it mn b gy mr ms l mt mu">sale_data %&gt;%<br/>    <strong class="mn iu">summarise</strong>(sales_2019 = <strong class="mn iu">sum</strong>(Offered_Calls[Date <strong class="mn iu">%within% interval</strong>("2019-01-01","2019-06-30")],na.rm = T),<br/>              sales_2018 = <strong class="mn iu">sum</strong>(Offered_Calls[Date<strong class="mn iu"> %within%</strong> <strong class="mn iu">interval</strong>("2018-01-01","2018-06-30")],na.rm = T))</span></pre><p id="db41" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj nv ll lm ln nw lp lq lr nx lt lu lv im bi translated">所以基本上我使用了<strong class="lc iu"> lubridate </strong>包中的<strong class="lc iu">%</strong></p><h2 id="de06" class="lw kj it bd kk lx ly dn ko lz ma dp ks lj mb mc ku ln md me kw lr mf mg ky mh bi translated">更高级的计算</h2><p id="4ed3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是，如果您正在处理一个实时数据集呢？您不希望每次运行定期报告时都要更新代码，以考虑最新的日期参数。对此我也有一个很好的解决方案</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="86ad" class="lw kj it mn b gy mr ms l mt mu">sale_data %&gt;%<br/>    <strong class="mn iu">summarise</strong>(sales_current_mtd = <strong class="mn iu">sum</strong>(Offered_Calls[Date <strong class="mn iu">%within% interval</strong>(<strong class="mn iu">cut</strong>(<strong class="mn iu">Sys.Date()</strong>,"month"),<strong class="mn iu">Sys.Date()</strong>)],na.rm = T),<br/>              same_period_last_year = sum(Offered_Calls[Date <strong class="mn iu">%within% interval</strong>(<strong class="mn iu">cut</strong>(<strong class="mn iu">Sys.Date()-years(1),"month"</strong>),<strong class="mn iu">Sys.Date()-years(1)</strong>)],na.rm = T))</span></pre><p id="2586" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj nv ll lm ln nw lp lq lr nx lt lu lv im bi translated">这和之前的公式是一样的。唯一的变化是，我将<strong class="lc iu"> interval </strong>函数中的日期参数替换为在您运行报告或刷新数据时自动计算所需日期间隔的函数。让我们来分解一下:</p><ul class=""><li id="4188" class="mw mx it lc b ld my lg mz lj na ln nb lr nc lv nd ne nf ng bi translated"><strong class="lc iu">切割(系统。Date()，" month") </strong>将销售日期与最接近的月份相加，这样您将总是得到每个月的第一天</li><li id="e3cf" class="mw mx it lc b ld nh lg ni lj nj ln nk lr nl lv nd ne nf ng bi translated"><strong class="lc iu"> Sys。Date() </strong>基本上只是获取当前日期。因此，在<strong class="lc iu"> interval </strong>函数中输入这两个参数，您将获得从每个月的月初到月末的时间间隔，从而得出 MTD 的总数</li><li id="9f13" class="mw mx it lc b ld nh lg ni lj nj ln nk lr nl lv nd ne nf ng bi translated">要获得去年同期的总数，只需添加一个额外的参数。将两个时间间隔的<strong class="lc iu">年(-1) </strong>函数相加，将得到相同的时间间隔，但是是去年的时间间隔，从而得到去年 MTD 的总数</li></ul><p id="a73a" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj nv ll lm ln nw lp lq lr nx lt lu lv im bi translated">我将展示另一个例子，在这个例子中，您必须按年度粒度(如 YTD)进行计算，这将展示这种计算的灵活性</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ef5a" class="lw kj it mn b gy mr ms l mt mu">sale_data %&gt;%<br/>    <strong class="mn iu">summarise</strong>(sales_ytd = <strong class="mn iu">sum</strong>(Offered_Calls[Date <strong class="mn iu">%within% interval(cut(Sys.Date()</strong>,"year"),<strong class="mn iu">Sys.Date()</strong>)],na.rm = T),<br/>              same_period_last_year = <strong class="mn iu">sum</strong>(Offered_Calls[Date <strong class="mn iu">%within% interval(cut(Sys.Date()-years(1)</strong>,"year"),<strong class="mn iu">Sys.Date()-years(1))</strong>],na.rm = T))</span></pre><ul class=""><li id="4fb3" class="mw mx it lc b ld my lg mz lj na ln nb lr nc lv nd ne nf ng bi translated">这里唯一的不同是我在<strong class="lc iu"> cut </strong>函数中把参数从“月”改成了“年”。这将日期推至年初。这使我们能够计算当前和去年的 YTD</li></ul><h1 id="b1dc" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结论</h1><p id="4bb4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这些是我在工作中用来在 r 中进行“时间智能”计算的一些解决方案。我展示了用于一次性特别请求的手动过程和用于定期报告的自动解决方案。虽然我的例子只包括每年、每月的计算，但是通过遵循我所展示的相同原则，您可以在任何级别上进行计算，如每周、每天和每季度。我发现这个解决方案对于计算必须在我们的周/月/季度报告中定期更新/报告的 KPI 非常有用。它允许我只刷新报告，而不必每次都手动计算它们。</p></div></div>    
</body>
</html>