<html>
<head>
<title>A simple Monte-Carlo simulation to solve a Putnam Competition math problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决普特南竞赛数学问题的简单蒙特卡罗模拟</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-simple-monte-carlo-simulation-to-solve-a-putnam-competition-math-problem-28545df6562d?source=collection_archive---------19-----------------------#2019-06-05">https://towardsdatascience.com/a-simple-monte-carlo-simulation-to-solve-a-putnam-competition-math-problem-28545df6562d?source=collection_archive---------19-----------------------#2019-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9d77" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python 中蒙特卡罗方法综述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/22841d409ccb235c491c3f687ebe169c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1nc0lT3uJovL6it0"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@grizzlybear?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jonathan Petersson</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="38b5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="1f83" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">高赌注赌博和高速赛车有两个共同点——高度的不确定性和蒙特卡洛城。这两者之间的联系导致了术语“蒙特卡罗模拟”的使用，该术语用于使用统计抽样来预测包含不确定性的过程的各种结果的概率的计算方法。迷茫？放心吧！我们将看看使用 Python 设计和执行一个简单的蒙特卡罗模拟。</p><p id="e081" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当我的一个朋友挑战我解决久负盛名的<a class="ae ky" href="https://www.maa.org/math-competitions/putnam-competition" rel="noopener ugc nofollow" target="_blank">普特南竞赛</a>中的一个问题时，我通常无聊的火车通勤变得令人兴奋——这是一个甚至困扰最聪明的数学本科生的测试。</p><p id="4f63" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">问题如下(转述):</p><blockquote class="ms"><p id="7deb" class="mt mu it bd mv mw mx my mz na nb mm dk translated">如果你在一个球体上随机选择 4 个点并把它们连接起来，那么得到的四面体包含球体中心的概率是多少？</p></blockquote><figure class="nd ne nf ng nh kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/efe5a2beb4fcc79c969e811dfcdda170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OmHsqY6864eAoZ0RHT0h0g.png"/></div></div></figure><p id="52b3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，通过应用一些几何和概率的概念来确定精确的解是完全可能的。我希望你们中的数学天才在你读完这句话之前就已经准备好答案了。对于那些不能理解的人(像我一样)，YouTube 上 3Blue1Brown 的一个<a class="ae ky" href="https://www.youtube.com/watch?v=OkmNXy7er84" rel="noopener ugc nofollow" target="_blank">视频</a>提供了一个关于分析解决方案的非常优雅的解释。</p><p id="aa61" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，问题中的“随机”一词在我的脑海中引发了另一种思路，最终导致了我将要提出的解决方案。我考虑了通过<strong class="lt iu">随机抽样</strong>获得答案的可能性。这个想法很简单——抽取大量四面体的随机样本，并计算考虑所有这些样本的概率。</p><h1 id="8f81" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">该算法</h1><p id="c8e9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">模拟的大致算法如下:</p><ol class=""><li id="ca3a" class="ni nj it lt b lu mn lx mo ma nk me nl mi nm mm nn no np nq bi translated">将已知半径的球面定义为样本空间。</li><li id="60ed" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">将合成概率定义为 num/den，其中 num=0，den=1。</li><li id="0d76" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">从样本空间中绘制球体内部四面体的一个样本。</li><li id="86fd" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">确定中心是否位于四面体内部。</li><li id="35ac" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">分别基于当前试验的成功或失败，通过在 num 上加 1 或 0，并在任何情况下在 den 上加 1，计算得到的概率。</li><li id="b779" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">重复步骤 3 至 5，选择指定数量的随机样本。</li><li id="09f8" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">显示结果概率。</li></ol><h1 id="4a66" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">代码</h1><p id="f32f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将一步一步地浏览代码，并详细检查每一步。</p><h2 id="a7dd" class="nw la it bd lb nx ny dn lf nz oa dp lj ma ob oc ll me od oe ln mi of og lp oh bi translated">步骤 1:导入所需的模块</h2><p id="bcb9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，我们在 Python 中导入所需的模块——即<em class="oi"> Scipy </em>和<em class="oi"> Matplotlib </em>。<em class="oi"> Scipy </em>有一个允许生成随机数的子模块。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="93b3" class="nw la it ok b gy oo op l oq or">import scipy as sci<br/>import matplotlib.pyplot as plt</span></pre><h2 id="c3f8" class="nw la it bd lb nx ny dn lf nz oa dp lj ma ob oc ll me od oe ln mi of og lp oh bi translated">步骤 2:定义样本空间</h2><p id="cdce" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下一步是创建一个由一定数量的点组成的样本空间。对于这个例子，让样本空间在半径为<strong class="lt iu"> 1 单位的球体表面上有<strong class="lt iu"> 10，000 个点</strong>。</strong></p><p id="1172" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们如何确保样本空间上的点位于球面上？三个简单的步骤:</p><ol class=""><li id="ca38" class="ni nj it lt b lu mn lx mo ma nk me nl mi nm mm nn no np nq bi translated">使用<code class="fe os ot ou ok b">sci.random.rand(1,3)</code> <em class="oi">选择任意随机 3D 矢量。</em>这将产生一个以 0.5 为中心的三维矢量，每个坐标的值在 0 到 1 之间。</li><li id="41e4" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">从每个坐标中减去 0.5，使其以 0 为中心。</li><li id="afac" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">计算向量的范数(或大小)并将向量除以其范数，确保其成为单位向量<strong class="lt iu"/>。任何单位矢量都必然位于半径为 1 的球面上。</li></ol><p id="ea26" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了安全起见，可以添加一个 if 条件，以确保范数等于 0 或大于 1 的向量不会经历这种变换。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">This animation was created using matplotlib; the code for this is not given in the article. It is merely used for the purpose of representation of under-the-hood computations.</figcaption></figure><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="d886" class="nw la it ok b gy oo op l oq or">points=10000 #Number of points <br/>x=sci.zeros((points,3)) #To store x-coordinates of sample points<br/>y=sci.zeros((points,3)) #To store y-coordinates of sample points</span><span id="d416" class="nw la it ok b gy ox op l oq or">for i in range(points):<br/>    vector=sci.random.rand(1,3)-0.5<br/>    if(sci.linalg.norm(vector)!=0 and sci.linalg.norm(vector)&lt;=1.0):<br/>        x[i,:]=vector<br/>        y[i,:]=x[i,:]/sci.linalg.norm(x[i,:])</span></pre><p id="66bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了绝对确保样本空间中的所有点都位于球体表面，我们可以添加另一个<strong class="lt iu">检查点。</strong></p><p id="b112" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们计算样本空间中向量的实际范数和期望范数(等于球体的半径；这里 1)并将其与一个公差(任意定义的；这里是 1×10⁻ ⁰).与所需规范不匹配的规范存储在<code class="fe os ot ou ok b">danger_array</code>中。如果<code class="fe os ot ou ok b">danger_array</code>的大小是 0(也就是说，不存在不需要的规范)，那么我们显示“全部清除”消息并继续前进。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="f1b8" class="nw la it ok b gy oo op l oq or">y_norms=sci.zeros(points) #Array to store norms of sample vectors</span><span id="09b9" class="nw la it ok b gy ox op l oq or">for i in range(points):<br/>    y_norms[i]=sci.linalg.norm(y[i,:])<br/>    tol=1e-10 #Tolerance<br/>    norm_diff=abs(y_norms-1) #Diff. between actual and desired norm<br/>    danger_array=y_norms[norm_diff&gt;tol]</span><span id="4bde" class="nw la it ok b gy ox op l oq or">if(len(danger_array)==0): <br/>    print("All Clear")<br/>else:<br/>    print("Danger")</span></pre><h2 id="b084" class="nw la it bd lb nx ny dn lf nz oa dp lj ma ob oc ll me od oe ln mi of og lp oh bi translated">步骤 3:创建函数来确定中心是否位于四面体内部</h2><p id="2727" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦所有检查都通过了，我们就进入问题的核心——确定球体的中心是否位于随机四面体中。这可以通过使用两个函数来简化。</p><p id="e1b2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一个检查球体的中心和四面体的第四个顶点是否位于由四面体的其余三个顶点形成的平面的同一侧。</p><p id="b73f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第二个为四面体的所有四个面调用第一个函数，并推断中心是否位于四面体内部。</p><p id="755e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了公式化<code class="fe os ot ou ok b">CheckSide</code>函数，我们依赖于以下线性代数原理:</p><ul class=""><li id="adc5" class="ni nj it lt b lu mn lx mo ma nk me nl mi nm mm oy no np nq bi translated">两个向量的<strong class="lt iu">叉积</strong>给出一个垂直于两个向量形成的平面的<strong class="lt iu">向量。</strong></li><li id="0d58" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm oy no np nq bi translated">两个矢量的<strong class="lt iu">点积</strong>给出了一个矢量在另一个方向上的分量的<strong class="lt iu">大小。如果分量的方向与第二个向量相反，那么点积就是负的。</strong></li></ul><p id="3d18" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们使用第一个原理来寻找由任意三个顶点形成的平面的法线。</p><p id="33e2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来，我们找到法线和一个向量的点积，该向量将第四个顶点与三个顶点中的任何一个连接起来——这个点积的符号被存储。</p><p id="7833" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，我们找到法线和连接球体中心和三个顶点中的任何一个的向量的点积——将该点积的符号与前一个进行比较，如果它们<strong class="lt iu">与</strong>匹配，则可以得出结论，第四个顶点和中心位于由剩余三个顶点形成的平面的<strong class="lt iu">同侧</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/54cba0f9f673e89e792e67785c6b1d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hnaewg7cE-M9TI7bSAGo4A.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">This schematic will make it easier for you to visualize the application of the two principles</figcaption></figure><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="b4f5" class="nw la it ok b gy oo op l oq or">def CheckSide(vertices,point):<br/>    t1,t2,t3,t4=vertices<br/>    p=point<br/>    side_1=t2-t1<br/>    side_2=t3-t1<br/>    normal=sci.cross(side_1,side_2)</span><span id="bb08" class="nw la it ok b gy ox op l oq or">    ref_vector=t4-t1<br/>    ref_sign=sci.dot(normal,ref_vector)</span><span id="2ca1" class="nw la it ok b gy ox op l oq or">    point_vector=p-t1<br/>    point_sign=sci.dot(normal,point_vector)</span><span id="806f" class="nw la it ok b gy ox op l oq or">    if(sci.sign(ref_sign)==sci.sign(point_sign)):<br/>        return 1<br/>    else:<br/>        return 0</span></pre><p id="40a2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们将<code class="fe os ot ou ok b">CheckSide</code>函数应用于一个四面体的所有四个面，我们将能够准确地推断出中心是否位于其中。因此，我们定义了一个新函数<code class="fe os ot ou ok b">CheckTetrahedron</code> <em class="oi"> </em>，它调用了<code class="fe os ot ou ok b">CheckSide</code> <em class="oi"> </em>函数四次。</p><p id="ac3b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在每一次函数调用之间，我们<strong class="lt iu">将</strong>的顶点数组滚动一个，这样<code class="fe os ot ou ok b">CheckSide</code> <em class="oi"> </em>函数在下一次调用时会在一个新的面上工作。</p><p id="ce77" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，将所有四个<code class="fe os ot ou ok b">CheckSide</code> <em class="oi"> </em>调用返回的值相加，如果它们等于<strong class="lt iu"> 4 </strong>，则断定中心位于四面体内部；如果没有，它就在外面。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="83b1" class="nw la it ok b gy oo op l oq or">def CheckTetrahedron(vertices,point):<br/>    vert=sci.copy(vertices)<br/>    check_1=CheckSide(vert,point)</span><span id="0255" class="nw la it ok b gy ox op l oq or">    vert=sci.roll(vert,1,axis=0)<br/>    check_2=CheckSide(vert,point)</span><span id="2c6c" class="nw la it ok b gy ox op l oq or">    vert=sci.roll(vert,1,axis=0)<br/>    check_3=CheckSide(vert,point)</span><span id="eab7" class="nw la it ok b gy ox op l oq or">    vert=sci.roll(vert,1,axis=0)<br/>    check_4=CheckSide(vert,point)</span><span id="8a39" class="nw la it ok b gy ox op l oq or">    sum_check=check_1+check_2+check_3+check_4</span><span id="6af5" class="nw la it ok b gy ox op l oq or">    if(sum_check==4.):<br/>        return 1<br/>    else:<br/>        return 0</span></pre><h2 id="d0b4" class="nw la it bd lb nx ny dn lf nz oa dp lj ma ob oc ll me od oe ln mi of og lp oh bi translated">步骤 4:初始化</h2><p id="abe9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经定义了所有必需的函数，是时候开始实际运行了。在开始运行之前，我们需要初始化一些参数，以便运行和绘图。</p><p id="6836" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">数组<code class="fe os ot ou ok b">check_point</code>将存储<strong class="lt iu">的</strong>和<strong class="lt iu">的</strong>来表示每次迭代的<strong class="lt iu">成功</strong>或<strong class="lt iu">失败</strong>。我们将创建一个数组来存储每次迭代的值，而不是只存储结果概率的一个值，这样我们就可以绘制一条曲线来显示概率随迭代次数的变化。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="816a" class="nw la it ok b gy oo op l oq or">centre=[0,0,0]<br/>number_of_samples=10000<br/>sample_span=sci.arange(0,number_of_samples,1)<br/>check_point=sci.zeros(number_of_samples) <br/>prob=sci.zeros(number_of_samples)</span></pre><h2 id="d8e7" class="nw la it bd lb nx ny dn lf nz oa dp lj ma ob oc ll me od oe ln mi of og lp oh bi translated">跑步</h2><p id="21ee" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">是时候运行模拟了！在每次迭代中，我们做以下三件事:</p><ol class=""><li id="2984" class="ni nj it lt b lu mn lx mo ma nk me nl mi nm mm nn no np nq bi translated">从样本空间中随机挑选 4 个不同的点。</li><li id="c78b" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">将<code class="fe os ot ou ok b">CheckTetrahedron</code> <em class="oi"> </em>函数应用于这 4 个点和中心，以确定中心是否位于这 4 个点形成的四面体中。</li><li id="a17a" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">根据试验的成功或失败，在<code class="fe os ot ou ok b">check_point</code> <em class="oi"> </em>中分别存储 1 或 0，并更新<code class="fe os ot ou ok b">prob</code> <em class="oi"> </em>数组中的合成概率值。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">This animation was created using matplotlib; the code for this is not given in the article. It is merely used for the purpose of representation of under-the-hood computations.</figcaption></figure><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="0a73" class="nw la it ok b gy oo op l oq or">for i in range(number_of_samples):<br/>    indices=sci.random.randint(0,points,4)<br/>    vertex_list=y[indices]<br/>    check_point[i]=CheckTetrahedron(vertex_list,centroid)<br/>    prob[i]=len(check_point[check_point==1.])/(i+1)</span></pre><h2 id="e566" class="nw la it bd lb nx ny dn lf nz oa dp lj ma ob oc ll me od oe ln mi of og lp oh bi translated">第六步:绘图</h2><p id="e062" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，在给定迭代次数下运行模拟后，绘制结果并找出结果概率的时间到了。我们给情节添加了一些花里胡哨的东西，让它看起来更有吸引力，同时也确保它清晰地传达了所有需要的信息。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="5a7c" class="nw la it ok b gy oo op l oq or">#Plot blank figure<br/>plt.figure(figsize=(15,10))</span><span id="2cfe" class="nw la it ok b gy ox op l oq or">#Plot resultant probability from simulation<br/>plt.plot(sample_span,prob,color="navy",linestyle="-",label="Resultant probability from simulation")</span><span id="db43" class="nw la it ok b gy ox op l oq or">#Plot resultant probability from analytical solution<br/>plt.plot(sample_span,[0.125]*len(sample_span),color="red",linestyle="-",label="Actual resultant probability from analytical solution (0.125)")</span><span id="35f6" class="nw la it ok b gy ox op l oq or">#Plot value of final resultant probability in text<br/>plt.text(sample_span[int(number_of_samples/2)],0.05,f"The final probability is {prob[-1]:.4f}",fontsize=16)</span><span id="c972" class="nw la it ok b gy ox op l oq or">#Display axis labels<br/>plt.xlabel("Number of iterations",fontsize=14)<br/>plt.ylabel("Probability",fontsize=14)</span><span id="b40b" class="nw la it ok b gy ox op l oq or">#Display legend<br/>plt.legend(loc="upper right",fontsize=14)</span><span id="abcd" class="nw la it ok b gy ox op l oq or">#Display title of the plot<br/>plt.title("Variation of resultant probability with increase in the number of iterations",fontsize=14)</span></pre><p id="b40e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最终的剧情如下。从图的性质来看，很明显<strong class="lt iu">随着迭代次数的上升，概率收敛到真值(即解析解)。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/c82a3ae43c09c827385aff31760d6b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2kpEV6xg02j2eAwat-9Axw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Plot generated by matplotlib detailing the variation of probability with the number of iterations</figcaption></figure><h2 id="4c30" class="nw la it bd lb nx ny dn lf nz oa dp lj ma ob oc ll me od oe ln mi of og lp oh bi translated">总结想法</h2><p id="d932" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">由于方法中相关的随机性，你的模拟可能无法在与我的模拟相同的迭代次数内收敛到真实值。在这种情况下，您可以不断增加迭代次数，直到您的解收敛到真实值。</p><p id="4073" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">解析解是<strong class="lt iu"> 1/8 </strong>或<strong class="lt iu"> 0.1250 </strong>，蒙特卡罗模拟收敛到一个值<strong class="lt iu"> 0.1248，</strong>，这个值足够接近。我们通过模拟从随机性中创造了一种明显的秩序——重复随机采样可以导致单一收敛解的事实令人震惊。这种方法可能看起来不优雅——几乎就像对计算能力的野蛮使用——但它非常有效，确实给出了准确的答案。</p></div><div class="ab cl pb pc hx pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="im in io ip iq"><p id="f6e9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">代码已经被记录在一个<a class="ae ky" href="https://nbviewer.jupyter.org/gist/gauravsdeshmukh/f735e3dbd34ec6b6e3dcd1f154f264ef" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>中，可以在线查看。</p><p id="7c08" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我希望我已经清楚地解释了方法和代码。欢迎您在评论中做出回应，提出问题或提供您可能有的任何建议。</p><p id="d020" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你也可以在 Twitter 上关注我。</p></div></div>    
</body>
</html>