<html>
<head>
<title>Easy Data Analysis, Visualization and Modeling using Datasist (PART 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Datasist 实现简单的数据分析、可视化和建模(第 1 部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/https-medium-com-risingdeveloper-easy-data-analysis-visualization-and-modeling-using-datasist-part1-8b26526dbe01?source=collection_archive---------23-----------------------#2019-12-03">https://towardsdatascience.com/https-medium-com-risingdeveloper-easy-data-analysis-visualization-and-modeling-using-datasist-part1-8b26526dbe01?source=collection_archive---------23-----------------------#2019-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e4e3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 datasist 库进行快速有效的数据分析</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dc76ec2c554002bf275f0ad9209a9a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rYEpi3Crp_pX0lWBbFeOg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">datasist logo</figcaption></figure><p id="2d10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">日前，第一个稳定版<strong class="la iu">data list 发布。</strong>你可能不知道<strong class="la iu">datalist</strong>是什么，所以先不要太激动。</p><h2 id="9b00" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">那么，什么是 DATASIST 呢？</h2><p id="d670" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">简单来说，datasist 是一个 python 库，它可以让数据分析、可视化、清理、准备甚至建模变得非常简单。因为让我们面对它，我不想每次都这样…(请看下面的代码块)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="bc49" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">…只是因为我想删除缺少 80%值的列，而我可以简单地做到这一点(请看下面的美景)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/a510c106aff9ccd3820b30ae356b9291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*PlsN4stz2IMj_XqZy7bufw.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">source: Pixabay</figcaption></figure><blockquote class="mv"><p id="5201" class="mw mx it bd my mz na nb nc nd ne lt dk translated">我知道没错，它很懒，但效率极高。</p></blockquote><p id="8760" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated"><strong class="la iu">datalist</strong>的目标是将我们经常使用的重复代码、函数和技术抽象成可以在一行代码中调用的简单函数。Datasist 的诞生纯粹是出于懒惰，因为让我们面对它吧，除非你是一个 10 倍的数据科学家，否则我们都讨厌一遍又一遍地键入又长又无聊的代码来做同样的事情。</p><p id="2c8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">datasist 的设计目前围绕 5 个模块:</p><ul class=""><li id="f6cc" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated">结构数据</li><li id="9815" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">特征工程</li><li id="36bf" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">时间序列</li><li id="1fdb" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">形象化</li><li id="bd68" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">模型</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/d4b07be37c565469c5966df51e243928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HB5UTdiGss6QlvdwoTUtsw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">class diagram for datasist. Source: <a class="ae nz" href="https://arxiv.org/abs/1911.03655" rel="noopener ugc nofollow" target="_blank">ArXiv</a></figcaption></figure><p id="725d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可能会在未来的版本中发生变化，因为我们目前正在努力支持数据科学和机器学习的许多其他领域。</p><p id="f5b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章的目的是向你介绍这些模块中的一些重要特性，以及你如何在你的项目中使用它们。为了这篇文章简洁明了，我决定把它分成两部分。</p><p id="536b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第 1 部分将涵盖前三个 modu <em class="oa"> les (structdata、feature engineering、timeseries </em>)和<a class="ae nz" rel="noopener" target="_blank" href="/easy-data-analysis-visualization-and-modeling-using-datasist-part-2-d2ce7fbf79e3">第 2 部分</a>将涵盖最后两个模块(<em class="oa">可视化和模型</em>)。</p><p id="03a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以不浪费更多的时间，让我们开始吧。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="f23d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将在这一部分学到什么:</p><ul class=""><li id="fe04" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated">使用 structdata 模块。</li><li id="78b9" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">使用数据列表的特征工程。</li><li id="aade" class="nk nl it la b lb nt le nu lh nv ll nw lp nx lt np nq nr ns bi translated">使用基于时间的要素。</li></ul><p id="4402" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要阅读本文，您需要安装 datasist 库。您可以使用 python pip 管理器来做到这一点。打开终端或 Jupyter 笔记本并键入，</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="091e" class="lu lv it oj b gy on oo l op oq">pip install datasist</span></pre><p id="a747" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记得用感叹号(！)在上面的命令之前，如果你在 Jupyter 笔记本上运行它。</p><p id="163f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，您需要获得一个数据集来进行实验。虽然您可以使用任何数据集，但为了一致性，建议下载我们在本教程中使用的数据集。你可以在这里 找到<a class="ae nz" href="https://zindi.africa/competitions/data-science-nigeria-2019-challenge-1-insurance-prediction/data" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">。</strong></a></p><p id="68ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，打开 Jupyter 笔记本，导入以下库和数据集，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="98f6" class="or lv it bd lw os ot ou lz ov ow ox mc jz oy ka mf kc oz kd mi kf pa kg ml pb bi translated">使用 structdata 模块</h1><p id="064d" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">structdata 模块包含许多用于处理结构化数据的函数，这些数据大多是 Pandas DataFrame 格式的。也就是说，您可以使用这些函数轻松地操作和分析数据帧。我们在下面重点介绍一些功能。</p><ol class=""><li id="a97f" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt pc nq nr ns bi translated"><strong class="la iu"> describe </strong>:我们都知道 Pandas 中的 describe 函数，我们决定扩展它以支持对数据集的全面描述。让我们来看看实际情况。</li></ol><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="b0a7" class="lu lv it oj b gy on oo l op oq">ds.structdata.describe(train_df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/61bed2128d08d2f03d40b82a2b0ff588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mdgXq5F9jXfKlFRcNp2cEw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">output from the describe function of structdata</figcaption></figure><p id="1acc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上面的结果中，您可以一次获得数据集的完整描述，并且还可以在一行中正确理解一些功能(太棒了！).</p><p id="96e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 2。check_train_test_set </strong>:该函数用于检查两个数据集的采样策略。这一点很重要，因为如果两个数据集不是来自同一个分布，那么特征提取将会不同，因为我们不能将第一个数据集的计算应用于第二个数据集。</p><p id="12fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要使用它，您需要传入两个数据集(<strong class="la iu"> train_df </strong>和<strong class="la iu"> test_df </strong> ) <strong class="la iu">，</strong>一个公共索引(customer_id)，最后传入两个数据集中存在的任何特性或列。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="7cbe" class="lu lv it oj b gy on oo l op oq">ds.structdata.check_train_test_set(train_df, test_df,<br/>                                   index='Customer Id',             <br/>                                    col='Building Dimension')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/40fa8fd2f6bbe8f987000dabb693db92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*c9pPv18otFkswmtd18Vymg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">output from the check_train_test_set</figcaption></figure><p id="12b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 3。display_missing: </strong>您可以检查数据集中缺失的值，并使用该函数在格式良好的数据帧中显示结果。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="5dde" class="lu lv it oj b gy on oo l op oq">ds.structdata.display_missing(train_df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/02bb37e2228903225e1ccc645b21a612.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*-JEWcT-YDeopyhx_IJreJg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">missing values in data set</figcaption></figure><p id="a9da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 4。get_cat_feats </strong>和<strong class="la iu"> get_num_feats: </strong>就像它们的名字一样，您可以分别以 Python 列表的形式检索分类和数字特征。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="5484" class="lu lv it oj b gy on oo l op oq">cat_feats = ds.structdata.get_cat_feats(train_df)<br/>cat_feats</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/fb736736489953cf5de4f01c57778188.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*fvydaDhY00y6gTV0MOSRPw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">categorical features in data set</figcaption></figure><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="ae74" class="lu lv it oj b gy on oo l op oq">num_feats = ds.structdata.get_num_feats(train_df)<br/>num_feats</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/f48127d0252e59a073a28271717285ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*F9Aiwn2NWCjfar78b7CN1g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">numerical features in data set</figcaption></figure><p id="d4b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 5。get_unique_counts: </strong>在决定使用何种编码方案之前，您是否希望检查分类特征中唯一类的数量？那么，你可以使用<strong class="la iu"><em class="oa">get _ unique _ count</em></strong>函数来轻松做到这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/2159a0ff1c2b726737325316601e9a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*jRkAT2_p1vNSL4XlRhmMRg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">output from the get_unique_counts function</figcaption></figure><p id="83c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">6。join_train_and_test: 大多数时候，在构建原型时，您可能希望将训练集和测试集连接起来，然后对其应用一些转换。您可以使用<strong class="la iu"><em class="oa">join _ train _ and _ test</em></strong>功能来完成。它返回一个连接的数据集以及训练集和测试集的大小，以便将来进行拆分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/19251df3d762f522c4c1d94e8385534a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*UV5F5OljzekoBN_KwMHCRQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">output from combining the two data set and splitting</figcaption></figure><p id="c461" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是 datasist 的 structdata 模块中的一些常用函数，要查看其他函数并了解更多关于您可以更改的参数，请查看这里的<a class="ae nz" href="https://risenw.github.io/datasist/structdata.html" rel="noopener ugc nofollow" target="_blank"> API 文档。</a></p><h1 id="1715" class="or lv it bd lw os ot ou lz ov ow ox mc jz oy ka mf kc oz kd mi kf pa kg ml pb bi translated">使用数据列表的特征工程。</h1><p id="9253" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">特征工程是从原始数据中提取重要特征并将其转换为适合机器学习模型的格式的行为。</p><p id="2734" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据列表的<strong class="la iu"> <em class="oa">特征 _ 工程</em> </strong>模块中的一些可用功能解释如下。</p><blockquote class="pk pl pm"><p id="f558" class="ky kz oa la b lb lc ju ld le lf jx lg pn li lj lk po lm ln lo pp lq lr ls lt im bi translated"><strong class="la iu">注意</strong>:在<strong class="la iu">特征工程</strong>模块中的函数总是返回一个新的和转换的数据帧。这意味着，你应该把结果赋给一个变量，因为什么也没有发生。</p></blockquote><ol class=""><li id="3091" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt pc nq nr ns bi translated"><strong class="la iu"> drop_missing </strong>:这个函数删除具有指定百分比的缺失值的列/特性。假设我有一组丢失值超过 80%的特性，我想删除这些列，我可以很容易地用<strong class="la iu"> <em class="oa"> drop_missing </em> </strong>函数来完成。</li></ol><p id="bd79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先让我们看看数据集中缺失值的百分比</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="2abc" class="lu lv it oj b gy on oo l op oq">ds.structdata.display_missing(train_df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/6b70618d8be6e62ca2de4eb4c8520d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*XqF43_oATMFW1wH4uMzBCA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">display of missing values in data set</figcaption></figure><p id="b4fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了演示，我们将删除缺少 7.1%值的列(Date _ of _ Occupancy)。</p><blockquote class="pk pl pm"><p id="4262" class="ky kz oa la b lb lc ju ld le lf jx lg pn li lj lk po lm ln lo pp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>您不应该删除丢失值如此之少的列/特征。最理想的做法是填满它。我们把它放在这里，只是为了演示。</p></blockquote><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="c459" class="lu lv it oj b gy on oo l op oq">new_train_df = ds.feature_engineering.drop_missing(train_df,  <br/>                                                    percent=7.0)<br/>ds.structdata.display_missing(new_train_df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/e3ff1349c3a4de2d8b29d56388744f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*M9QWMaMl_HjgxgOL5xJO5A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Output of dataset after using the drop_missing function</figcaption></figure><p id="ad51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2 <strong class="la iu">。drop_redundant: </strong>该功能用于移除低方差或无方差的特征。也就是说，所有要素都包含相同的值。我们展示了一个使用人工数据集的简单示例。</p><p id="c34e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，让我们创建数据集…</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="8db2" class="lu lv it oj b gy on oo l op oq">df = pd.DataFrame({'a': [1,1,1,1,1,1,1],<br/>                  'b': [2,3,4,5,6,7,8]})</span><span id="0e1e" class="lu lv it oj b gy ps oo l op oq">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/0dbddd1f2de1f307d5042b02fc0f7d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*ro47baMHiMBzuPb1TfFIbg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">sample dataset</figcaption></figure><p id="4fd4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在看看上面的数据集，我们看到列<strong class="la iu"> a </strong>是多余的，也就是说它始终具有相同的值。我们可以通过将数据集传递给<strong class="la iu"><em class="oa">drop _ redundant</em></strong>函数来自动删除该列。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="467e" class="lu lv it oj b gy on oo l op oq">df = ds.feature_engineering.drop_redundant(df)<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/336e73d3b4c6d0c42acf678f547da686.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*cJ6ZnKRxU5iTPhoGc_bd4A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Result dataset from using the drop_redundant function</figcaption></figure><p id="0d88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.<strong class="la iu"> convert_dtypes </strong>:该函数以一个数据帧作为参数，自动将特征类型转换为正确的数据类型。</p><p id="39b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子。首先，我们创建一个人工数据集如下。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="3182" class="lu lv it oj b gy on oo l op oq">data = {'Name':['Tom', 'nick', 'jack'],<br/>        'Age':['20', '21', '19'], <br/>        'Date of Birth': ['1999-11-17','20 Sept 1998','Wed Sep 19 <br/>                         14:55:02 2000']}</span><span id="88ca" class="lu lv it oj b gy ps oo l op oq">df = pd.DataFrame(data)<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/0513cf361e5f9dea26d467738bbd5fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*z75JPY75VIUMiWTHkSEy6Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">sample data set</figcaption></figure><p id="6bbd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，让我们检查数据类型…</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="2408" class="lu lv it oj b gy on oo l op oq">df.dtypes</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/0ba9a2fb957080d7e86b647de4c07c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*McN9eRXA8ztWkZu-QPtVlw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">data types of features</figcaption></figure><p id="feb9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">年龄和出生日期这两个特性应该分别是整数和日期时间，通过将这个数据集传递给<strong class="la iu"><em class="oa">convert _ dtype</em></strong>函数，可以自动修复这个问题。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="1588" class="lu lv it oj b gy on oo l op oq">df = ds.feature_engineering.convert_dtype(df)<br/>df.dtypes</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi px"><img src="../Images/1de09e584f6d4af08ecbf13fd9b434fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*5G6daA-hC-pNBon8heVSZQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">datatypes of features in artificial data set after using convert_dtypes function</figcaption></figure><p id="55ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4.<strong class="la iu"> fill_missing_cats: </strong>顾名思义，这个函数接受一个数据帧，并自动检测缺少值的分类列。它使用模式填充它们。让我们看一个例子。</p><p id="021b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从数据集中，我们有两个缺失值的分类要素，它们是 Garden 和 Geo_Code。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="0671" class="lu lv it oj b gy on oo l op oq">df = ds.feature_engineering.fill_missing_cats(train_df)<br/>ds.structdata.display_missing(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi py"><img src="../Images/c977660456c71064f18185db5d15fc49.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*j8WMGC19scpy5wefUVmMfQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">missing values DataFrame after filling the missing categorical features</figcaption></figure><p id="bfea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">5.<strong class="la iu"> fill_missing_nums </strong>:这类似于<strong class="la iu"><em class="oa">fill _ missing _ cats</em></strong>，除了它作用于数字特征，你可以指定一个填充策略(均值、众数或中位数)。</p><p id="2b8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从数据集中，我们有两个数值特征缺失值，它们是建筑尺寸和入住日期。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="49a2" class="lu lv it oj b gy on oo l op oq">df = ds.feature_engineering.fill_missing_num(train_df)<br/>ds.structdata.display_missing(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi py"><img src="../Images/becb96fcbb9973e1531d367c97579edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*YigSUfcbrJdZCIUkYnVDYg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">missing values DataFrame after filling the missing numerical features</figcaption></figure><p id="1061" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">6.<strong class="la iu"> log_transform </strong>:该功能可以帮助你对一组特征进行 log 变换。它还显示了之前和之后的图与偏斜水平，以帮助您决定是否日志转换功能是你真正想要的。</p><p id="d0bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">特征 B <em class="oa">建筑尺寸</em>是右斜的，我们可以转换它。</p><blockquote class="pk pl pm"><p id="5c81" class="ky kz oa la b lb lc ju ld le lf jx lg pn li lj lk po lm ln lo pp lq lr ls lt im bi translated">注意:传递给 log_transform 函数的列不应该包含缺失值，否则它将抛出一个错误。</p></blockquote><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="ac04" class="lu lv it oj b gy on oo l op oq">df = ds.feature_engineering.fill_missing_num(df)<br/>df = ds.feature_engineering.log_transform(df,<br/>                                    columns=['Building Dimension'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/ff695a3abfad5e8164a3fd3fd41928e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*jJGHp39ci7ZZ0iHyQmouzg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Log-transform plot</figcaption></figure><p id="b718" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了处理地理特征，如<em class="oa">纬度</em>和<em class="oa">经度</em>，datasist 有专门的函数，如<strong class="la iu">方位</strong>、<strong class="la iu">曼哈顿距离</strong>、<strong class="la iu">获取位置中心</strong>等，在特征工程模块中也有。要查看这些和其他函数，您可以在这里查看<a class="ae nz" href="https://risenw.github.io/datasist/feature_engineering.html" rel="noopener ugc nofollow" target="_blank"> API 文档</a>。</p><h1 id="5138" class="or lv it bd lw os ot ou lz ov ow ox mc jz oy ka mf kc oz kd mi kf pa kg ml pb bi translated">使用基于时间的要素</h1><p id="9bef" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">最后，在这一部分，我将讨论 datasist 中的 timeseries 模块。timeseries 模块包含使用日期时间功能的函数。它可以帮助您从日期中提取新特征，还可以帮助您将它们可视化。</p><ol class=""><li id="546e" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt pc nq nr ns bi translated"><strong class="la iu"> extract_dates: </strong>该函数可以从指定的日期特征中提取指定的特征，如星期几、一年中的某一天、小时、分钟和一天中的秒钟。为了演示这一点，让我们使用一个包含日期功能的数据集。</li></ol><p id="56b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里 获取新的数据集<a class="ae nz" href="https://zindi.africa/competitions/sendy-logistics-challenge" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">。</strong></a></p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="88a4" class="lu lv it oj b gy on oo l op oq">new_data = pd.read_csv("Train.csv")<br/>new_data.head(3).T</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/e5126875b75ab42d192927b78e9509f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*33V7r9kqkom6bLsrkWOfQQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Transposed head of the dataset</figcaption></figure><p id="b3e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据集包含大量我们可以分析的时间特征。关于这项任务的更多细节可以在<a class="ae nz" href="https://zindi.africa/competitions/sendy-logistics-challenge/data" rel="noopener ugc nofollow" target="_blank">竞赛页面上找到。</a></p><p id="eb33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们演示一下使用 extract_dates 函数从<strong class="la iu">位置-时间</strong>、<strong class="la iu">到达目的地-时间</strong>要素中提取信息是多么容易。我们指定只提取星期几(dow)和一天中的小时(hr)。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="c76c" class="lu lv it oj b gy on oo l op oq">date_cols = ['Placement - Time', 'Arrival at Destination - Time']</span><span id="5cef" class="lu lv it oj b gy ps oo l op oq">df = ds.timeseries.extract_dates(new_train, date_cols=date_cols,<br/>                                          subset=['dow', 'hr')</span><span id="3803" class="lu lv it oj b gy ps oo l op oq">df.head(3).T</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/c3770fef9e2a98fd3c7bf02b4bad26dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*hca8INlx1kHzv6hwexlCTQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">output from extract_dates function</figcaption></figure><p id="c929" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，datasist 创建了新的列，并向数据集追加了新的特性。</p><p id="b1f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 2。时间片</strong>:时间片功能可以帮助你根据特定的时间特性可视化一组特性。这可以帮助你识别趋势和模式。要使用此函数，可以传递一组数字列，然后指定要绘制的日期特征。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="1fc0" class="lu lv it oj b gy on oo l op oq">num_cols = ['Time from Pickup to Arrival', 'Destination Long', <br/>            'Pickup Long','Platform Type', 'Temperature']</span><span id="f8e4" class="lu lv it oj b gy ps oo l op oq">ds.timeseries.timeplot(new_train, num_cols=num_cols,<br/>                       time_col='Placement - Time')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/b7008e1815e05ef7cd21a795fbf4fa05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQNNQIsqX-Vpm8RT3pib2g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">output of timeplot</figcaption></figure><p id="487a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至此，第 1 部分已经结束。要了解更多关于 datasist 和其他可用函数的信息，您可以在这里查看<a class="ae nz" href="https://risenw.github.io/datasist/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> API 文档。</strong> </a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/a89b2696fde89659f1d978924fa9c021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ChCIjrsyMB9tllBO3jXHVA.jpeg"/></div></figure><p id="bb99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第 2 部分中，我们将介绍最后两个模块(可视化和模型),在那里您将看到如何利用 datasist 的强大功能，只用一行代码就能快速创建漂亮的图形。</p><blockquote class="mv"><p id="a303" class="mw mx it bd my mz qd qe qf qg qh lt dk translated"><a class="ae nz" href="https://github.com/risenW/datasist" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">数据列表</strong> </a>正在并将随着我们添加更多功能而继续发展。如果你想让它变得更好，请查看我们的投稿指南<a class="ae nz" href="https://risenw.github.io/datasist/contributing.html" rel="noopener ugc nofollow" target="_blank">这里</a>，如果你想报告一个 bug 问题或者对新功能有一个想法，请访问我们的 GitHub <a class="ae nz" href="https://github.com/risenW/datasist/issues" rel="noopener ugc nofollow" target="_blank">问题页面这里。如果这个项目对你有用，别忘了在 GitHub 上给我们留下一颗星。</a></p></blockquote><p id="126e" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">最后，如果您在项目中使用了 datasist，请告诉我们，这样我们就可以在我们的页面上展示您的作品。</p><p id="cde4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">点击 查看我们的贡献者列表<a class="ae nz" href="https://github.com/risenW/datasist/graphs/contributors" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">。</strong></a></p><p id="be28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae nz" href="https://github.com/risenW/datasist" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">链接</strong> </a>到 GitHub 上的 datasist repo</p><p id="9a22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae nz" href="https://risenw.github.io/datasist/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">将</strong> </a>链接到文档</p><p id="7c70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae nz" href="https://risenw.github.io/datasist/classification_example.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">链接</strong> </a>到示例用法</p><p id="24a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<a class="ae nz" href="https://twitter.com/risingodegua" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">Twitter</strong></a><strong class="la iu"/><a class="ae nz" href="https://www.linkedin.com/in/risingdeveloper/" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">LinkedIn</strong></a>上找我</p><p id="70ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给我发邮件:<a class="ae nz" href="mailto:risingodegua@gmail.com" rel="noopener ugc nofollow" target="_blank">risingodegua@gmail.com</a></p></div></div>    
</body>
</html>