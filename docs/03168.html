<html>
<head>
<title>Function Approximation in Reinforcement Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强化学习中的函数逼近</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/function-approximation-in-reinforcement-learning-85a4864d566?source=collection_archive---------0-----------------------#2019-05-21">https://towardsdatascience.com/function-approximation-in-reinforcement-learning-85a4864d566?source=collection_archive---------0-----------------------#2019-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2142" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当状态和动作空间爆炸时该怎么办…字面意思？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/466d55ddb7634c922971d0d6fbdd88e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8y277WmNNLaMX7K0"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@qwitka?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Maksym Kaharlytskyi</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="747e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">更新</strong>:学习和练习强化学习的最好方式是去 http://rl-lab.com<a class="ae ky" href="http://rl-lab.com/" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="350d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">概观</h1><p id="693e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在像 DP 和蒙特卡罗这样的表格方法中，我们已经看到状态的表示实际上是每个状态的记忆。<br/>现在让我们回忆一下到底什么是状态。<br/>状态是可观察特征或变量的组合。这意味着每当一个特性或变量有了一个新值，就会产生一个新的状态。</p><p id="c788" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来举一个具体的例子。假设一个代理在 4x4 网格中，那么代理在砂砾上的位置就是一个特征。这给出了 16 个不同的位置，意味着 16 个不同的州。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/8df9c7c163c6193db4daa643d3b6b1cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aaSWk2mjFqdOI3pC2xnffw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Grid World</figcaption></figure><p id="6b28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这还不是全部，假设方位(北、南、东、西)也是一个特征。这为每个位置提供了 4 种可能性，这使得状态的数量为 16*4 = 64。此外，如果代理有可能使用 5 种不同的工具(包括“无工具”的情况)，这将使状态数增加到 64 * 5 = 320。<br/>你明白了……</p><p id="2a3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表示这些状态的一种方法是创建一个多维数组，比如 V[row，column，direction，tool]。然后我们或者查询或者计算一个状态。<br/>例如 V[1，2，north，torch]表示代理在第 1 行第 2 列，面向北方，手持火炬的状态。这个数组单元格中的值表明了这个状态的价值。<br/>另一个例子是 V[4，1，west，nothing]，它是第 4 行第 1 列的一个代理，向西行驶，但什么也没有。</p><p id="6733" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们也考虑一下国际象棋。<br/>每一步棋后棋盘的情况是一种状态。估计大约有 10^120 个州！<br/>国际象棋中一种状态的一种表示可以是:</p><p id="463b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">黑卒，黑车，…，无，无，…。，白皇后，白主教] </p><p id="ac78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中每个维度代表棋盘上的一个正方形，其值是黑色或白色棋子之一，也可以是零。</p><p id="e9b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以一旦我们有了状态集，我们就可以为每个状态分配一个值状态函数。</p><p id="e127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不用说，容纳多个状态所需的存储量是巨大的，并且计算每个状态的值所需的时间也是令人望而却步的。</p><p id="3378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从逻辑上讲，这促使我们寻找更好、更合适的解决方案。</p><h1 id="6ff6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">解决方法</h1><p id="e77a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">记住我们正在努力做的事情总是有用的，因为我们可能会忽略所有的细节。<br/>我们的想法是，我们希望找到环境中每个状态/动作的值，以便代理遵循收集最大回报的最佳路径。</p><p id="6aa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一节中，我们已经表明，当状态空间变得太大时，表格方法就变得不充分和不合适了。为了解决这个缺点，我们可以根据每个状态的特征采用新的方法。目的是使用这些特征集合来概括具有相似特征的状态的值的<strong class="lb iu">估计</strong>。</p><p id="26e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用单词<strong class="lb iu">估计</strong>来表示这种方法永远不会找到一个状态的真实值，而是它的近似值。尽管这个结果看起来很不方便，但是这将实现更快的计算和更多的推广。</p><p id="c855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算这些近似值的方法被称为<strong class="lb iu">函数近似值</strong>。</p><p id="4dc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多函数逼近器:</p><ul class=""><li id="cfcb" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">特征的线性组合</li><li id="6cb9" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">神经网络</li><li id="ee78" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">决策图表</li><li id="4e49" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">最近邻</li></ul><p id="992b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">…</p><p id="f1fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们将使用梯度下降以找到最佳结果，函数逼近器必须是可微分的，这导致我们对特征和神经网络的线性组合。</p><h2 id="a623" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">特征的线性组合</h2><p id="b22c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在让我们深入研究这种线性函数逼近方法的细节。<br/>但首先让我们记住这个公式，它来自<a class="ae ky" href="https://medium.com/@zsalloum/math-behind-reinforcement-learning-the-easy-way-1b7ed0c030f4" rel="noopener">数学背后的强化学习</a>文章:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nt"><img src="../Images/1dcf1bfa1523afa6d56a2565261d203e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*XBua6P6Rw1w4FRmsh0e7ZQ.png"/></div></figure><p id="cceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个递归公式，它根据下一个状态<strong class="lb iu"><em class="nu">【s’</em></strong>等等的值来计算一个状态<strong class="lb iu"> <em class="nu"> s </em> </strong>的值… <br/>这个公式的问题是，每次我们需要计算 V(s)时，我们都需要计算所有未来的状态。更糟糕的是，如果我们在某个时候遇到一个与我们过去已经见过的状态相似的状态，我们没有办法识别它。</p><p id="d1f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得在<a class="ae ky" rel="noopener" target="_blank" href="/td-in-reinforcement-learning-the-easy-way-f92ecfa9f3ce">时间差异</a>文章中提到的，利用 Q 学习公式，我们有一种估计未来状态的方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nt"><img src="../Images/3bf9d2c76060146683cc8831201421b6.png" data-original-src="https://miro.medium.com/v2/format:webp/1*s80b7_pfTReXENYNaCUK4g.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nt"><img src="../Images/ba6b6365498e5e287265a26c21b6ade4.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Aq-UZZ0QtkAal3rLF_08Zw.png"/></div></figure><p id="68bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将利用这些公式推导出一些有趣的解。<br/>让我们重新定义 V(s ),比如它反映了它所包含的特征。状态值函数可以用其特征的加权和来表示:<br/> V(s) = W1。F1(s) + W2。F2(s) + … +Wn。Fn(s)或简称:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/a2b8b8d0502efcea66a4deaf2fb24b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*4n_slAa5c0_V0Ku2jRfznw.png"/></div></figure><p id="7d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">𝝫(s)是在状态<strong class="lb iu"> <em class="nu"> s </em> </strong>下的特征向量，而𝜽ᵀ是应用于特征的权重的转置矩阵，以这种方式，一些特征在任何状态<strong class="lb iu"> <em class="nu"> s </em> </strong>下比其他特征更受重视。</p><p id="0aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们定义𝜹，也称为 TD 误差，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/42739a690982472e8f48348253e36d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*H6TpaD3zHyL7cxlc69wdqg.png"/></div></figure><p id="9387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过用新的定义代替𝜹中的 V(s ),我们得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/bba3bac018799b6a8308e45afd3e7e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2aiEB4v_E3AKvFvCrgxnQA.png"/></div></div></figure><p id="c3b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，根据定义 V(St) = R(t₊₁) + 𝛾V(St₊₁)，这意味着𝜹应该是零。然而，我们不是在一个确定的环境中，这意味着我们不能确定相同的行为总是导致相同的结果，并且学习过程不是 100%准确的，这意味着我们对 V(s)的学习不一定等同于 R(t₊₁) + 𝛾V(St₊₁).所有这些导致𝜹具有非零值。所以现在我们的目标是计算𝜽，以便最小化𝜹.通过最小化 J(𝜽).来实现这一点的便利方法</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/769d584e7ab7f30b4699a9055c940852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7e3oATG770_OB6FxoiMTGw.png"/></div></div></figure><p id="b3b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">J(𝜽)与任何回归一样，计算实际结果与真实结果之间的差异。然而我们的问题是我们不知道什么是真正的结果！相反，我们将计算实际结果和估计结果之间的差异。每次迭代后，我们都有一个新的真实结果估计，这使得我们看起来好像是在瞄准一个移动的目标。<br/>想法仍然是不断改进估计，直到两者之间的差异变得足够小。<br/>已经证明这种方法有足够的收敛性保证。</p><p id="60b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成本函数的最小化可以使用梯度下降法来完成，该方法在<a class="ae ky" rel="noopener" target="_blank" href="/gradient-descent-the-easy-way-5240ca9a08da">梯度下降</a>文章中有详细描述。<br/>梯度下降将逐步向最小化 J(𝜽的值更新𝜽，更新公式为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/cb5aaaa1b22ee60c3649f13573e939f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vEkV7jSzEgxxVRJD0sI8lQ.png"/></div></div></figure><p id="a215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中𝜹 𝝫(s)大致是 J(𝜽)相对于𝜽的导数，⍺是学习率]0，1]。</p><p id="8bfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">重要提示</strong>:实际上 J(𝜽相对于𝜽的推导是𝜹【𝝫(st)-𝝫(st+1】，但实际上这个算法的结果更差。</p><p id="458f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经建立了状态值函数的函数近似，现在让我们把这个概念扩展到动作值函数。</p><p id="94dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设𝝫(s,a)为状态<strong class="lb iu"> <em class="nu"> s </em> </strong>的特征，动作<strong class="lb iu"> <em class="nu"> a </em> </strong>，我们要做的是根据一个策略<strong class="lb iu"> π来估计 Q(s，a)的值。</strong></p><p id="441e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与状态值类似，动作值函数为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/a3222aed93e5d31daeb581bc9f1f1f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*9d66jlVHEWQLJTI4R0M26w.png"/></div></figure><p id="06ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">𝜽权重的更新是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/0a47da0cc5816b14284aabab80733e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*Qyp5fQX_zU65nHJ9S3-tew.png"/></div></figure><h2 id="2e2b" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">神经网络</h2><p id="bd93" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">与非线性函数近似(如神经网络)相比，线性函数近似的主要缺点是需要良好的精选特征，这可能需要领域知识。</p><p id="065d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在非线性函数逼近器中，我们将再次重新定义状态和动作值函数 V 和 Q，例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/b49a41b06127bfed52491e86d08aadc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idlwrUszpq61IoQVQF9K1A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/65cbe034d97f84871e5914217d01e11a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_mIjJ9sXtY--TuJY6FOawA.png"/></div></div></figure><p id="a1e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在 v 和 q 是<strong class="lb iu">非线性函数</strong>即<strong class="lb iu"> <em class="nu"> </em> </strong>以𝝫(s) / 𝝫(s，a)和𝜽为参数。<br/>在这个公式中我们要注意的是，特征的数量和𝜽向量的大小不一定相同(就想象一个神经网络)。</p><p id="8d0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面我们现在可以计算 TD 误差𝜹和权重𝜽的更新</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/2234f3e0adc21a71e45752e05f6dd800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAB_jH9oxm1T9Xmn_Ah5pg.png"/></div></div></figure><p id="c429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，𝜹是使用先前已知的𝜽值(此处称为𝜽⁻)和新计算的值来计算的。<br/>神经网络计算的细节可以在反向传播文章<a class="ae ky" rel="noopener" target="_blank" href="/back-propagation-the-easy-way-part-1-6a8cde653f65">第一部分</a>、<a class="ae ky" rel="noopener" target="_blank" href="/back-propagation-the-easy-way-part-2-bea37046c897">第二部分</a>和<a class="ae ky" rel="noopener" target="_blank" href="/back-propagation-the-easy-way-part-3-cc1de33e8397">第三部分</a>中找到。</p><h1 id="d02d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="ee8e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">总之，当类似情况发生时，函数近似有助于找到状态或动作的值，而在计算 V 和 Q 的真实值时，需要完整的计算，并且不从过去的经验中学习。此外，函数逼近节省了计算时间和存储空间。</p><h1 id="8fbf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">相关文章</h1><ul class=""><li id="775f" class="mt mu it lb b lc mn lf mo li of lm og lq oh lu my mz na nb bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/policy-gradient-step-by-step-ac34b629fd55">政策梯度循序渐进</a></li><li id="c4c1" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/policy-based-reinforcement-learning-the-easy-way-8de9a3356083">基于策略的强化学习</a></li><li id="489b" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-actor-critic-7642bdb2b3d2">强化学习中的演员评论家介绍</a></li></ul></div></div>    
</body>
</html>