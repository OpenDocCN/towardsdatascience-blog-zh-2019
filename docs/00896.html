<html>
<head>
<title>Train neural networks using AMD GPU and Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 AMD GPU 和 Keras 训练神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/train-neural-networks-using-amd-gpus-and-keras-37189c453878?source=collection_archive---------6-----------------------#2019-02-11">https://towardsdatascience.com/train-neural-networks-using-amd-gpus-and-keras-37189c453878?source=collection_archive---------6-----------------------#2019-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d81e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">ROCm 平台入门</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/781ad0030a4885914e461df784e4522b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2VUCew6Dc5I066MdZ8CqnA.png"/></div></div></figure><p id="7889" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">AMD 正在开发一个新的高性能计算平台，称为 ROCm。它的目标是创建一个通用的开源环境，能够与 Nvidia(使用 CUDA)和 AMD GPUs 接口(<a class="ae lq" href="https://rocm.github.io/index.html" rel="noopener ugc nofollow" target="_blank">进一步信息</a>)。</p><p id="9e41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本教程将解释如何设置一个神经网络环境，在一个或多个配置中使用 AMD GPUs。</p><p id="b545" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在软件方面:我们将能够使用 Docker 在 ROCm 内核上运行 Tensorflow v1.12.0 作为 Keras 的后端。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/e51102851d2c6859619a727dc7065f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxG6l9EWMS2TDYyAcsN2vg.png"/></div></div></figure><p id="41fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">安装和部署 ROCm 需要特定的硬件/软件配置。</p><h1 id="e867" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">硬件要求</h1><p id="ccc9" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">官方文档(ROCm v2.1)建议采用以下<a class="ae lq" href="https://rocm-documentation.readthedocs.io/en/latest/Installation_Guide/Installation-Guide.html#hardware-support" rel="noopener ugc nofollow" target="_blank">硬件解决方案</a>。</p><h2 id="f926" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated">支持的 CPU</h2><p id="d319" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">当前支持 PCIe Gen3 + PCIe 原子处理器的 CPU 有:</p><ul class=""><li id="a195" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">AMD 锐龙 CPUs</li><li id="a523" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">AMD 锐龙 APU 中的 CPU:</li><li id="81cc" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">AMD 锐龙线程处理器</li><li id="e9e7" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">AMD EPYC CPU；</li><li id="ead1" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">英特尔至强 E7 v3 或更新的 CPUs</li><li id="20ed" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">英特尔至强 E5 v3 或更新的 CPUs</li><li id="a029" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">英特尔至强 E3 v3 或更新的 CPUs</li><li id="67a6" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">英特尔酷睿 i7 v4(i7–4xxx)、酷睿 i5 v4(i5–4xxx)、酷睿 i3 v4(i3–4xxx)或更新的 CPU(即 Haswell 系列或更新的产品)。</li><li id="aa74" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">一些 Ivy Bridge-E 系统</li></ul><h2 id="abd8" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated">支持的 GPU</h2><p id="2bdd" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">ROCm 官方支持使用以下芯片的 AMD GPUs:</p><ul class=""><li id="2faa" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">GFX8 GPUs</li><li id="7fc8" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">“斐济”芯片，如 AMD 公司的镭龙 R9 Fury X 和镭龙本能 MI8</li><li id="fc8d" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">“北极星 10”芯片，如在 AMD 镭龙 RX 480/580 和镭龙本能军情六处</li><li id="46d6" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">“北极星 11”芯片，如 AMD 镭龙 RX 470/570 和镭龙专业 WX 4100</li><li id="e0fd" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">“北极星 12”芯片，如 AMD 公司的镭龙 RX 550 和镭龙 RX 540</li><li id="c4db" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">GFX9 GPUs</li><li id="d78f" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">“织女星 10”芯片，如 AMD 公司的镭龙 RX 织女星 64 和镭龙本能 MI25</li><li id="fef6" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">“织女星 7 纳米”芯片(镭龙本能 MI50，镭龙七)</li></ul><h1 id="062c" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">软件要求</h1><p id="ad5e" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">在软件方面，ROCm 的当前版本(v2.1)仅在基于 Linux 的系统中受支持。</p><blockquote class="np"><p id="1123" class="nq nr it bd ns nt nu nv nw nx ny lp dk translated">ROCm 2.1.x 平台支持以下操作系统:</p><p id="347d" class="nq nr it bd ns nt nu nv nw nx ny lp dk translated">Ubuntu 16.04.x 和 18.04.x(版本 16.04.3 和更新版本或内核 4.13 和更新版本)</p><p id="5034" class="nq nr it bd ns nt nu nv nw nx ny lp dk translated">CentOS 7.4、7.5 和 7.6(使用 devtoolset-7 运行时支持)</p><p id="ecdf" class="nq nr it bd ns nt nu nv nw nx ny lp dk translated">RHEL 7.4、7.5 和 7.6(使用 devtoolset-7 运行时支持)</p></blockquote><h1 id="98fe" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz nz ka me kc oa kd mg kf ob kg mi mj bi translated">测试设置</h1><p id="504e" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">作者使用了以下硬件/软件配置来测试和验证环境:</p><h2 id="24ce" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated"><strong class="ak">硬件</strong></h2><ul class=""><li id="87bc" class="nb nc it kw b kx mk la ml ld oc lh od ll oe lp ng nh ni nj bi translated">CPU:英特尔至强 E5–2630 l</li><li id="c5b5" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">内存:2 个 8 GB</li><li id="f275" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">主板:微星 X99A 金环版</li><li id="bf7f" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">GPU: 2 个 RX480 8GB + 1 个 RX580 4GB</li><li id="dd87" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">固态硬盘:三星 850 Evo (256 GB)</li><li id="fe4c" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">硬盘:WDC 1TB</li></ul><h2 id="803e" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated"><strong class="ak">软件</strong></h2><ul class=""><li id="a71e" class="nb nc it kw b kx mk la ml ld oc lh od ll oe lp ng nh ni nj bi translated">操作系统:LTS Ubuntu 18.04</li></ul></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="fbd4" class="ls lt it bd lu lv om lx ly lz on mb mc jz oo ka me kc op kd mg kf oq kg mi mj bi translated">ROCm 安装</h1><p id="99ec" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">为了让一切正常工作，建议在全新安装的操作系统中开始安装过程。以下步骤<a class="ae lq" href="https://rocm.github.io/index.html" rel="noopener ugc nofollow" target="_blank">参照 Ubuntu 18.04 LTS 操作系统，其他操作系统请参照</a><a class="ae lq" href="https://rocm-documentation.readthedocs.io/en/latest/Installation_Guide/Installation-Guide.html#installing-from-amd-rocm-repositories" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="359b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一步是安装 ROCm 内核和依赖项:</p><h2 id="37c0" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated"><strong class="ak">更新你的系统</strong></h2><p id="6c2a" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">打开一个新的终端<code class="fe or os ot ou b">CTRL + ALT + T</code></p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="e9ae" class="mp lt it ou b gy oz pa l pb pc">sudo apt update<br/>sudo apt dist-upgrade<br/>sudo apt install libnuma-dev<br/>sudo reboot</span></pre><h2 id="b5da" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated"><strong class="ak">添加 ROCm apt 库</strong></h2><p id="a747" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">要下载和安装 ROCm stack，需要添加相关的存储库:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="6c6b" class="mp lt it ou b gy oz pa l pb pc">wget -qO - http://repo.radeon.com/rocm/apt/debian/rocm.gpg.key | sudo apt-key add -</span><span id="98d5" class="mp lt it ou b gy pd pa l pb pc">echo 'deb [arch=amd64] http://repo.radeon.com/rocm/apt/debian/ xenial main' | sudo tee /etc/apt/sources.list.d/rocm.list</span></pre><h2 id="8504" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated"><strong class="ak">安装 ROCm </strong></h2><p id="d038" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">现在需要更新 apt 库列表并安装<code class="fe or os ot ou b">rocm-dkms</code>元包:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="5b02" class="mp lt it ou b gy oz pa l pb pc">sudo apt update<br/>sudo apt install rocm-dkms</span></pre><h2 id="d275" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated">设置权限</h2><p id="88bc" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">官方文档建议使用当前用户创建一个新的<code class="fe or os ot ou b">video</code>组来访问 GPU 资源。</p><p id="f7c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，检查系统中的组，发出:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="9814" class="mp lt it ou b gy oz pa l pb pc">groups</span></pre><p id="47b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后将您自己添加到视频群组:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="69bb" class="mp lt it ou b gy oz pa l pb pc">sudo usermod -a -G video $LOGNAME</span></pre><p id="88b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能希望确保您添加到系统中的任何未来用户都被默认放入“视频”组。为此，您可以运行以下命令:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="925b" class="mp lt it ou b gy oz pa l pb pc">echo 'ADD_EXTRA_GROUPS=1' | sudo tee -a /etc/adduser.conf<br/>echo 'EXTRA_GROUPS=video' | sudo tee -a /etc/adduser.conf</span></pre><p id="4cc0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后重新启动系统:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="403a" class="mp lt it ou b gy oz pa l pb pc">reboot</span></pre><h2 id="5ab3" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated">测试 ROCm 堆栈</h2><p id="c192" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">现在建议发出以下命令来测试 ROCm 安装。</p><p id="bacf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">打开一个新的终端<code class="fe or os ot ou b">CTRL + ALT + T</code>，发出以下命令:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="73ef" class="mp lt it ou b gy oz pa l pb pc">/opt/rocm/bin/rocminfo</span></pre><p id="da96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出应该如下所示:<a class="ae lq" href="https://gist.github.com/mattiavarile/957193417b2a5b8d647759d0c3bfb537" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="9d74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后复核签发:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="1a65" class="mp lt it ou b gy oz pa l pb pc">/opt/rocm/opencl/bin/x86_64/clinfo</span></pre><p id="cb93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出应该是这样的:<a class="ae lq" href="https://gist.github.com/mattiavarile/8ecff9d728eac3d08584271720269e9d" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="54e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">官方文档最后建议将 ROCm 二进制文件添加到 PATH:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="6b06" class="mp lt it ou b gy oz pa l pb pc">echo 'export PATH=$PATH:/opt/rocm/bin:/opt/rocm/profiler/bin:/opt/rocm/opencl/bin/x86_64' | sudo tee -a /etc/profile.d/rocm.sh</span></pre><p id="906a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">恭喜你！ROCm 已正确安装在您的系统中，并且命令:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="67dc" class="mp lt it ou b gy oz pa l pb pc">rocm-smi</span></pre><p id="6eb2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">应该显示您的硬件信息和统计数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/4f72c3d478d661680847af027b49aaff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GJAeNidDaztNa6WcwvHozQ.png"/></div></div><figcaption class="pf pg gj gh gi ph pi bd b be z dk">rocm-smi command output</figcaption></figure><p id="702e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="pj">提示:</em> </strong>看看<code class="fe or os ot ou b">rocm-smi -h</code>命令，探索更多的功能和 OC 工具</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="da3f" class="ls lt it bd lu lv om lx ly lz on mb mc jz oo ka me kc op kd mg kf oq kg mi mj bi translated">张量流 Docker</h1><p id="f4a9" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">让 ROCm + Tensorflow 后端工作的最快、最可靠的方法是使用 AMD 开发者提供的 docker 镜像。</p><h2 id="b714" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated">安装 Docker CE</h2><p id="1acd" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">首先，需要安装 Docker。为此，请遵循 Ubuntu 系统的说明:</p><div class="pk pl gp gr pm pn"><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" rel="noopener  ugc nofollow" target="_blank"><div class="po ab fo"><div class="pp ab pq cl cj pr"><h2 class="bd iu gy z fp ps fr fs pt fu fw is bi translated">获取 Ubuntu 的 Docker CE</h2><div class="pu l"><h3 class="bd b gy z fp ps fr fs pt fu fw dk translated">要在 Ubuntu 上开始使用 Docker CE，请确保您满足先决条件，然后安装 Docker。先决条件…</h3></div><div class="pv l"><p class="bd b dl z fp ps fr fs pt fu fw dk translated">docs.docker.com</p></div></div><div class="pw l"><div class="px l py pz qa pw qb ks pn"/></div></div></a></div><p id="5da9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="pj">提示</em> </strong>:为了避免插入<code class="fe or os ot ou b">sudo docker &lt;command&gt;</code>而不是<code class="fe or os ot ou b">docker &lt;command&gt; </code>，向非根用户提供访问权限是很有用的:<a class="ae lq" href="https://docs.docker.com/install/linux/linux-postinstall/" rel="noopener ugc nofollow" target="_blank">将 Docker 作为非根用户管理</a>。</p><h2 id="07e2" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated">拉 ROCm 张量流图像</h2><p id="a3e5" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">现在该拉 AMD 开发者提供的<a class="ae lq" href="https://hub.docker.com/r/rocm/tensorflow" rel="noopener ugc nofollow" target="_blank"> Tensorflow docker </a>了。</p><p id="740c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">打开新的终端<code class="fe or os ot ou b">CTRL + ALT + T</code>并发布:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="1b53" class="mp lt it ou b gy oz pa l pb pc">docker pull rocm/tensorflow</span></pre><p id="47bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几分钟后，映像将被安装到您的系统中，准备就绪。</p><h2 id="5b6e" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated">创造一个持久的空间</h2><p id="fa4a" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">由于 docker 容器的短暂性，一旦 Docker 会话关闭，所有的修改和存储的文件都将随容器一起删除。</p><p id="f024" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在物理驱动器中创建一个永久空间来存储文件和笔记本是非常有用的。更简单的方法是创建一个文件夹，用 docker 容器初始化。为此，发出以下命令:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="e76a" class="mp lt it ou b gy oz pa l pb pc">mkdir /home/$LOGNAME/tf_docker_share</span></pre><p id="9b00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该命令将创建一个名为<code class="fe or os ot ou b">tf_docker_share</code>的文件夹，用于存储和查看 docker 中创建的数据。</p><h2 id="55c3" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated">起始码头工人</h2><p id="e14a" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">现在，在新的容器会话中执行图像。只需发送以下命令:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="19c0" class="mp lt it ou b gy oz pa l pb pc">docker run -i -t \<br/>--network=host \<br/>--device=/dev/kfd \<br/>--device=/dev/dri \<br/>--group-add video \<br/>--cap-add=SYS_PTRACE \<br/>--security-opt seccomp=unconfined \<br/>--workdir=/tf_docker_share \<br/>-v $HOME/tf_docker_share:/tf_docker_share rocm/tensorflow:latest /bin/bash</span></pre><p id="0ddf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">docker 正在目录<code class="fe or os ot ou b">/tf_docker_share</code>上执行，您应该看到类似于:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/3410bc9064deebe03bda87c13608d4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*RBm5_K1x5PdBSkSuDkxwdw.png"/></div></figure><p id="6da9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着你现在正在 Tensorflow-ROCm 虚拟系统中运行。</p><h2 id="91da" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated">安装 Jupyter</h2><p id="8a21" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">Jupyter 是一个非常有用的工具，用于神经网络的开发、调试和测试。不幸的是，它目前没有默认安装在由 ROCm 团队发布的 tensor flow-ROCm Docker image 上。因此需要手动安装 Jupyter。</p><p id="34ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，在 Tensorflow-ROCm 虚拟系统提示符下，</p><p id="6df4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">1.发出以下命令:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="b585" class="mp lt it ou b gy oz pa l pb pc">pip3 install jupyter</span></pre><p id="ca01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它会将 Jupyter 包安装到虚拟系统中。让这个终端开着。</p><p id="0af9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2.打开一个新的端子<code class="fe or os ot ou b">CTRL + ALT + T</code>。</p><p id="0b01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">找到发出命令的<code class="fe or os ot ou b">CONTAINER ID</code>:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="2e98" class="mp lt it ou b gy oz pa l pb pc">docker ps</span></pre><p id="363a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">应该会出现一个类似如下的表格:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/025e432eead59d91a2abf07cded24dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qysKWuq-QmgdD1SeuDLGXw.png"/></div></div><figcaption class="pf pg gj gh gi ph pi bd b be z dk">Container ID on the left</figcaption></figure><p id="a0a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一列表示被执行容器的<em class="pj">容器 ID </em>。复制它，因为下一步需要它。</p><p id="6ad1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3.是时候<em class="pj">提交</em>了，永久地写入图像的修改。从同一个终端，执行:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="1e15" class="mp lt it ou b gy oz pa l pb pc">docker commit &lt;container-id&gt; rocm/tensorflow:&lt;tag&gt;</span></pre><p id="70bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中<code class="fe or os ot ou b">tag</code>值是任意名称，例如<code class="fe or os ot ou b">personal</code>。</p><p id="efed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">4.要再次检查图像是否已正确生成，请从同一终端发出以下命令:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="2550" class="mp lt it ou b gy oz pa l pb pc">docker images</span></pre><p id="9cb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这应该会生成如下所示的表格:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qe"><img src="../Images/842b3a092d5f01ffd9b7a9c150eb63cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XCd_gB3uCrws6HfQpze4YQ.png"/></div></div></figure><p id="de37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得注意的是，在本教程的剩余部分，我们将引用这个新生成的图像。</p><p id="a9c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用新的<code class="fe or os ot ou b">docker run</code>命令，看起来像:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="ed3a" class="mp lt it ou b gy oz pa l pb pc">docker run -i -t \<br/>--network=host \<br/>--device=/dev/kfd \<br/>--device=/dev/dri \<br/>--group-add video \<br/>--cap-add=SYS_PTRACE \<br/>--security-opt seccomp=unconfined \<br/>--workdir=/tf_docker_share \<br/>-v $HOME/tf_docker_share:/tf_docker_share rocm/tensorflow:&lt;tag&gt; /bin/bash</span></pre><p id="efd9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，<code class="fe or os ot ou b">tag</code>的值是任意的，例如<code class="fe or os ot ou b">personal</code>。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="8063" class="ls lt it bd lu lv om lx ly lz on mb mc jz oo ka me kc op kd mg kf oq kg mi mj bi translated">进入 Jupyter 笔记本电脑环境</h1><p id="49f8" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">我们终于可以进入木星的环境了。在其中，我们将使用 Tensorflow v1.12 作为后端，Keras 作为前端，创建第一个神经网络。</p><h2 id="1cb0" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated">清洁</h2><p id="6973" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">首先关闭所有先前执行的 Docker 容器。</p><ol class=""><li id="c0a6" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp qf nh ni nj bi translated">检查已经打开的容器:</li></ol><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="085c" class="mp lt it ou b gy oz pa l pb pc">docker ps</span></pre><p id="c956" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2.关闭所有码头集装箱:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="fa8b" class="mp lt it ou b gy oz pa l pb pc">docker container stop &lt;container-id1&gt; &lt;container-id2&gt; ... &lt;container-idn&gt;</span></pre><p id="1f14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3.关闭所有已经打开的终端。</p><h2 id="3fa2" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated">执行 Jupyter</h2><p id="4faf" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">让我们打开一个新的终端<code class="fe or os ot ou b">CTRL + ALT + T</code>:</p><ol class=""><li id="b147" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp qf nh ni nj bi translated">运行一个新的 Docker 容器(<code class="fe or os ot ou b">personal</code>标签将被默认使用):</li></ol><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="d355" class="mp lt it ou b gy oz pa l pb pc">docker run -i -t \<br/>--network=host \<br/>--device=/dev/kfd \<br/>--device=/dev/dri \<br/>--group-add video \<br/>--cap-add=SYS_PTRACE \<br/>--security-opt seccomp=unconfined \<br/>--workdir=/tf_docker_share \<br/>-v $HOME/tf_docker_share:/tf_docker_share rocm/tensorflow:personal /bin/bash</span></pre><p id="c0d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您应该登录 Tensorflow-ROCm docker 容器提示符。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/3410bc9064deebe03bda87c13608d4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*RBm5_K1x5PdBSkSuDkxwdw.png"/></div><figcaption class="pf pg gj gh gi ph pi bd b be z dk">Logged into docker container</figcaption></figure><p id="adbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2.执行 Jupyter 笔记本:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="520f" class="mp lt it ou b gy oz pa l pb pc">jupyter notebook --allow-root --port=8889</span></pre><p id="d8dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">应该会出现一个新的浏览器窗口，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qg"><img src="../Images/24fc5b4b8ad99da4176a768f0b6a187b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9feNZT0gd5li0WXH5V7hTA.png"/></div></div><figcaption class="pf pg gj gh gi ph pi bd b be z dk">Jupyter root directory</figcaption></figure><p id="22f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果新标签没有自动出现，在浏览器上，返回到执行<code class="fe or os ot ou b">jupyter notebook</code>命令的终端。在底部，有一个链接(在上面按下<code class="fe or os ot ou b">CTRL + left mouse button</code>)然后，浏览器中的一个新标签会将你重定向到 Jupyter 根目录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qh"><img src="../Images/492f1530d28888fee8ddd062b228e9a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09RrmJfYl4envIS8eArTPQ.png"/></div></div><figcaption class="pf pg gj gh gi ph pi bd b be z dk">Typical Jupyter notebook output. The example link is on the bottom</figcaption></figure></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="7f23" class="ls lt it bd lu lv om lx ly lz on mb mc jz oo ka me kc op kd mg kf oq kg mi mj bi translated">用 Keras 训练神经网络</h1><p id="8a10" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">在本教程的最后一部分，我们将在<a class="ae lq" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> MNIST 数据集</a>上训练一个简单的神经网络。我们将首先建立一个完全连接的神经网络。</p><h2 id="acdc" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated">全连接神经网络</h2><p id="6656" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">让我们创建一个新的笔记本，从 Jupyter 根目录的右上角菜单中选择<em class="pj"> Python3 </em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qi"><img src="../Images/7f0be720db472680e44b10cec83e7490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vNj8jKr-hXnFj4OxnGHVBQ.png"/></div></div><figcaption class="pf pg gj gh gi ph pi bd b be z dk">The upper-right menu in Jupyter explorer</figcaption></figure><p id="2ae4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个新的 Jupiter 笔记本应该会在新的浏览器选项卡中弹出。通过点击窗口左上角的<code class="fe or os ot ou b">Untitled</code>将其重命名为<code class="fe or os ot ou b">fc_network</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qj"><img src="../Images/e656ca65d28c20021231e254680ffc74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pi4kNssZp3_6HYOQ0qW9rw.png"/></div></div><figcaption class="pf pg gj gh gi ph pi bd b be z dk">Notebook renaming</figcaption></figure><p id="b99f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们检查 Tensorflow 后端。在第一个单元格中插入:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="88c6" class="mp lt it ou b gy oz pa l pb pc">import tensorflow as tf; print(tf.__version__)</span></pre><p id="f9bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后按<code class="fe or os ot ou b">SHIFT + ENTER</code>执行。输出应该类似于:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qg"><img src="../Images/4d520f4543e66e5c39d1ea08c0ec8d64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPeCkZPyTCiRgmbA-4pqwQ.png"/></div></div><figcaption class="pf pg gj gh gi ph pi bd b be z dk">Tensorflow V1.12.0</figcaption></figure><p id="fa6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们用的是 Tensorflow v1.12.0。</p><p id="b7d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们导入一些有用的函数，接下来使用:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="ca83" class="mp lt it ou b gy oz pa l pb pc">from tensorflow.keras.datasets import mnist<br/>from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import Dense, Dropout<br/>from tensorflow.keras.optimizers import RMSprop<br/>from tensorflow.keras.utils import to_categorical</span></pre><p id="2ce3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们设置批量大小、时期和类的数量。</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="2741" class="mp lt it ou b gy oz pa l pb pc">batch_size = 128<br/>num_classes = 10<br/>epochs = 10</span></pre><p id="0105" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在将下载并预处理输入，将它们加载到系统内存中。</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="7985" class="mp lt it ou b gy oz pa l pb pc"># the data, split between train and test sets<br/>(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><span id="251b" class="mp lt it ou b gy pd pa l pb pc">x_train = x_train.reshape(60000, 784)<br/>x_test = x_test.reshape(10000, 784)<br/>x_train = x_train.astype('float32')<br/>x_test = x_test.astype('float32')<br/>x_train /= 255<br/>x_test /= 255<br/>print(x_train.shape[0], 'train samples')<br/>print(x_test.shape[0], 'test samples')</span><span id="e4fc" class="mp lt it ou b gy pd pa l pb pc"># convert class vectors to binary class matrices<br/>y_train = to_categorical(y_train, num_classes)<br/>y_test = to_categorical(y_test, num_classes)</span></pre><p id="b391" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是时候定义神经网络架构了:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="b22a" class="mp lt it ou b gy oz pa l pb pc">model = Sequential()<br/>model.add(Dense(512, activation='relu', input_shape=(784,)))<br/>model.add(Dropout(0.2))<br/>model.add(Dense(512, activation='relu'))<br/>model.add(Dropout(0.2))<br/>model.add(Dense(num_classes, activation='softmax'))</span></pre><p id="8ea0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用一个非常简单的双层全连接网络，每层有 512 个神经元。它还包括神经元连接 20%的下降概率，以防止过度拟合。</p><p id="5b6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看网络架构的一些见解:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="0bfb" class="mp lt it ou b gy oz pa l pb pc">model.summary()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qk"><img src="../Images/3f4e721f45c586f8c23c9288018f3f5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*-UDGtwth-nesxkzQ-0Ql5w.png"/></div><figcaption class="pf pg gj gh gi ph pi bd b be z dk">Network architecture</figcaption></figure><p id="70be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管问题很简单，但我们有相当多的参数需要训练(大约 700.000)，这也意味着相当大的计算功耗。卷积神经网络将解决降低计算复杂性的问题。</p><p id="1050" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，编译模型:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="7723" class="mp lt it ou b gy oz pa l pb pc">model.compile(loss='categorical_crossentropy',<br/>              optimizer=RMSprop(),<br/>              metrics=['accuracy'])</span></pre><p id="4c30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并开始训练:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="db9e" class="mp lt it ou b gy oz pa l pb pc">history = model.fit(x_train, y_train,<br/>                    batch_size=batch_size,<br/>                    epochs=epochs,<br/>                    verbose=1,<br/>                    validation_data=(x_test, y_test))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qh"><img src="../Images/c2a68c9256e656d66a25ccd771782fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-arLbyHys9q77jSj8t6vPQ.png"/></div></div><figcaption class="pf pg gj gh gi ph pi bd b be z dk">Training process</figcaption></figure><p id="3b5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">神经网络已经在单个 RX 480 上以相当高的 47us/step 进行了训练。相比之下，Nvidia Tesla K80 达到了 43us/step，但贵了 10 倍。</p><h2 id="3227" class="mp lt it bd lu mq mr dn ly ms mt dp mc ld mu mv me lh mw mx mg ll my mz mi na bi translated">多 GPU 训练</h2><p id="4100" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">作为一个额外的步骤，如果您的系统有多个 GPU，可以利用 Keras 功能，以减少培训时间，在不同的 GPU 之间分割批处理。</p><p id="d8b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，首先需要通过声明一个环境变量来指定用于训练的 GPU 数量(将以下命令放在单个单元上并执行):</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="449f" class="mp lt it ou b gy oz pa l pb pc">!export HIP_VISIBLE_DEVICES=0,1,...</span></pre><p id="58db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从 0 到…的数字定义了用于训练的 GPU。如果您想禁用 GPU 加速，只需:</p><pre class="kj kk kl km gt ov ou ow ox aw oy bi"><span id="5650" class="mp lt it ou b gy oz pa l pb pc">!export HIP_VISIBLE_DEVICES=-1</span></pre><p id="3cfd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还需要添加<code class="fe or os ot ou b">multi_gpu_model</code>功能。</p><p id="99b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">举个例子，如果你有 3 个 GPU，前面的代码会<a class="ae lq" href="https://gist.github.com/mattiavarile/223d9c13c9f1919abe9a77931a4ab6c1" rel="noopener ugc nofollow" target="_blank">相应地</a>修改。</p><h1 id="ef96" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">结论</h1><p id="29c5" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">本教程到此结束。下一步将在 MNIST 数据集上测试卷积神经网络。比较单个和多个 GPU 的性能。</p><p id="305e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里相关的是，AMD GPUs 在计算负载下表现相当好，而价格只是它的一小部分。GPU 市场正在快速变化，ROCm 为研究人员、工程师和初创公司提供了非常强大的开源工具，可以采用，从而降低了硬件设备的前期成本。</p><p id="f24e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="pj">条乘</em> <a class="ae lq" href="http://www.linkedin.com/in/mattia-varile" rel="noopener ugc nofollow" target="_blank"> <em class="pj">条乘</em> </a></p><p id="59ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请随意评论这篇文章，以提高他的质量和效果。</p></div></div>    
</body>
</html>