<html>
<head>
<title>Databases: Explaining Data Normalization, Data Anomalies and DBMS Keys</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库:解释数据规范化、数据异常和 DBMS 键</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/softly-explained-data-normalization-data-anomalies-and-dbms-keys-f8122aefaeb3?source=collection_archive---------3-----------------------#2019-11-28">https://towardsdatascience.com/softly-explained-data-normalization-data-anomalies-and-dbms-keys-f8122aefaeb3?source=collection_archive---------3-----------------------#2019-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="67b2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据科学工程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9889d6c3c01357c15e18307fd5becc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQ1vUlTGGKDb0RcXfL9sWA.jpeg"/></div></div></figure><p id="e806" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章将对数据库规范化和它的其他方面做一个简短的解释。俗话说，“人无完人！”我也不例外，所以请随时评论我可能犯的任何错误。</p><p id="48fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">注意:数据库的领域是巨大的，基于这篇文章不应该被低估。</em></p><p id="a19d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要规范化是为了什么？要解决这些问题:</p><h1 id="76a8" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">反常</h1><p id="83f1" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><strong class="kw iu"> 1- </strong> <strong class="kw iu">更新异常</strong>:假设我们在一个表格中有 10 列，其中 2 列称为员工姓名和员工地址。现在，如果一名员工改变了位置，我们就必须更新该表。但问题是，如果表没有被规范化，一个雇员可能有多个条目，当更新所有这些条目时，其中一个可能会丢失。</p><p id="fe2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2-插入异常:假设我们有一个有 4 列的表。学号，学名，学生地址，学生成绩。现在，当一个新生入学时，即使前三个属性可以填写，但第四个属性将为空值，因为他还没有任何分数。</p><p id="a601" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> 3-删除异常</strong>:该异常表示从表格中删除了不必要的重要信息。假设我们有学生的信息和他们参加的课程，如下所示(学生 ID、学生姓名、课程、地址)。如果任何学生离开学校，那么与该学生相关的条目将被删除。但是，即使课程取决于学校而不是学生，删除操作也会删除课程信息。</p><p id="f095" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">规范化试图将表细化到可以避免这些问题的状态。简而言之，它试图将表分成多个表，并使用键定义它们之间的关系。</p><h1 id="bd74" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">重要的钥匙</h1><p id="b113" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><strong class="kw iu"> a)主键</strong>:这个键唯一地标识表中每个条目。该值不能在表中重复，并且不能包含空值。通常第一列被定义为主键。示例(学号)。</p><p id="c9b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> b)外键:</strong>该键可以有重复的值，但是为了唯一地标识每个条目，该表仍然可以有独立于外键列的主键列。但是，外键将创建与另一个表的关系，在该表中，这些值被定义为主键。</p><p id="e25d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> c)复合键</strong>:这是定义多列为主键的方法。在表中没有列具有唯一值的情况下，我们可以将两列或两列以上的组合定义为唯一的，并将其设置为主键。例如:(学生姓名、地址、分数等。)在这里，学生可能有相同的名字，因此我们将学生名字和地址的组合定义为主键。现在更不可能有同名同姓的学生了。</p><p id="c2bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> d)候选键</strong>:简单的说，候选键是一个键，也可以作为主键。例如:(学生证，学生证号，地址，标记)这里学生证是主键，因为它没有重复值，没有空值。然而，学生卷号还包含主键的所有属性，因此被视为候选键。</p><p id="4223" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> f)代理键</strong>:这意味着当没有其他列能够保存主键的属性时，人工创建的唯一标识表中每个条目的值。它是一个附加列，通常保存整数值。</p><p id="3249" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，我们不能对主键在另一个表中作为外键的表进行任何更改。换句话说，如果主键被另一个表中的外键引用，我们就不能对它进行更改。或者说，如果父表有一个外键引用父表的主键的子表，我们就不能对其主键进行更改。</p><h1 id="8850" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">正常化</h1><p id="2457" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">1NF:第一个范式表示表格的每个单元格必须只有一个值。因此，行和列的每个交集必须包含原子值。例如:如果我们有一个列名 phone_number，则该列的每一行必须只保存一个电话号码。</p><p id="39e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2NF:我们在上面看到了候选人密钥，这就是它的作用。2NF 规则表示表中没有非质数属性依赖于任何候选键。简而言之，如果表代表两个不同的实体，那么它应该被分解成它们自己的实体。例如:如果我们有一个表(学生 ID、学生姓名、课程编号、课程名称、教师 ID、教师姓名)，它表示由学校每位教师讲授的每门课程中注册的每个学生的信息。由于它代表了三种不同的实体，因此必须将其标准化为 2NF 形式。</p><p id="bc31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3NF:此规则表示表必须是 2NF 形式，并且每个表应该只包含非过渡依赖于自己表的主键的列。简单地说，如果我们有一个表(交易 ID，价格，数量，total_sales)，这里的总销售额是价格和数量(价格*数量)的乘积。因此，销售过渡依赖于交易标识，这是这里的一个主键。所以每个属性必须直接依赖于主键。</p></div></div>    
</body>
</html>