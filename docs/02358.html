<html>
<head>
<title>Build Your Own Clustering Based Recommendation Engine in 15 minutes !!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 15 分钟内构建您自己的基于聚类的推荐引擎！！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-your-own-clustering-based-recommendation-engine-in-15-minutes-bdddd591d394?source=collection_archive---------1-----------------------#2019-04-18">https://towardsdatascience.com/build-your-own-clustering-based-recommendation-engine-in-15-minutes-bdddd591d394?source=collection_archive---------1-----------------------#2019-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="601f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">推荐引擎是机器学习技术在当前互联网时代最流行的应用之一。这些广泛用于电子商务网站推荐类似产品和电影推荐网站。他们负责为我们生成各种定制的新闻建议。这将推动用户参与更多内容，从而为组织带来更好的用户体验和更多收入。因此，它们在今天的工业中极其重要。</p><p id="7b46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">推荐引擎基本上过滤数据并向用户推荐最相关的结果。这些结果是以最大可能感兴趣的方式推荐的。现在，所有的推荐引擎都有用户数据和他们的历史记录，可以用来创建他们的过滤算法。这最终帮助他们为每个独特的用户生成非常准确的推荐。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e0c3748b0fc91dd8625f58f40edf4bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KlAkw4VQbcrW8m9P.jpg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">User-based filtering is based on history of users and similarity b/w them from their purchase histories for example. But, Item-based recommendations are based on content based similarity. Like, “how many times few items are bought together”. Next time, most frequent of these purchases will be recommended together.</figcaption></figure><p id="ee9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在协同过滤的情况下,“用户行为”被用于推荐项目。这些推荐可以利用用户-用户相似性或者基于项目-项目相似性来生成。并且基于该相似性度量，向用户提供建议。但是，让我们考虑一个场景，在这个场景中，我们没有可用的用户数据，但是我们仍然必须向用户推荐商品。</p><blockquote class="le"><p id="fde6" class="lf lg it bd lh li lj lk ll lm ln kn dk translated">没有用户数据怎么办？我们的推荐引擎现在将如何工作？</p></blockquote><p id="c816" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">生成推荐的问题现在被简单地转化为类似聚类的问题。其中相似性度量基于“在生成推荐时，两个项目有多接近？”。用于生成推荐的度量将基于两个项目的相似性，如这些项目之间的向量距离。我们将针对 Pluralsight 的在线课程文本数据进行讨论。让我们来做一个仅基于我们可用的项目数据的推荐引擎。</p><h1 id="7a6c" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">在线课程推荐系统</h1><p id="5796" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">在本文中，我们将从 Pluralsight 的课程数据中构建一个推荐系统，并查看可以对我们基于聚类的解决方案进行的进一步改进。我们将按下述顺序讨论该项目的整个数据分析流程。为了节省时间，你可以直接参考<a class="ae mw" href="https://github.com/ashishrana160796/Online-Course-Recommendation-System" rel="noopener ugc nofollow" target="_blank">项目库</a>并遵循精心制作的<a class="ae mw" href="https://github.com/ashishrana160796/Online-Course-Recommendation-System/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> README.md </a>文件。此外，可以为提到的每个模块直接运行<a class="ae mw" href="https://github.com/ashishrana160796/Online-Course-Recommendation-System/blob/master/model_train_k_30.py" rel="noopener ugc nofollow" target="_blank">实用程序脚本</a>。</p><blockquote class="mx my mz"><p id="11ff" class="jq jr na js b jt ju jv jw jx jy jz ka nb kc kd ke nc kg kh ki nd kk kl km kn im bi translated">1.简介:了解你的数据</p><p id="2d45" class="jq jr na js b jt ju jv jw jx jy jz ka nb kc kd ke nc kg kh ki nd kk kl km kn im bi translated">2.架构设计:构建实用工具</p><p id="5b79" class="jq jr na js b jt ju jv jw jx jy jz ka nb kc kd ke nc kg kh ki nd kk kl km kn im bi translated">3.预处理步骤</p><p id="d9c4" class="jq jr na js b jt ju jv jw jx jy jz ka nb kc kd ke nc kg kh ki nd kk kl km kn im bi translated">4.问题讨论、模型训练和优化</p><p id="3488" class="jq jr na js b jt ju jv jw jx jy jz ka nb kc kd ke nc kg kh ki nd kk kl km kn im bi translated">5.工作推荐系统</p><p id="6676" class="jq jr na js b jt ju jv jw jx jy jz ka nb kc kd ke nc kg kh ki nd kk kl km kn im bi translated">6.结论&amp;主题建模的未来改进(特别是 LDA)</p></blockquote><blockquote class="le"><p id="9ed9" class="lf lg it bd lh li ne nf ng nh ni kn dk translated"><strong class="ak"> <em class="nj">超级省时提示</em> </strong>:打开项目的<a class="ae mw" href="https://github.com/ashishrana160796/Online-Course-Recommendation-System" rel="noopener ugc nofollow" target="_blank"> github </a>库，按照<a class="ae mw" href="https://github.com/ashishrana160796/Online-Course-Recommendation-System/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> README.md </a>文件运行代码即可😉</p></blockquote><h1 id="c1d2" class="lt lu it bd lv lw lx ly lz ma mb mc md me nk mg mh mi nl mk ml mm nm mo mp mq bi translated">简介:了解你的数据</h1><p id="e1ef" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">该项目使用的数据是 Pluralsight 网站上的课程列表和描述。要获取课程数据，只需运行下面提到的 ReST API 查询。但是，为了获得用户注册数据，让我们说一个基于协作过滤器的引擎。</p><p id="f271" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，获取在<a class="ae mw" href="https://www.pluralsight.com/product/professional-services/white-paper/api" rel="noopener ugc nofollow" target="_blank">文档</a>中提到的 ReST api-token，然后进行 ReST 查询，以获取关于该网站上所有课程和注册该网站的各个用户的数据。如果您想要获取用户相关数据，则需要此键。否则，为了获得简单的课程相关数据，我们可以编写如下 ReST 查询。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="8a20" class="ns lu it no b gy nt nu l nv nw"># Input<br/>http://api.pluralsight.com/api-v0.9/courses</span><span id="67c8" class="ns lu it no b gy nx nu l nv nw"># Output: A <em class="na">Courses.csv</em> file for download. It will be having below mentioned structure.</span><span id="8e14" class="ns lu it no b gy nx nu l nv nw">CourseId,CourseTitle,DurationInSeconds,ReleaseDate,Description,AssessmentStatus,IsCourseRetired</span><span id="f8df" class="ns lu it no b gy nx nu l nv nw">abts-advanced-topics,BizTalk 2006 Business Process Management,22198,2008-10-25,"This course covers Business Process Management features in BizTalk Server 2006, including web services, BAM, hosting, and BTS 2009 features",Live,no<br/>abts-fundamentals,BizTalk 2006<br/>...</span></pre><p id="9b8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们仅限于发动机制造的课程数据。否则，这种方法将与其他推荐引擎文章非常相似。通过查看这些数据，我们发现以下几点在训练模型时非常重要。您也可以打开<em class="na"> Courses.csv </em>文件，自己进行如下观察。</p><ol class=""><li id="ff7d" class="ny nz it js b jt ju jx jy kb oa kf ob kj oc kn od oe of og bi translated">课程数据文本描述针对课程 Id、课程标题和课程描述列呈现。因此，在构建我们的推荐引擎时，这些列是我们感兴趣的。利用这些列中的文本数据，我们将能够构建词向量，我们的模型将在预测结果时使用这些词向量。此外，大部分信息仅出现在<em class="na">【描述】</em>栏中。因此，没有描述的课程将从培训中删除。</li><li id="1c3d" class="ny nz it js b jt oh jx oi kb oj kf ok kj ol kn od oe of og bi translated">“已退休”栏描述了网站上课程的当前状态，即网站上目前是否有该课程。因此，我们不想推荐我们训练有素的模型的退役课程。但是，我们绝对可以在我们的训练数据中使用它们。</li><li id="7b6b" class="ny nz it js b jt oh jx oi kb oj kf ok kj ol kn od oe of og bi translated">并对该数据的预处理进行了讨论。数据中显然存在一些额外的'-'标记、不同的大小写和停用词。我们将相应地预处理我们的文本，只关注名词/名词短语。</li></ol><p id="33b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下一节中，我们将讨论正在开发的这个推荐实用程序的基本架构。有了这个架构，最终我们将拥有一个完整的机器学习工具，它将课程数据作为输入，并基于用户查询生成建议。</p><h1 id="00d8" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">架构设计:构建实用工具</h1><p id="444a" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">下图清楚地说明了我们在这个数据科学项目中的渠道。请在以从左到右的方式进一步阅读之前先看一下。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi om"><img src="../Images/4231b069a63388dc9b38097c460c93d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7k07UfBqLREWGWrUG_9_ig.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk"><strong class="bd on">Three main components:</strong> 1. Pre-process &amp; Train; 2. Optimizations; 3. Recommendation Utility Tool</figcaption></figure><p id="bbd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个实用工具主要分为三个组件，我们将在接下来的章节中详细讨论这些组件。主要是对模型进行训练和优化，减少误差。之后，我们将编写实用工具，该工具将基于唯一课程 id 的输入查询生成推荐。</p><p id="5134" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记住上面的工具架构，让我们转到预处理步骤，并开始为我们的模型进行数据摄取步骤。</p><h1 id="b5fd" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">预处理步骤</h1><p id="b2a7" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">按照下面的代码片段，我们将做一些小的文本预处理，如删除所有标点符号。此外，在大量的术语中,“ll”被用在诸如“we’ll”、“you’ll”等情况中。这些也从<em class="na">‘描述’</em>文本中删除。我们还将消除停用词，并以适当的方式合并包含描述、课程 id、标题的列。请参考下面的代码片段，以遵循上述步骤。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="df54" class="ns lu it no b gy nt nu l nv nw">import pandas as pd</span><span id="8da4" class="ns lu it no b gy nx nu l nv nw"># 1. read data, from source<br/># "Courses.csv" file has been renamed<br/>course_df = pd.read_csv("data/courses.csv")</span><span id="f03c" class="ns lu it no b gy nx nu l nv nw"># 2. drop rows with NaN values for any column, specifically 'Description'<br/># Course with no description won't be of much use<br/>course_df = course_df.dropna(how='any')</span><span id="1cdb" class="ns lu it no b gy nx nu l nv nw"># 3. Pre-processing step: remove words like we'll, you'll, they'll etc.<br/>course_df['Description'] = course_df['Description'].replace({"'ll": " "}, regex=True)</span><span id="ef06" class="ns lu it no b gy nx nu l nv nw"># 4. Another Pre-preprocessing step: Removal of '-' from the CourseId field<br/>course_df['CourseId'] = course_df['CourseId'].replace({"-": " "}, regex=True)</span><span id="a687" class="ns lu it no b gy nx nu l nv nw"># 5. Combine three columns namely: CourseId, CourseTitle, Description<br/>comb_frame = course_df.CourseId.str.cat(" "+course_df.CourseTitle.str.cat(" "+course_df.Description))</span><span id="c60a" class="ns lu it no b gy nx nu l nv nw"># 6. Remove all characters except numbers &amp; alphabets<br/># Numbers are retained as they are related to specific course series also<br/>comb_frame = comb_frame.replace({"[^A-Za-z0-9 ]+": ""}, regex=True)</span></pre><p id="7323" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在对上述数据进行基本的清理步骤后，<em class="na">‘comb _ frame’</em>包含了与课程相关的所有必要的文字描述。之后，让我们移动到这个文本的矢量化，并训练我们的模型。</p><h1 id="1595" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">问题讨论、模型训练和优化</h1><p id="dc17" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">现在，我们将所有需要的文本数据呈现在一个数据框中。但是，我们需要将其转换成有意义的表示。因此，它可以正确地输入到我们的机器学习模型中。</p><p id="5240" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们使用<strong class="js iu"> <em class="na"> tf-idf </em> </strong>权重来表示术语在文档中的重要性。它是对文档中单词重要性的统计度量。该权重与单词在语料库中出现的次数相关，但是被语料库中单词的频率所抵消。</p><p id="d144" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="na"> Tf </em> </strong>中的<strong class="js iu"> <em class="na"> tf-idf </em> </strong>权重衡量文档中的词频。以及<strong class="js iu"> <em class="na"> idf </em> </strong>测量给定语料库中给定术语重要性。这可以从下面提到的公式中推断出来。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="d880" class="ns lu it no b gy nt nu l nv nw"><strong class="no iu">TF(</strong>t<strong class="no iu">)</strong> = (Number of times term <em class="na">'t'</em> appears in a document) <strong class="no iu">/</strong> (Total number of terms in the document)</span><span id="964b" class="ns lu it no b gy nx nu l nv nw"><strong class="no iu">IDF(</strong>t<strong class="no iu">)</strong> = <strong class="no iu">log_e(</strong>Total number of documents <strong class="no iu">/</strong> Number of documents with term <em class="na">'t'</em> in it<strong class="no iu">)</strong></span></pre><p id="0f76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用 scikit learn 将我们的文本数据转换为上面公式中指定的向量矩阵乘积。按照下面的代码片段进行转换。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="9dd2" class="ns lu it no b gy nt nu l nv nw"># Create word vectors from combined frames<br/># Make sure to make necessary imports</span><span id="f3c2" class="ns lu it no b gy nx nu l nv nw">from sklearn.cluster import KMeans<br/>from sklearn import metrics<br/>from sklearn.feature_extraction.text import TfidfVectorizer</span><span id="052d" class="ns lu it no b gy nx nu l nv nw">vectorizer = TfidfVectorizer(stop_words='english')<br/>X = vectorizer.fit_transform(comb_frame)</span></pre><p id="7fdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在此之后，我们可以将这些数据直接输入到我们的 k 均值学习算法中。但是，对于我们的 k-means 算法，我们将需要<strong class="js iu"><em class="na">【k】</em></strong>的理想值，对此我们还没有讨论过。首先，我们可以使用 k=8 的值，因为 Pluralsight 有八种不同类型的课程类别，并检查我们的模型相应训练的预测能力。跟随下面提到的代码片段。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="ad84" class="ns lu it no b gy nt nu l nv nw"># true_k, derived from elbow method and confirmed from pluralsight's website<br/>true_k = 8</span><span id="c178" class="ns lu it no b gy nx nu l nv nw"># Running model with 15 different centroid initializations &amp; maximum iterations are 500<br/>model = KMeans(n_clusters=true_k, init='k-means++', max_iter=500, n_init=15)<br/>model.fit(X)</span></pre><p id="0850" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以观察来自每个聚类的顶词，以查看所形成的聚类在质量上是否良好，或者它们在某种意义上是否需要改进。运行下面提到的片段，观察每个聚类中的热门词。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="a057" class="ns lu it no b gy nt nu l nv nw"># Top terms in each clusters.</span><span id="b85e" class="ns lu it no b gy nx nu l nv nw">print("Top terms per cluster:")<br/>order_centroids = model.cluster_centers_.argsort()[:, ::-1]<br/>terms = vectorizer.get_feature_names()<br/>for i in range(true_k):<br/>    print("Cluster %d:" % i),<br/>    for ind in order_centroids[i, :15]:<br/>        print(' %s' % terms[ind]),<br/>    print</span></pre><p id="8376" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">观察这些单词后，您可能会注意到所有形成的集群都不合适，一些课程类别在多个集群中重复出现(请参考<a class="ae mw" href="https://github.com/ashishrana160796/Online-Course-Recommendation-System" rel="noopener ugc nofollow" target="_blank"> README.md </a>文件)。那现在还是好的(<em class="na">😉</em>)，我们的模型将数量巨大的课程类别细分为其他子类别。因此，给定类别的课程数量的基数问题暴露出来，我们的模型无法解决。</p><p id="68ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到，细分类别平面艺术，电影设计，动画形成了母'创意-专业'类别。由于课程类别之间的数据分布不均，即数据基数的问题，因此形成了这个子类。因此，像“商务-专业”这样课程数量少的课程类别在我们的理想假设中迷失了，因为<strong class="js iu"> k </strong>等于 8。这很容易发生，因为在我们简单的机器学习模型训练中，不经常出现的业务相关术语很容易失去其 tf-idf 权重。</p><p id="b621" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，从这种方法得到的聚类仍然可以通过进一步划分成其他聚类来改进，以用更少数量的课程得到这些更小的课程类别。因为，这些进一步的划分可以公式化为误差最小化的优化问题。我们不想因此过度拟合我们的模型，我们将使用<strong class="js iu"> <em class="na">【肘测试】</em> </strong>方法来寻找<strong class="js iu"> <em class="na"> k </em> </strong>的理想值。<em class="na">这个想法是，每当给定的</em><strong class="js iu"><em class="na">【k’</em></strong><em class="na"/><strong class="js iu"><em class="na"/></strong><em class="na">的值的误差急剧下降时，该值对于形成聚类来说足够好。</em>这些形成的集群将具有尖锐的误差极小值，并将为我们的模型给出令人满意的解决方案。按照下面提到的代码对我们的数据进行弯头测试。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="f02f" class="ns lu it no b gy nt nu l nv nw"># Continuing after vectorization step</span><span id="4cca" class="ns lu it no b gy nx nu l nv nw"># data-structure to store Sum-Of-Square-Errors<br/>sse = {}</span><span id="67b8" class="ns lu it no b gy nx nu l nv nw"># Looping over multiple values of k from 1 to 30<br/>for k in range(1, 40):<br/>    kmeans = KMeans(n_clusters=k, init='k-means++', max_iter=100).fit(X)<br/>    comb_frame["clusters"] = kmeans.labels_<br/>    sse[k] = kmeans.inertia_</span><span id="7aaf" class="ns lu it no b gy nx nu l nv nw"># Plotting the curve with 'k'-value vs SSE<br/>plt.plot(list(sse.keys()), list(sse.values()))<br/>plt.xlabel("Number of cluster")<br/>plt.ylabel("SSE")<br/># Save the Plot in current directory<br/>plt.savefig('elbow_method.png')</span></pre><p id="8d0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行上述代码后，我们得到了下图，在此基础上，我们为 k=30 训练了我们的模型。并为我们的推荐引擎工具实现了相对更好的聚类。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/b628c9b3dd7d6f0e477edfe9150a2d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*YyhoGTr8g4c3y0OGv7A8BQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Slope is drastically diminishing after the value of k=30. Hence, we’ll opt for this value for our model.</figcaption></figure><p id="eb4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，让我们保存我们的模型，继续我们的推荐实用程序脚本设计，并讨论未来的改进方法。所有这些提到的片段都以<a class="ae mw" href="https://github.com/ashishrana160796/Online-Course-Recommendation-System/blob/master/model_train_k_30.py" rel="noopener ugc nofollow" target="_blank"> model_train.py </a>脚本的形式提供，您可以参考它来直接执行。但是，在此之前，请提取 courses.csv 数据文件，并仔细阅读<a class="ae mw" href="https://github.com/ashishrana160796/Online-Course-Recommendation-System" rel="noopener ugc nofollow" target="_blank"> README.md </a>。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="af90" class="ns lu it no b gy nt nu l nv nw"># Save machine learning model<br/>filename = 'finalized_model.sav'<br/>pickle.dump(model, open(filename, 'wb'))</span></pre><h1 id="c947" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">工作推荐系统</h1><p id="4d45" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">我们将为这个推荐模块创建几个实用函数。一个 cluster_predict 函数，它将预测输入其中的任何描述的分类。首选输入是我们之前在<a class="ae mw" href="https://github.com/ashishrana160796/Online-Course-Recommendation-System/blob/master/model_train_k_30.py" rel="noopener ugc nofollow" target="_blank"> model_train.py </a>文件的 comb_frame 中设计的类似“描述”的输入。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="a6a7" class="ns lu it no b gy nt nu l nv nw">def cluster_predict(str_input):<br/>    Y = vectorizer.transform(list(str_input))<br/>    prediction = model.predict(Y)<br/>    return prediction</span></pre><p id="97b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，我们将根据新的 dataframe 列中的描述向量为每个课程分配类别，即<em class="na">‘cluster prediction’</em>。见下文。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="e172" class="ns lu it no b gy nt nu l nv nw"># Create new column for storing predicted categories from our trained model.<br/>course_df['ClusterPrediction'] = ""</span></pre><p id="ce98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将为只有实时课程的数据框存储该聚类类别分数，即删除“无”实时条目的课程。之后，我们将在数据框中为每门课程运行预测函数实用程序，并存储聚类类别。这些存储的类别将在将来与输入查询及其预测类别进行匹配，以生成推荐。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="68cd" class="ns lu it no b gy nt nu l nv nw"># load the complete data in a dataframe<br/>course_df = pd.read_csv("data/courses.csv")</span><span id="51a6" class="ns lu it no b gy nx nu l nv nw"># drop retired course from analysis. But, courses with no descriptions are kept.<br/>course_df = course_df[course_df.IsCourseRetired == 'no']<br/>    <br/># create new column in dataframe which is combination of (CourseId, CourseTitle, Description) in existing data-frame<br/>course_df['InputString'] = course_df.CourseId.str.cat(" "+course_df.CourseTitle.str.cat(" "+course_df.Description))</span><span id="beb2" class="ns lu it no b gy nx nu l nv nw"># Create new column for storing predicted categories from our trained model.<br/>course_df['ClusterPrediction'] = ""</span><span id="b52b" class="ns lu it no b gy nx nu l nv nw"># Cluster category for each live course<br/>course_df['ClusterPrediction']=course_df.apply(lambda x: cluster_predict(course_df['InputString']), axis=0)</span></pre><p id="5da9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，推荐实用函数将预测具有课程 id 的输入查询的课程类别，并且将从上面转换的数据帧<em class="na">‘course _ df’</em>中推荐几个随机课程，该数据帧具有每个课程的预测值。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="bdfd" class="ns lu it no b gy nt nu l nv nw">def recommend_util(str_input):<br/>    <br/>    # match on the basis course-id and form whole 'Description' entry out of it.<br/>    temp_df = course_df.loc[course_df['CourseId'] == str_input]<br/>    temp_df['InputString'] = temp_df.CourseId.str.cat(" "+temp_df.CourseTitle.str.cat(" "+temp_df['Description']))<br/>    str_input = list(temp_df['InputString'])<br/>    </span><span id="1759" class="ns lu it no b gy nx nu l nv nw">    # Predict category of input string category<br/>    prediction_inp = cluster_predict(str_input)<br/>    prediction_inp = int(prediction_inp)</span><span id="16e8" class="ns lu it no b gy nx nu l nv nw">    # Based on the above prediction 10 random courses are recommended from the whole data-frame<br/>    # Recommendation Logic is kept super-simple for current implementation.</span><span id="4296" class="ns lu it no b gy nx nu l nv nw">    temp_df = course_df.loc[course_df['ClusterPrediction'] == prediction_inp]<br/>    temp_df = temp_df.sample(10)<br/>    <br/>    return list(temp_df['CourseId'])</span></pre><p id="461f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用下面给出的查询测试你训练过的推荐引擎。您也可以通过从 courses.csv 获取课程 id 来添加您的查询。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="cedb" class="ns lu it no b gy nt nu l nv nw">queries = ['play-by-play-machine-learning-exposed', 'microsoft-cognitive-services-machine-learning', 'python-scikit-learn-building-machine-learning-models', 'pandas-data-wrangling-machine-learning-engineers', 'xgboost-python-scikit-learn-machine-learning']</span><span id="5be1" class="ns lu it no b gy nx nu l nv nw">for query in queries:<br/>    res = recommend_util(query)<br/>    print(res)</span></pre><h1 id="848c" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论和未来改进</h1><p id="eab2" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">当前推荐引擎的实现本质上是非常原始的。用精确的硬步骤阈值来形成集群的方法是粗糙的，但是给出了用集群化算法实现这些引擎的想法。此外，生成的推荐本质上是随机的。可以采用更具体的方法(如基于最高得分的推荐方法)作为改进。目前，course-id 作为唯一的输入，而不是更好的自然语言输入。但是，这些只是基于实施的改进。</p><p id="7081" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本上，为了将来的改进，用于训练的类别分配机制和模型可以被改变。此外，可以采用来自主题建模的高级和复杂的机制，如潜在狄利克雷分配(LDA)。主题建模是自然语言处理的一个统计分支，它从文档集中提取摘要。我们将使用 LDA，它将一个特定的文档分配给一个特定的主题和一个实数权重分数，该分数将与相应主题的单词相关联。</p><blockquote class="le"><p id="c877" class="lf lg it bd lh li lj lk ll lm ln kn dk translated">只需运行<a class="ae mw" href="https://github.com/ashishrana160796/Online-Course-Recommendation-System/blob/master/lda_train.py" rel="noopener ugc nofollow" target="_blank"> lda_train.py </a>来详细了解 lda 的实现，注释/控制台输出将解释关于正在执行的步骤的一切。</p></blockquote><p id="6f81" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">这些指定的主题及其与单词的关联分数可以作为上述<em class="na"> cluster_prediction </em>函数的预测逻辑基础。但是，这些预测将比当前由 k-means 聚类算法生成的任何推荐更精确。一个基于 gensim 的 LDA 实现在<a class="ae mw" href="https://github.com/ashishrana160796/Online-Course-Recommendation-System/blob/master/lda_train.py" rel="noopener ugc nofollow" target="_blank">这里</a>的同一个<a class="ae mw" href="https://github.com/ashishrana160796/Online-Course-Recommendation-System" rel="noopener ugc nofollow" target="_blank"> github </a>仓库中可用。它的推荐实用程序脚本目前还没有添加，你可以作为家庭作业来尝试。</p><p id="87c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">霍普，你喜欢读它，并得到了一个数据科学项目的小手。如果有任何改进，请在<a class="ae mw" href="https://github.com/ashishrana160796/Online-Course-Recommendation-System" rel="noopener ugc nofollow" target="_blank"> github </a>上做一个公关或公开一个问题。</p></div></div>    
</body>
</html>